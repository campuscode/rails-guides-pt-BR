<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Interface de Consulta do Active Record — Ruby on Rails Guides</title>
  <link rel="stylesheet" type="text/css" href="stylesheets/style.css" data-turbolinks-track="reload">
  <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
  <link rel="stylesheet" type="text/css" href="stylesheets/highlight.css" data-turbolinks-track="reload">
  <link rel="stylesheet" type="text/css" href="stylesheets/search.css" data-turbolinks-track="reload">
  <link href="images/favicon.ico" rel="icon" type="image/x-icon" />
  <script src="javascripts/turbolinks.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/clipboard.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/guides.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/search.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/lunr-documents.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/lunr.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/toggle-theme.js" data-turbolinks-track="reload"></script>
  <meta property="og:title" content="Interface de Consulta do Active Record — Ruby on Rails Guides" />
  <meta name="description" content="Interface de Consulta do Active RecordEste guia cobre diferentes maneiras de recuperar dados de um banco de dados utilizando o Active RecordApós ler esse guia, você saberá: Como encontrar registros usando uma variedade de métodos e condições. Como especificar a ordem, os atributos recuperados, agrupamento e outras propriedades dos registros encontrados. Como usar o eager loading para reduzir o número de consultas necessárias no banco de dados para recuperar os dados. Como utilizar métodos localizadores dinâmicos. Como utilizar encadeamento de métodos para usar múltiplos métodos do Active Record em conjunto. Como checar a existência de determinados registros. Como executar diversos cálculos nos models do Active Record. Como executar o EXPLAIN nas relações." />
  <meta property="og:description" content="Interface de Consulta do Active RecordEste guia cobre diferentes maneiras de recuperar dados de um banco de dados utilizando o Active RecordApós ler esse guia, você saberá: Como encontrar registros usando uma variedade de métodos e condições. Como especificar a ordem, os atributos recuperados, agrupamento e outras propriedades dos registros encontrados. Como usar o eager loading para reduzir o número de consultas necessárias no banco de dados para recuperar os dados. Como utilizar métodos localizadores dinâmicos. Como utilizar encadeamento de métodos para usar múltiplos métodos do Active Record em conjunto. Como checar a existência de determinados registros. Como executar diversos cálculos nos models do Active Record. Como executar o EXPLAIN nas relações." />
  <meta property="og:locale" content="pt_BR" />
  <meta property="og:site_name" content="Guia Ruby on Rails" />
  <meta property="og:image" content="https://avatars.githubusercontent.com/u/4223" />
  <meta property="og:type" content="website" />
</head>
<body class="guide">
  <div>
    <div id="version-badge">v7.0.8</div>
  </div>
  <div id="topNav">
    <div class="wrapper">
      <strong class="more-info-label">Veja mais em <a href="https://rubyonrails.org/">rubyonrails.org:</a> </strong>
      <span class="red-button more-info-button">
        Mais Ruby on Rails
      </span>
      <ul class="more-info-links s-hidden">
        <li class="more-info"><a href="https://rubyonrails.org/blog">Blog</a></li>
        <li class="more-info"><a href="https://guides.rubyonrails.org/">Guia oficial</a></li>
        <li class="more-info"><a href="https://api.rubyonrails.org/">API</a></li>
        <li class="more-info"><a href="https://discuss.rubyonrails.org/">Forum</a></li>
        <li class="more-info"><a href="https://github.com/rails/rails">Contribua no GitHub</a></li>
      </ul>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="Voltar para a página principal">Guiarails.com.br</a></h1>
      <ul class="nav">
        <li><a class="nav-item" href="index.html">Home</a></li>
        <li class="guides-search guides-search-large">
          <input class="search-box search-box-large nav-item" type="text" placeholder="Digite o termo...">
          <div class="search-results"></div>
          <div class="search-spinner">Aguarde...</div>
        </li>
        <li class="guides-index guides-index-large">
          <a href="index.html" id="guidesMenu" class="guides-index-item nav-item">Guias</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <dl class="guides-section-container">
                <div class="guides-section">
                  <dt>Comece aqui</dt>
                  <dd><a href="getting_started.html">Começando com Rails</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Models</dt>
                  <dd><a href="active_record_basics.html">Active Record Basics</a></dd>
                  <dd><a href="active_record_migrations.html">Active Record Migrations</a></dd>
                  <dd><a href="active_record_validations.html">Active Record Validations</a></dd>
                  <dd><a href="active_record_callbacks.html">Active Record Callbacks</a></dd>
                  <dd><a href="association_basics.html">Active Record Associations</a></dd>
                  <dd><a href="active_record_querying.html">Active Record Query Interface</a></dd>
                  <dd><a href="active_model_basics.html">Active Model Basics</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Views</dt>
                  <dd><a href="action_view_overview.html">Action View Overview</a></dd>
                  <dd><a href="layouts_and_rendering.html">Layouts and Rendering in Rails</a></dd>
                  <dd><a href="action_view_helpers.html">Action View Helpers</a></dd>
                  <dd><a href="form_helpers.html">Action View Form Helpers</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Controllers</dt>
                  <dd><a href="action_controller_overview.html">Action Controller Overview</a></dd>
                  <dd><a href="routing.html">Rails Routing from the Outside In</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Outros componentes</dt>
                  <dd><a href="active_support_core_extensions.html">Active Support Core Extensions</a></dd>
                  <dd><a href="action_mailer_basics.html">Action Mailer Basics</a></dd>
                  <dd><a href="action_mailbox_basics.html">Action Mailbox Basics</a></dd>
                  <dd><a href="action_text_overview.html">Action Text Overview</a></dd>
                  <dd><a href="active_job_basics.html">Active Job Basics</a></dd>
                  <dd><a href="active_storage_overview.html">Active Storage Overview</a></dd>
                  <dd><a href="action_cable_overview.html">Action Cable Overview</a></dd>
                  <dd><a href="webpacker.html">Webpacker</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Indo mais fundo</dt>
                  <dd><a href="i18n.html">Rails Internationalization (I18n) API</a></dd>
                  <dd><a href="testing.html">Testing Rails Applications</a></dd>
                  <dd><a href="security.html">Securing Rails Applications</a></dd>
                  <dd><a href="debugging_rails_applications.html">Debugging Rails Applications</a></dd>
                  <dd><a href="configuring.html">Configuring Rails Applications</a></dd>
                  <dd><a href="command_line.html">The Rails Command Line</a></dd>
                  <dd><a href="asset_pipeline.html">The Asset Pipeline</a></dd>
                  <dd><a href="working_with_javascript_in_rails.html">Working with JavaScript in Rails</a></dd>
                  <dd><a href="initialization.html">The Rails Initialization Process</a></dd>
                  <dd><a href="autoloading_and_reloading_constants.html">Autoloading and Reloading Constants</a></dd>
                  <dd><a href="classic_to_zeitwerk_howto.html">Classic para Zeitwerk - Como Fazer</a></dd>
                  <dd><a href="caching_with_rails.html">Caching with Rails: An Overview</a></dd>
                  <dd><a href="active_support_instrumentation.html">Active Support Instrumentation</a></dd>
                  <dd><a href="api_app.html">Using Rails for API-only Applications</a></dd>
                  <dd><a href="active_record_postgresql.html">Active Record and PostgreSQL</a></dd>
                  <dd><a href="active_record_multiple_databases.html">Multiple Databases with Active Record</a></dd>
                  <dd><a href="active_record_encryption.html">Active Record Encryption</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Estendendo o Rails</dt>
                  <dd><a href="plugins.html">The Basics of Creating Rails Plugins</a></dd>
                  <dd><a href="rails_on_rack.html">Rails on Rack</a></dd>
                  <dd><a href="generators.html">Creating and Customizing Rails Generators &amp; Templates</a></dd>
                  <dd><a href="engines.html">Getting Started with Engines</a></dd>
                  <dd><a href="threading_and_code_execution.html">Threading and Code Execution in Rails</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Contribuições</dt>
                  <dd><a href="contributing_to_ruby_on_rails.html">Contributing to Ruby on Rails</a></dd>
                  <dd><a href="api_documentation_guidelines.html">API Documentation Guidelines</a></dd>
                  <dd><a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Políticas</dt>
                  <dd><a href="maintenance_policy.html">Maintenance Policy for Ruby on Rails</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Release Notes</dt>
                  <dd><a href="upgrading_ruby_on_rails.html">Upgrading Ruby on Rails</a></dd>
                  <dd><a href="7_0_release_notes.html">Version 7.0 - Dezembro 2021</a></dd>
                  <dd><a href="6_1_release_notes.html">Version 6.1 - Dezembro 2020</a></dd>
                  <dd><a href="6_0_release_notes.html">Version 6.0 - Agosto 2019</a></dd>
                  <dd><a href="5_2_release_notes.html">Version 5.2 - April 2018</a></dd>
                  <dd><a href="5_1_release_notes.html">Version 5.1 - April 2017</a></dd>
                  <dd><a href="5_0_release_notes.html">Version 5.0 - June 2016</a></dd>
                  <dd><a href="4_2_release_notes.html">Version 4.2 - December 2014</a></dd>
                  <dd><a href="4_1_release_notes.html">Version 4.1 - April 2014</a></dd>
                  <dd><a href="4_0_release_notes.html">Version 4.0 - June 2013</a></dd>
                  <dd><a href="3_2_release_notes.html">Version 3.2 - January 2012</a></dd>
                  <dd><a href="3_1_release_notes.html">Version 3.1 - August 2011</a></dd>
                  <dd><a href="3_0_release_notes.html">Version 3.0 - August 2010</a></dd>
                  <dd><a href="2_3_release_notes.html">Version 2.3 - March 2009</a></dd>
                  <dd><a href="2_2_release_notes.html">Version 2.2 - November 2008</a></dd>
                </div>
            </div>
          </dl>
        </li>
        <li><a class="nav-item" href="contributing_to_ruby_on_rails.html">Contribua</a></li>
        <li class="guides-search guides-search-small">
          <input class="search-box search-box-small nav-item" type="text" placeholder="Digite o termo...">
          <div class="search-results"></div>
          <div class="search-spinner">Aguarde...</div>
        </li>
        <li class="guides-index guides-index-small">
          <select class="guides-index-item nav-item">
            <option value="index.html">Guias</option>
              <optgroup label="Comece aqui">
                  <option value="getting_started.html">Começando com Rails</option>
              </optgroup>
              <optgroup label="Models">
                  <option value="active_record_basics.html">Active Record Basics</option>
                  <option value="active_record_migrations.html">Active Record Migrations</option>
                  <option value="active_record_validations.html">Active Record Validations</option>
                  <option value="active_record_callbacks.html">Active Record Callbacks</option>
                  <option value="association_basics.html">Active Record Associations</option>
                  <option value="active_record_querying.html">Active Record Query Interface</option>
                  <option value="active_model_basics.html">Active Model Basics</option>
              </optgroup>
              <optgroup label="Views">
                  <option value="action_view_overview.html">Action View Overview</option>
                  <option value="layouts_and_rendering.html">Layouts and Rendering in Rails</option>
                  <option value="action_view_helpers.html">Action View Helpers</option>
                  <option value="form_helpers.html">Action View Form Helpers</option>
              </optgroup>
              <optgroup label="Controllers">
                  <option value="action_controller_overview.html">Action Controller Overview</option>
                  <option value="routing.html">Rails Routing from the Outside In</option>
              </optgroup>
              <optgroup label="Outros componentes">
                  <option value="active_support_core_extensions.html">Active Support Core Extensions</option>
                  <option value="action_mailer_basics.html">Action Mailer Basics</option>
                  <option value="action_mailbox_basics.html">Action Mailbox Basics</option>
                  <option value="action_text_overview.html">Action Text Overview</option>
                  <option value="active_job_basics.html">Active Job Basics</option>
                  <option value="active_storage_overview.html">Active Storage Overview</option>
                  <option value="action_cable_overview.html">Action Cable Overview</option>
                  <option value="webpacker.html">Webpacker</option>
              </optgroup>
              <optgroup label="Indo mais fundo">
                  <option value="i18n.html">Rails Internationalization (I18n) API</option>
                  <option value="testing.html">Testing Rails Applications</option>
                  <option value="security.html">Securing Rails Applications</option>
                  <option value="debugging_rails_applications.html">Debugging Rails Applications</option>
                  <option value="configuring.html">Configuring Rails Applications</option>
                  <option value="command_line.html">The Rails Command Line</option>
                  <option value="asset_pipeline.html">The Asset Pipeline</option>
                  <option value="working_with_javascript_in_rails.html">Working with JavaScript in Rails</option>
                  <option value="initialization.html">The Rails Initialization Process</option>
                  <option value="autoloading_and_reloading_constants.html">Autoloading and Reloading Constants</option>
                  <option value="classic_to_zeitwerk_howto.html">Classic para Zeitwerk - Como Fazer</option>
                  <option value="caching_with_rails.html">Caching with Rails: An Overview</option>
                  <option value="active_support_instrumentation.html">Active Support Instrumentation</option>
                  <option value="api_app.html">Using Rails for API-only Applications</option>
                  <option value="active_record_postgresql.html">Active Record and PostgreSQL</option>
                  <option value="active_record_multiple_databases.html">Multiple Databases with Active Record</option>
                  <option value="active_record_encryption.html">Active Record Encryption</option>
              </optgroup>
              <optgroup label="Estendendo o Rails">
                  <option value="plugins.html">The Basics of Creating Rails Plugins</option>
                  <option value="rails_on_rack.html">Rails on Rack</option>
                  <option value="generators.html">Creating and Customizing Rails Generators &amp; Templates</option>
                  <option value="engines.html">Getting Started with Engines</option>
                  <option value="threading_and_code_execution.html">Threading and Code Execution in Rails</option>
              </optgroup>
              <optgroup label="Contribuições">
                  <option value="contributing_to_ruby_on_rails.html">Contributing to Ruby on Rails</option>
                  <option value="api_documentation_guidelines.html">API Documentation Guidelines</option>
                  <option value="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</option>
              </optgroup>
              <optgroup label="Políticas">
                  <option value="maintenance_policy.html">Maintenance Policy for Ruby on Rails</option>
              </optgroup>
              <optgroup label="Release Notes">
                  <option value="upgrading_ruby_on_rails.html">Upgrading Ruby on Rails</option>
                  <option value="7_0_release_notes.html">Version 7.0 - Dezembro 2021</option>
                  <option value="6_1_release_notes.html">Version 6.1 - Dezembro 2020</option>
                  <option value="6_0_release_notes.html">Version 6.0 - Agosto 2019</option>
                  <option value="5_2_release_notes.html">Version 5.2 - April 2018</option>
                  <option value="5_1_release_notes.html">Version 5.1 - April 2017</option>
                  <option value="5_0_release_notes.html">Version 5.0 - June 2016</option>
                  <option value="4_2_release_notes.html">Version 4.2 - December 2014</option>
                  <option value="4_1_release_notes.html">Version 4.1 - April 2014</option>
                  <option value="4_0_release_notes.html">Version 4.0 - June 2013</option>
                  <option value="3_2_release_notes.html">Version 3.2 - January 2012</option>
                  <option value="3_1_release_notes.html">Version 3.1 - August 2011</option>
                  <option value="3_0_release_notes.html">Version 3.0 - August 2010</option>
                  <option value="2_3_release_notes.html">Version 2.3 - March 2009</option>
                  <option value="2_2_release_notes.html">Version 2.2 - November 2008</option>
              </optgroup>
          </select>
        </li>
      </ul>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      <h2>Interface de Consulta do <em>Active Record</em></h2><p>Este guia cobre diferentes maneiras de recuperar dados de um banco de dados utilizando o <em>Active Record</em></p><p>Após ler esse guia, você saberá:</p>
<ul>
<li>Como encontrar registros usando uma variedade de métodos e condições.</li>
<li>Como especificar a ordem, os atributos recuperados, agrupamento e outras propriedades dos registros encontrados.</li>
<li>Como usar o <em>eager loading</em> para reduzir o número de consultas necessárias no banco de dados para recuperar os dados.</li>
<li>Como utilizar métodos localizadores dinâmicos.</li>
<li>Como utilizar encadeamento de métodos para usar múltiplos métodos do <em>Active Record</em> em conjunto.</li>
<li>Como checar a existência de determinados registros.</li>
<li>Como executar diversos cálculos nos <em>models</em> do <em>Active Record</em>.</li>
<li>Como executar o <em>EXPLAIN</em> nas relações.</li>
</ul>


                <div id="subCol">
            <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
            <ol class="chapters">
<li><a href="#o-que-%C3%A9-a-interface-do-active-record-para-queries-questionmark">O que é a Interface do <em>Active Record</em> para <em>Queries</em>?</a></li>
<li>
<a href="#recuperando-objetos-do-banco-de-dados">Recuperando Objetos do Banco de Dados</a>

<ul>
<li><a href="#retornando-um-%C3%BAnico-objeto">Retornando um Único Objeto</a></li>
<li><a href="#retornando-m%C3%BAltiplos-objetos-em-lotes">Retornando Múltiplos Objetos em Lotes</a></li>
</ul>
</li>
<li>
<a href="#condi%C3%A7%C3%B5es">Condições</a>

<ul>
<li><a href="#condi%C3%A7%C3%B5es-de-strings-puras">Condições de Strings Puras</a></li>
<li><a href="#condi%C3%A7%C3%B5es-de-array">Condições de Array</a></li>
<li><a href="#condi%C3%A7%C3%B5es-de-hash">Condições de Hash</a></li>
<li><a href="#condi%C3%A7%C3%B5es-not">Condições NOT</a></li>
<li><a href="#condi%C3%A7%C3%B5es-or">Condições OR</a></li>
<li><a href="#condi%C3%A7%C3%B5es-and">Condições AND</a></li>
</ul>
</li>
<li><a href="#ordenando">Ordenando</a></li>
<li><a href="#selecionando-campos-espec%C3%ADficos">Selecionando Campos Específicos</a></li>
<li><a href="#limit-e-offset"><em>Limit</em> e <em>Offset</em></a></li>
<li>
<a href="#agrupando">Agrupando</a>

<ul>
<li><a href="#total-de-itens-agrupados">Total de Itens Agrupados</a></li>
</ul>
</li>
<li><a href="#having"><em>Having</em></a></li>
<li>
<a href="#condi%C3%A7%C3%B5es-de-substitui%C3%A7%C3%A3o">Condições de Substituição</a>

<ul>
<li><a href="#unscope"><code>unscope</code></a></li>
<li><a href="#only"><code>only</code></a></li>
<li><a href="#reselect"><code>reselect</code></a></li>
<li><a href="#reorder"><code>reorder</code></a></li>
<li><a href="#reverse-order"><code>reverse_order</code></a></li>
<li><a href="#rewhere"><code>rewhere</code></a></li>
</ul>
</li>
<li><a href="#rela%C3%A7%C3%B5es-nulas">Relações Nulas</a></li>
<li><a href="#objetos-readonly-somente-leitura">Objetos <em>Readonly</em> (Somente leitura)</a></li>
<li>
<a href="#bloqueando-registros-para-altera%C3%A7%C3%A3o">Bloqueando registros para alteração</a>

<ul>
<li><a href="#bloqueio-otimista">Bloqueio Otimista</a></li>
<li><a href="#bloqueio-pessimista">Bloqueio pessimista</a></li>
</ul>
</li>
<li>
<a href="#associando-tabelas">Associando Tabelas</a>

<ul>
<li><a href="#joins"><code>joins</code></a></li>
<li><a href="#left-outer-joins"><code>left_outer_joins</code></a></li>
</ul>
</li>
<li>
<a href="#associations-com-eager-loading">Associations com <em>Eager Loading</em></a>

<ul>
<li><a href="#includes">includes</a></li>
<li><a href="#preload">preload</a></li>
<li><a href="#eager-load">eager_load</a></li>
</ul>
</li>
<li>
<a href="#scopes"><em>Scopes</em></a>

<ul>
<li><a href="#transmitindo-argumentos">Transmitindo Argumentos</a></li>
<li><a href="#usando-condicionais">Usando Condicionais</a></li>
<li><a href="#aplicando-um-escopo-padr%C3%A3o">Aplicando um Escopo Padrão</a></li>
<li><a href="#mesclagem-de-escopos">Mesclagem de Escopos</a></li>
<li><a href="#removendo-todo-o-escopo">Removendo Todo o Escopo</a></li>
</ul>
</li>
<li><a href="#localizadores-din%C3%A2micos">Localizadores Dinâmicos</a></li>
<li><a href="#enums">Enums</a></li>
<li>
<a href="#entendendo-encadeamento-de-m%C3%A9todos">Entendendo Encadeamento de Métodos</a>

<ul>
<li><a href="#buscando-dados-filtrados-de-m%C3%BAltiplas-tabelas">Buscando Dados Filtrados de Múltiplas Tabelas</a></li>
<li><a href="#buscando-dados-espec%C3%ADficos-de-m%C3%BAltiplas-tabelas">Buscando Dados Específicos de Múltiplas Tabelas</a></li>
</ul>
</li>
<li>
<a href="#encontrando-ou-construindo-um-novo-objeto">Encontrando ou Construindo um Novo Objeto</a>

<ul>
<li><a href="#find-or-create-by"><code>find_or_create_by</code></a></li>
<li><a href="#find-or-create-by-bang"><code>find_or_create_by!</code></a></li>
<li><a href="#find-or-initialize-by"><code>find_or_initialize_by</code></a></li>
</ul>
</li>
<li>
<a href="#encontrando-por-sql">Encontrando por SQL</a>

<ul>
<li><a href="#select-all"><code>select_all</code></a></li>
<li><a href="#pluck"><code>pluck</code></a></li>
<li><a href="#ids"><code>ids</code></a></li>
</ul>
</li>
<li><a href="#exist%C3%AAncia-de-objetos">Existência de Objetos</a></li>
<li>
<a href="#c%C3%A1lculos">Cálculos</a>

<ul>
<li><a href="#contar-count">Contar (<em>count</em>)</a></li>
<li><a href="#m%C3%A9dia-average">Média (<em>average</em>)</a></li>
<li><a href="#m%C3%ADnimo-minimum">Mínimo (<em>minimum</em>)</a></li>
<li><a href="#m%C3%A1ximo-maximum">Máximo (<em>maximum</em>)</a></li>
<li><a href="#soma-sum">Soma (<em>sum</em>)</a></li>
</ul>
</li>
<li>
<a href="#executando-o-explain">Executando o EXPLAIN</a>

<ul>
<li><a href="#interpretando-o-explain">Interpretando o EXPLAIN</a></li>
</ul>
</li>
</ol>

          </div>

    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <h3 id="o-que-é-a-interface-do-active-record-para-queries-questionmark"><a class="anchorlink" href="#o-que-%C3%A9-a-interface-do-active-record-para-queries-questionmark">1 O que é a Interface do <em>Active Record</em> para <em>Queries</em>?</a></h3><p>Se você está acostumado com SQL puro para encontrar registros no banco de dados, então você provavelmente encontrará
maneiras melhores de realizar as mesmas operações no Rails. O <em>Active Record</em> te isola da necessidade de usar o SQL
na maioria dos casos.</p><p>O <em>Active Record</em> fará consultas no banco de dados para você e é compatível com a maioria dos sistemas de banco de dados, incluindo MySQL, MariaDB, PostgreSQL e SQLite. Independentemente de qual sistema de banco de dados você está usando, o formato dos métodos do <em>Active Record</em> será sempre o mesmo.</p><p>Os exemplos de código ao longo desse guia irão se referir à um ou mais dos seguintes modelos:</p><div class="info"><p>Todos os <em>models</em> seguintes utilizam <code>id</code> como <em>primary key</em> (chave primária), a não ser quando especificado o
contrário.</p></div><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Author</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:books</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">order</span><span class="p">(</span><span class="ss">year_published: :desc</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Author &lt; ApplicationRecord
  has_many :books, -&gt; { order(year_published: :desc) }
end
">Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:supplier</span>
  <span class="n">belongs_to</span> <span class="ss">:author</span>
  <span class="n">has_many</span> <span class="ss">:reviews</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:orders</span><span class="p">,</span> <span class="ss">join_table: </span><span class="s1">'books_orders'</span>

  <span class="n">scope</span> <span class="ss">:in_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:out_of_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:old</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">year_published: </span><span class="o">...</span><span class="mi">50</span><span class="p">.</span><span class="nf">years</span><span class="p">.</span><span class="nf">ago</span><span class="p">.</span><span class="nf">year</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:out_of_print_and_expensive</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">out_of_print</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'price &gt; 500'</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:costs_more_than</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="s1">'price &gt; ?'</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Book &lt; ApplicationRecord
  belongs_to :supplier
  belongs_to :author
  has_many :reviews
  has_and_belongs_to_many :orders, join_table: 'books_orders'

  scope :in_print, -&gt; { where(out_of_print: false) }
  scope :out_of_print, -&gt; { where(out_of_print: true) }
  scope :old, -&gt; { where(year_published: ...50.years.ago.year) }
  scope :out_of_print_and_expensive, -&gt; { out_of_print.where('price &gt; 500') }
  scope :costs_more_than, -&gt;(amount) { where('price &gt; ?', amount) }
end
">Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:orders</span>
  <span class="n">has_many</span> <span class="ss">:reviews</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Customer &lt; ApplicationRecord
  has_many :orders
  has_many :reviews
end
">Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:books</span><span class="p">,</span> <span class="ss">join_table: </span><span class="s1">'books_orders'</span>

  <span class="n">enum</span> <span class="ss">:status</span><span class="p">,</span> <span class="p">[</span><span class="ss">:shipped</span><span class="p">,</span> <span class="ss">:being_packed</span><span class="p">,</span> <span class="ss">:complete</span><span class="p">,</span> <span class="ss">:cancelled</span><span class="p">]</span>

  <span class="n">scope</span> <span class="ss">:created_before</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="o">...</span><span class="n">time</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Order &lt; ApplicationRecord
  belongs_to :customer
  has_and_belongs_to_many :books, join_table: 'books_orders'

  enum :status, [:shipped, :being_packed, :complete, :cancelled]

  scope :created_before, -&gt;(time) { where(created_at: ...time) }
end
">Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Review</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>
  <span class="n">belongs_to</span> <span class="ss">:book</span>

  <span class="n">enum</span> <span class="ss">:state</span><span class="p">,</span> <span class="p">[</span><span class="ss">:not_reviewed</span><span class="p">,</span> <span class="ss">:published</span><span class="p">,</span> <span class="ss">:hidden</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Review &lt; ApplicationRecord
  belongs_to :customer
  belongs_to :book

  enum :state, [:not_reviewed, :published, :hidden]
end
">Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:books</span>
  <span class="n">has_many</span> <span class="ss">:authors</span><span class="p">,</span> <span class="ss">through: :books</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Supplier &lt; ApplicationRecord
  has_many :books
  has_many :authors, through: :books
end
">Copy</button>
</div>
<p><img src="images/active_record_querying/bookstore_models.png" alt="Diagrama de todos os models da loja de livros"></p><h3 id="recuperando-objetos-do-banco-de-dados"><a class="anchorlink" href="#recuperando-objetos-do-banco-de-dados">2 Recuperando Objetos do Banco de Dados</a></h3><p>Para recuperar objetos do banco de dados, o <em>Active Record</em> fornece diversos métodos de localização. Cada método de localização permite que você
passe argumentos para o mesmo para executar determinada consulta no seu banco de dados sem a necessidade de escrever SQL puro.</p><p>Os métodos são:</p>
<ul>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-annotate"><code>annotate</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/FinderMethods.html#method-i-find"><code>find</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-create_with"><code>create_with</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-distinct"><code>distinct</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-eager_load"><code>eager_load</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-extending"><code>extending</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-extract_associated"><code>extract_associated</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-from"><code>from</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-group"><code>group</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-having"><code>having</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-includes"><code>includes</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-joins"><code>joins</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-left_outer_joins"><code>left_outer_joins</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-limit"><code>limit</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-lock"><code>lock</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-none"><code>none</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-offset"><code>offset</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-optimizer_hints"><code>optimizer_hints</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-order"><code>order</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-preload"><code>preload</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-readonly"><code>readonly</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-references"><code>references</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-reorder"><code>reorder</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-reselect"><code>reselect</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-reverse_order"><code>reverse_order</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-select"><code>select</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-where"><code>where</code></a></li>
</ul>
<p>Métodos de localização que retornam uma coleção, como o <code>where</code> e <code>group</code>, retornam uma instância do <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Relation.html"><code>ActiveRecord::Relation</code></a>.
Os métodos que localizam uma única entidade, como o <code>find</code> e o <code>first</code>, retornam uma única instância do <em>model</em>.</p><p>A principal operação do <code>Model.find(options)</code> pode ser resumida como:</p>
<ul>
<li>Converter as opções fornecidas em uma consulta equivalente no SQL.</li>
<li>Disparar uma consulta SQL e recuperar os resultados correspondentes no banco de dados.</li>
<li>Instanciar o objeto Ruby equivalente do <em>model</em> apropriado para cada linha resultante.</li>
<li>Executar <code>after_find</code> e, em seguida, retornos de chamada com <code>after_initialize</code>, se houver.</li>
</ul>
<h4 id="retornando-um-único-objeto"><a class="anchorlink" href="#retornando-um-%C3%BAnico-objeto">2.1 Retornando um Único Objeto</a></h4><p>O <em>Active Record</em> possui diferentes formas de retornar um único objeto.</p><h5 id="find"><a class="anchorlink" href="#find">2.1.1 <code>find</code></a></h5><p>Utilizando o método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/FinderMethods.html#method-i-find"><code>find</code></a>, você pode retornar o objeto correspondente à <em>primary key</em> especificada que corresponde às opções fornecidas.
Por exemplo:</p><div class="code_container">
<pre><code class="highlight irb"><span class="c"># Encontra o cliente com a primary key (id) 10.
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">=&gt; #&lt;Customer id: 10, first_name: "Ryan"&gt;</span><span class="w">
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="customer = Customer.find(10)
">Copy</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.id = 10) LIMIT 1
">Copy</button>
</div>
<p>O método <code>find</code> irá gerar uma exceção <code>ActiveRecord::RecordNotFound</code> se nenhum registro correspondente for encontrado.</p><p>Você pode, também, utilizar este método para consultar múltiplos objetos. Chame o método <code>find</code> e passe um array de <em>primary keys</em>.
Será retornado um array contendo todos os registros correspondentes para as <em>primary keys</em> fornecidas. Por exemplo:</p><div class="code_container">
<pre><code class="highlight irb"><span class="c"># Encontra os clientes com as primary keys 1 e 10.
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customers</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span> <span class="c1"># OU Customer.find(1, 10)</span>
<span class="gp">=&gt; [#&lt;Customer id: 1, first_name: "Lifo"&gt;</span><span class="p">,</span> <span class="c1">#&lt;Customer id: 10, first_name: "Ryan"&gt;]</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="customers = Customer.find([1, 10]) # OU Customer.find(1, 10)
">Copy</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.id IN (1,10))
">Copy</button>
</div>
<div class="warning"><p>O método <code>find</code> irá gerar uma excecão <code>ActiveRecord::RecordNotFound</code> a não ser que um registro correspondente seja encontrado para <strong>todas</strong> as primary keys fornecidas.</p></div><h5 id="take"><a class="anchorlink" href="#take">2.1.2 <code>take</code></a></h5><p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/FinderMethods.html#method-i-take"><code>take</code></a> retorna um registro sem nenhuma ordem implícita. Por exemplo:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">take</span>
<span class="gp">=&gt; #&lt;Customer id: 1, first_name: "Lifo"&gt;</span><span class="w">
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="customer = Customer.take
">Copy</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers LIMIT 1
">Copy</button>
</div>
<p>O método <code>take</code> retorna <code>nil</code> se nenhum registro for encontrado e nenhuma exceção será disparada.</p><p>Você pode passar um argumento numérico para o método <code>take</code> para retornar o mesmo número em resultados. Por exemplo:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customers</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">take</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">=&gt; [#&lt;Customer id: 1, first_name: "Lifo"&gt;</span><span class="p">,</span> <span class="c1">#&lt;Customer id: 220, first_name: "Sara"&gt;]</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="customers = Customer.take(2)
">Copy</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">LIMIT</span> <span class="mi">2</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers LIMIT 2
">Copy</button>
</div>
<p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/FinderMethods.html#method-i-take-21"><code>take!</code></a> se comporta exatamente como o <code>take</code>, exceto que irá gerar uma exceção <code>ActiveRecord::RecordNotFound</code> caso não encontre nenhum registro correspondente.</p><div class="info"><p>O registro retornado pode variar dependendo do mecanismo do banco de dados.</p></div><h5 id="first"><a class="anchorlink" href="#first">2.1.3 <code>first</code></a></h5><p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/FinderMethods.html#method-i-first"><code>first</code></a> encontra o primeiro registro ordenado pela <em>primary key</em> (padrão). Por exemplo:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">first</span>
<span class="gp">=&gt; #&lt;Customer id: 1, first_name: "Lifo"&gt;</span><span class="w">
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="customer = Customer.first
">Copy</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">ASC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers ORDER BY customers.id ASC LIMIT 1
">Copy</button>
</div>
<p>O método <code>first</code> retorna <code>nil</code> se não for encontrado nenhum registro correspondente e nenhuma exceção é gerada.</p><p>Se o seu <a href="active_record_querying.html#applying-a-default-scope">default scope</a> contém um método de ordenação, <code>first</code> irá retornar o primeiro
registro de acordo com essa ordenação.</p><p>Você pode passar um argumento número para o métoddo <code>first</code> para retornar o mesmo número em resultados. Por exemplo:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customers</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">first</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">=&gt; [#&lt;Customer id: 1, first_name: "Lifo"&gt;</span><span class="p">,</span> <span class="c1">#&lt;Customer id: 2, first_name: "Fifo"&gt;, #&lt;Customer id: 3, first_name: "Filo"&gt;]</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="customers = Customer.first(3)
">Copy</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">ASC</span> <span class="k">LIMIT</span> <span class="mi">3</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers ORDER BY customers.id ASC LIMIT 3
">Copy</button>
</div>
<p>Em uma coleção ordenada utilizando o <code>order</code>, <code>first</code> irá retornar o primeiro registro que foi ordenado com o atributo especificado em <code>order</code>.</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">).</span><span class="nf">first</span>
<span class="gp">=&gt; #&lt;Customer id: 2, first_name: "Fifo"&gt;</span><span class="w">
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="customer = Customer.order(:first_name).first
">Copy</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="k">ASC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers ORDER BY customers.first_name ASC LIMIT 1
">Copy</button>
</div>
<p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/FinderMethods.html#method-i-first-21"><code>first!</code></a> se comporta exatamente como o <code>first</code>, exceto que irá gerar uma exceção <code>ActiveRecord::RecordNotFound</code> se nenhum registro
correspondente for encontrado.</p><h5 id="last"><a class="anchorlink" href="#last">2.1.4 <code>last</code></a></h5><p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/FinderMethods.html#method-i-last"><code>last</code></a> encontra o último registro ordenado pela <em>primary key</em> (padrão). Por exemplo:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">last</span>
<span class="gp">=&gt; #&lt;Customer id: 221, first_name: "Russel"&gt;</span><span class="w">
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="customer = Customer.last
">Copy</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers ORDER BY customers.id DESC LIMIT 1
">Copy</button>
</div>
<p>O método <code>last</code> retorna <code>nil</code> se não encontrar nenhum registro correspondente e nenhuma exceção será disparada.</p><p>Se o seu <a href="active_record_querying.html#applying-a-default-scope">default scope</a> contém um método de ordenação, <code>last</code> irá retornar
o último registro de acordo com essa ordenação.</p><p>Você pode passar um argumento número para o método <code>last</code> para retornar o mesmo número em resultados. Por exemplo:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customers</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">last</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">=&gt; [#&lt;Customer id: 219, first_name: "James"&gt;</span><span class="p">,</span> <span class="c1">#&lt;Customer id: 220, first_name: "Sara"&gt;, #&lt;Customer id: 221, first_name: "Russel"&gt;]</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="customers = Customer.last(3)
">Copy</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">3</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers ORDER BY customers.id DESC LIMIT 3
">Copy</button>
</div>
<p>Em uma coleção ordenada utilizando o <code>order</code>, <code>last</code> irá retornar o último registro que foi ordenado com o atributo especificado em <code>order</code>.</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">).</span><span class="nf">last</span>
<span class="gp">=&gt; #&lt;Customer id: 220, first_name: "Sara"&gt;</span><span class="w">
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="customer = Customer.order(:first_name).last
">Copy</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers ORDER BY customers.first_name DESC LIMIT 1
">Copy</button>
</div>
<p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/FinderMethods.html#method-i-last-21"><code>last!</code></a> se comporta exatamente como o <code>last</code>, exceto que irá gerar uma exceção <code>ActiveRecord::RecordNotFound</code> se nenhum registro
correspondente for encontrado.</p><h5 id="find-by"><a class="anchorlink" href="#find-by">2.1.5 <code>find_by</code></a></h5><p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/FinderMethods.html#method-i-find_by"><code>find_by</code></a> irá retornar o primeiro registro que corresponde às condições. Por exemplo:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_by</span> <span class="ss">first_name: </span><span class="s1">'Lifo'</span>
<span class="gp">=&gt; #&lt;Customer id: 1, first_name: "Lifo"&gt;</span><span class="w">
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_by</span> <span class="ss">first_name: </span><span class="s1">'Jon'</span>
<span class="p">=&gt;</span> <span class="kp">nil</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.find_by first_name: 'Lifo'
Customer.find_by first_name: 'Jon'
">Copy</button>
</div>
<p>É equivalente à escrever:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Lifo'</span><span class="p">).</span><span class="nf">take</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.where(first_name: 'Lifo').take
">Copy</button>
</div>
<p>O equivalente ao de cima, em SQL, seria</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Lifo'</span><span class="p">)</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.first_name = 'Lifo') LIMIT 1
">Copy</button>
</div>
<p>Observe que não há 'ORDER BY' no SQL acima. Se suas condição <code>find_by</code> puderem corresponder a vários registros, você deve <a href="#ordering">aplicar uma ordenação</a> para garantir um resultado determinístico.</p><p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/FinderMethods.html#method-i-find_by"><code>find_by</code></a> se comporta exatamente como o <code>find_by</code>, exceto que irá gerar uma exceção <code>ActiveRecord::RecordNotFound</code> se nenhum registro
correspondente for encontrado. Por exemplo:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_by!</span> <span class="ss">first_name: </span><span class="s1">'does not exist'</span>
<span class="go">ActiveRecord::RecordNotFound
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.find_by! first_name: 'does not exist'
">Copy</button>
</div>
<p>Isto é equivalente à escrever:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'does not exist'</span><span class="p">).</span><span class="nf">take!</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.where(first_name: 'does not exist').take!
">Copy</button>
</div>
<h4 id="retornando-múltiplos-objetos-em-lotes"><a class="anchorlink" href="#retornando-m%C3%BAltiplos-objetos-em-lotes">2.2 Retornando Múltiplos Objetos em Lotes</a></h4><p>Nós frequentemente precisamos iterar sobre um grande número de registros, seja quando precisamos enviar <em>newsletter</em> para
um grande número de clientes, ou quando vamos exportar dados.</p><p>Isso pode parecer simples:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># Isso pode consumir muita memória se a tabela for grande.</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="# Isso pode consumir muita memória se a tabela for grande.
Customer.all.each do |customer|
  NewsMailer.weekly(customer).deliver_now
end
">Copy</button>
</div>
<p>Mas essa abordagem se torna cada vez mais impraticável à medida que o tamanho da tabela aumenta, pois o <code>Customer.all.each</code>
instrui o <em>Active Record</em> à buscar a <strong>tabela inteira</strong> em uma única passagem, cria um <em>model</em> de objeto por linha e
mantém todo o array de objetos de <em>model</em> na memória. De fato, se você tem um grande número de registros, a coleção inteira
pode exceder a quantidade de memória disponível.</p><p>O Rails fornece dois métodos para solucionar esse problema, dividindo os registros em lotes <em>memory-friendly</em> para o processamento.
O primeiro método, <code>find_each</code>, retorna um lote de registros e depois submete <em>cada</em> registro individualmente para um bloco como um <em>model</em>.
O segundo método, <code>find_in_batches</code>, retorna um lote de registros e depois submete <em>o lote inteiro</em> ao bloco como um array de <em>models</em>.</p><div class="info"><p>Os métodos <code>find_each</code> e <code>find_in_batches</code> são destinados ao uso no processamento em lotes de grandes numéros de registros
que não irão caber na memória de uma só vez. Se você apenas precisa fazer um  <em>loop</em> em milhares de registros, os métodos
regulares do <code>find</code> são a opção preferida.</p></div><h5 id="find-each"><a class="anchorlink" href="#find-each">2.2.1 <code>find_each</code></a></h5><p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Batches.html#method-i-find_each"><code>find_each</code></a> retorna os registros em lotes e depois aloca <em>cada</em> um no bloco. No exemplo a seguir, <code>find_each</code> retorna
<em>customers</em> em lotes de 1000 e os aloca no bloco um à um:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.find_each do |customer|
  NewsMailer.weekly(customer).deliver_now
end
">Copy</button>
</div>
<p>Esse processo é repetido, buscando mais lotes sempre que preciso, até que todos os registros tenham sido processados.</p><p><code>find_each</code> funciona com classes de <em>model</em>, como visto acima, assim como relações:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">weekly_subscriber: </span><span class="kp">true</span><span class="p">).</span><span class="nf">find_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.where(weekly_subscriber: true).find_each do |customer|
  NewsMailer.weekly(customer).deliver_now
end
">Copy</button>
</div>
<p>contanto que ele não tenha nenhuma ordenação, pois o método necessita forçar uma ordem interna para iterar.</p><p>Se houver uma ordem presente no receptor, o comportamento depende da <em>flag</em> <a href="configuring.html#config-active-record-error-on-ignored-order"><code>config.active_record.error_on_ignored_order</code></a>.
Se verdadeiro, <code>ArgumentError</code> é disparada, caso contrário a ordem será ignorada e um aviso gerado, que é o padrão. Isto pode
ser substituído com a opção <code>:error_on_ignore</code>, explicado abaixo.</p><h6 id="opções-para-find-each"><a class="anchorlink" href="#op%C3%A7%C3%B5es-para-find-each">2.2.1.1 Opções para <code>find_each</code></a></h6><p><strong><code>:batch_size</code></strong></p><p>A opção <code>:batch_size</code> permite que você especifique o número de registros à serem retornados em cada lote, antes de serem passados, individualmente, para o bloco.
Por exemplo, para retornar registros de um lote de 5000:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">batch_size: </span><span class="mi">5000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.find_each(batch_size: 5000) do |customer|
  NewsMailer.weekly(customer).deliver_now
end
">Copy</button>
</div>
<p><strong><code>:start</code></strong></p><p>Por padrão, os registros são buscados em ordem ascendente de <em>primary key</em>. A opção <code>:start</code> permite que você configure o primeiro ID da sequência sempre que o menor
ID não seja o que você precisa. Isto pode ser útil, por exemplo, se você quer retomar um processo interrompido de lotes, desde que você
tenha salvo o último ID processado como ponto de retorno.</p><p>Por exemplo, para enviar <em>newsletters</em> apenas para os clientes com a <em>primary key</em> começando com 2000:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">start: </span><span class="mi">2000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.find_each(start: 2000) do |customer|
  NewsMailer.weekly(customer).deliver_now
end
">Copy</button>
</div>
<p><strong><code>:finish</code></strong></p><p>Similar à opção <code>:start</code>, <code>:finish</code> permite que você configure o último ID da sequência sempre que o maior ID não seja o que você necessite.
Isso pode ser útil, por exemplo, se você quer executar um processo de lotes utilizando subconjuntos de registros baseados no <code>:start</code> e <code>:finish</code></p><p>Por exemplo, para enviar <em>newsletters</em> apenas para os clientes com a <em>primary key</em> começando em 2000 e indo até 10000:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">start: </span><span class="mi">2000</span><span class="p">,</span> <span class="ss">finish: </span><span class="mi">10000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.find_each(start: 2000, finish: 10000) do |customer|
  NewsMailer.weekly(customer).deliver_now
end
">Copy</button>
</div>
<p>Outro exemplo seria se você queira múltiplos <em>workers</em> manipulando a mesma fila de processamento. Você pode ter cada <em>worker</em>
lidando com 10000 registros atribuindo a opção <code>:start</code> e <code>finish</code> apropriadas para cada <em>worker</em></p><p><strong><code>:error_on_ignore</code></strong></p><p>Sobrescreve as configurações da aplicação para especificar se um erro deve ser disparada quando a ordem está presente
na relação.</p><p><strong><code>:order</code></strong></p><p>Specifies the primary key order (can be <code>:asc</code> or <code>:desc</code>). Defaults to <code>:asc</code>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">order: :desc</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customer</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">customer</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.find_each(order: :desc) do |customer|
  NewsMailer.weekly(customer).deliver_now
end
">Copy</button>
</div>
<h5 id="find-in-batches"><a class="anchorlink" href="#find-in-batches">2.2.2 <code>find_in_batches</code></a></h5><p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Batches.html#method-i-find_in_batches"><code>find_in_batches</code></a> é similar ao <code>find_each</code>, pois ambos retornam lotes de registros. A diferença é que o <code>find_in_batches</code> fornece <em>lotes</em> ao bloco como um array de <em>models</em>,
em vez de individualmente. O exemplo à seguir irá produzir ao bloco fornecido um array com até 1000 notas fiscais de uma vez,
com o bloco final contendo quaisquer clientes remanescente:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># Fornece à add_customers um array com 1000 clientes de cada vez.</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">find_in_batches</span> <span class="k">do</span> <span class="o">|</span><span class="n">customers</span><span class="o">|</span>
  <span class="n">export</span><span class="p">.</span><span class="nf">add_customers</span><span class="p">(</span><span class="n">customers</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="# Fornece à add_customers um array com 1000 clientes de cada vez.
Customer.find_in_batches do |customers|
  export.add_customers(customers)
end
">Copy</button>
</div>
<p><code>find_in_batches</code> funcional com classes de <em>model</em>, como visto acima, e também com relações:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># Fornece à add_customers um array dos 1000 clientes ativos recentemente de cada vez.</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">recently_active</span><span class="p">.</span><span class="nf">find_in_batches</span> <span class="k">do</span> <span class="o">|</span><span class="n">customers</span><span class="o">|</span>
  <span class="n">export</span><span class="p">.</span><span class="nf">add_customers</span><span class="p">(</span><span class="n">customers</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="# Fornece à add_customers um array dos 1000 clientes ativos recentemente de cada vez.
Customer.recently_active.find_in_batches do |customers|
  export.add_customers(customers)
end
">Copy</button>
</div>
<p>contanto que não há ordenação, pois o método irá forçar uma ordem interna para a iteração.</p><h6 id="opções-parafind-in-batches"><a class="anchorlink" href="#op%C3%A7%C3%B5es-parafind-in-batches">2.2.2.1 Opções para<code>find_in_batches</code></a></h6><p>O método <code>find_in_batches</code> aceita as mesmas opção que o <code>find_each</code>:</p><p><strong><code>:batch_size</code></strong></p><p>Assim como para <code>find_each</code>, <code>batch_size</code> estabelece quantos registros serão recuperados em cada grupo. Por exemplo, a recuperação de lotes de 2500 registros pode ser especificada como:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_in_batches</span><span class="p">(</span><span class="ss">batch_size: </span><span class="mi">2500</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customers</span><span class="o">|</span>
  <span class="n">export</span><span class="p">.</span><span class="nf">add_customers</span><span class="p">(</span><span class="n">customers</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.find_in_batches(batch_size: 2500) do |customers|
  export.add_customers(customers)
end
">Copy</button>
</div>
<p><strong><code>:start</code></strong></p><p>A opção <code>start</code> permite especificar o ID inicial de onde os registros serão selecionados. Conforme mencionado antes, por padrão, os registros são buscados em ordem crescente da chave primária. Por exemplo, para recuperar clientes começando com ID: 5000 em lotes de 2500 registros, o seguinte código pode ser usado:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_in_batches</span><span class="p">(</span><span class="ss">batch_size: </span><span class="mi">2500</span><span class="p">,</span> <span class="ss">start: </span><span class="mi">5000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customers</span><span class="o">|</span>
  <span class="n">export</span><span class="p">.</span><span class="nf">add_customers</span><span class="p">(</span><span class="n">customers</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.find_in_batches(batch_size: 2500, start: 5000) do |customers|
  export.add_customers(customers)
end
">Copy</button>
</div>
<p><strong><code>:finish</code></strong></p><p>A opção <code>finish</code> permite especificar a identificação final dos registros a serem recuperados. O código abaixo mostra o caso de recuperação de clientes em lotes, até o cliente com ID: 7000:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_in_batches</span><span class="p">(</span><span class="ss">finish: </span><span class="mi">7000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">customers</span><span class="o">|</span>
  <span class="n">export</span><span class="p">.</span><span class="nf">add_customers</span><span class="p">(</span><span class="n">customers</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.find_in_batches(finish: 7000) do |customers|
  export.add_customers(customers)
end
">Copy</button>
</div>
<p><strong><code>:error_on_ignore</code></strong></p><p>A opção <code>error_on_ignore</code> sobrescreve a configuração da aplicação para especificar se um erro deve ser disparado quando uma ordem específica está presente na relação.</p><h3 id="condições"><a class="anchorlink" href="#condi%C3%A7%C3%B5es">3 Condições</a></h3><p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-where"><code>where</code></a> permite que você especifique condições para limitar os registros retornados, representando a parte <code>where</code> da instrução SQL. Condições podem ser especificadas como uma <em>string</em>, <em>array</em>, ou <em>hash</em>.</p><h4 id="condições-de-strings-puras"><a class="anchorlink" href="#condi%C3%A7%C3%B5es-de-strings-puras">3.1 Condições de Strings Puras</a></h4><p>Se você gostaria de adicionar condições para sua busca, poderia apenas especificá-las, como, por exemplo <code>Book.where("title = 'Introdução a Algoritmos'")</code>. Isso encontrará todos os livros em que o campo <code>title</code> tenha o valor igual a "Introdução a Algoritmos".</p><div class="warning"><p>Construindo sua própria condições como <em>strings</em> pura pode te deixar vulnerável a ataques de injeção SQL. Por exemplo, <code>Book.where("title LIKE '%#{params[:title]}%'")</code> não é seguro. Veja a próxima seção para saber a maneira preferida de lidar com  condições usando array.</p></div><h4 id="condições-de-array"><a class="anchorlink" href="#condi%C3%A7%C3%B5es-de-array">3.2 Condições de Array</a></h4><p>Agora, se esse título pudesse variar, digamos como um argumento de algum lugar? O comando da busca então levaria a forma:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title = ?"</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">])</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Book.where("title = ?", params[:title])
'>Copy</button>
</div>
<p><em>Active Record</em> tomará o primeiro argumento como a string de condições e quaisquer argumentos adicionais vão substituir os pontos de interrogação <code>(?)</code> nele.</p><p>Se você quer especificar múltiplas condições:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title = ? AND out_of_print = ?"</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">],</span> <span class="kp">false</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Book.where("title = ? AND out_of_print = ?", params[:title], false)
'>Copy</button>
</div>
<p>Neste exemplo, o primeiro ponto de interrogação será substituído com o valor em <code>params[:title]</code> e o segundo será substituído com a representação SQL para <code>false</code>, que depende do adaptador.</p><p>Este código é altamente preferível:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title = ?"</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">])</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Book.where("title = ?", params[:title])
'>Copy</button>
</div>
<p>Para este código:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title = </span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Book.where("title = #{params[:title]}")
'>Copy</button>
</div>
<p>Devido à segurança do argumento. Colocando a variável dentro da condição de <em>string</em>, passará a variável para o banco de dados <strong>como se encontra</strong>. Isto significa que será uma variável sem escape diretamente de um usuário que pode ter intenções maliciosas. Se você fizer isso, coloca todo seu banco de dados em risco, porque uma vez que um usuário descobre que pode explorar seu banco de dados, ele pode fazer qualquer coisa com ele. Nunca, jamais, coloque seus argumentos diretamente dentro da condição de <em>string</em>.</p><div class="info"><p>Para mais informações sobre os perigos da injeção de SQL, veja em <a href="https://guides.rubyonrails.org/security.html#sql-injection">Ruby on Rails Security Guide</a> / <a href="security.html#sql-injection">Ruby on Rails Security Guide PT-Br</a></p></div><h5 id="condições-com-placeholder"><a class="anchorlink" href="#condi%C3%A7%C3%B5es-com-placeholder">3.2.1 Condições com <em>Placeholder</em></a></h5><p>Similar ao estilo de substituição <code>(?)</code> dos parâmetros, você também pode especificar chaves em sua condição de <em>string</em> junto com uma <em>hash</em> de chaves/valores (<em>keys/values</em>) correspondentes:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"created_at &gt;= :start_date AND created_at &lt;= :end_date"</span><span class="p">,</span>
  <span class="p">{</span><span class="ss">start_date: </span><span class="n">params</span><span class="p">[</span><span class="ss">:start_date</span><span class="p">],</span> <span class="ss">end_date: </span><span class="n">params</span><span class="p">[</span><span class="ss">:end_date</span><span class="p">]})</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Book.where("created_at &gt;= :start_date AND created_at &lt;= :end_date",
  {start_date: params[:start_date], end_date: params[:end_date]})
'>Copy</button>
</div>
<p>Isso torna a legibilidade mais clara se você tem um grande número de condições variáveis.</p><h5 id="condições-que-usam-like"><a class="anchorlink" href="#condi%C3%A7%C3%B5es-que-usam-like">3.2.2 Condições que usam <code>LIKE</code></a></h5><p>Embora os argumentos de condição sejam automaticamente escapados para evitar injeção de SQL (<em>SQL injection</em>), os curingas SQL <code>LIKE</code> (ou seja, <code>%</code> e <code>_</code>) <strong>não</strong> são escapados. Isso pode causar um comportamento inesperado se um valor não limpo for usado em um argumento. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title LIKE ?"</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">]</span> <span class="o">+</span> <span class="s2">"%"</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Book.where("title LIKE ?", params[:title] + "%")
'>Copy</button>
</div>
<p>No código acima, a intenção é corresponder títulos que começam com uma <em>string</em> especificada pelo usuário. No entanto, quaisquer ocorrências de <code>%</code> ou <code>_</code> em <code>params[:title]</code> serão tratadas como curingas, levando a resultados de consulta surpreendentes. Em algumas circunstâncias, isso também pode impedir que o banco de dados use um índice pretendido, levando a uma consulta muito mais lenta.</p><p>Para evitar esses problemas, use <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Sanitization/ClassMethods.html#method-i-sanitize_sql_like"><code>sanitize_sql_like</code></a> para escapar caracteres curinga na parte relevante do argumento:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"title LIKE ?"</span><span class="p">,</span>
  <span class="no">Book</span><span class="p">.</span><span class="nf">sanitize_sql_like</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:title</span><span class="p">])</span> <span class="o">+</span> <span class="s2">"%"</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Book.where("title LIKE ?",
  Book.sanitize_sql_like(params[:title]) + "%")
'>Copy</button>
</div>
<h4 id="condições-de-hash"><a class="anchorlink" href="#condi%C3%A7%C3%B5es-de-hash">3.3 Condições de Hash</a></h4><p><em>Active Record</em> também permite que você passe em condições de <em>hash</em> o que pode aumentar a legibilidade de suas sintaxes de condições. Com condições de <em>hash</em>, você passa em uma <em>hash</em> com chaves (<em>keys</em>) dos campos que deseja qualificados e os valores (<em>values</em>) de como deseja qualificá-los:</p><div class="note"><p>Apenas igualdade, intervalo, e subconjunto são possíveis com as condições de <em>hash</em>.</p></div><h5 id="condições-de-igualdade"><a class="anchorlink" href="#condi%C3%A7%C3%B5es-de-igualdade">3.3.1 Condições de igualdade</a></h5><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.where(out_of_print: true)
">Copy</button>
</div>
<p>Isso irá gerar um SQL como este:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">books</span><span class="p">.</span><span class="n">out_of_print</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE (books.out_of_print = 1)
">Copy</button>
</div>
<p>O nome do campo também pode ser uma <em>string</em>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'out_of_print'</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.where('out_of_print' =&gt; true)
">Copy</button>
</div>
<p>No caso de um relacionamento <code>belongs_to</code>, uma chave de associação pode ser usada para especificar o model se um objeto <em>Active Record</em> for usado como o valor. Este método também funciona com relacionamentos polimórficos.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">author</span> <span class="o">=</span> <span class="no">Author</span><span class="p">.</span><span class="nf">first</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">author: </span><span class="n">author</span><span class="p">)</span>
<span class="no">Author</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:books</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">books: </span><span class="p">{</span> <span class="ss">author: </span><span class="n">author</span> <span class="p">})</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="author = Author.first
Book.where(author: author)
Author.joins(:books).where(books: { author: author })
">Copy</button>
</div>
<h5 id="condições-de-intervalos"><a class="anchorlink" href="#condi%C3%A7%C3%B5es-de-intervalos">3.3.2 Condições de intervalos</a></h5><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
">Copy</button>
</div>
<p>Isso irá encontrar todos livros criados ontem usando uma instrução SQL <code>BETWEEN</code>:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">books</span><span class="p">.</span><span class="n">created_at</span> <span class="k">BETWEEN</span> <span class="s1">'2008-12-21 00:00:00'</span> <span class="k">AND</span> <span class="s1">'2008-12-22 00:00:00'</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE (books.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
">Copy</button>
</div>
<p>Isso demonstra uma sintaxe mais curta para exemplos em <a href="#condicoes-de-array">Condições de Array</a></p><p>Beginless and endless ranges are supported and can be used to build less/greater than conditions.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.where(created_at: (Time.now.midnight - 1.day)..)
">Copy</button>
</div>
<p>This would generate SQL like:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">books</span><span class="p">.</span><span class="n">created_at</span> <span class="o">&gt;=</span> <span class="s1">'2008-12-21 00:00:00'</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE books.created_at &gt;= '2008-12-21 00:00:00'
">Copy</button>
</div>
<h5 id="subconjunto-de-condições"><a class="anchorlink" href="#subconjunto-de-condi%C3%A7%C3%B5es">3.3.3 Subconjunto de Condições</a></h5><p>Se você deseja procurar registros usando a expressão <code>IN</code> pode passar um <em>array</em> para a <em>hash</em> de condições:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">orders_count: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.where(orders_count: [1,3,5])
">Copy</button>
</div>
<p>Esse código irá gerar um SQL como este:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">orders_count</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.orders_count IN (1,3,5))
">Copy</button>
</div>
<h4 id="condições-not"><a class="anchorlink" href="#condi%C3%A7%C3%B5es-not">3.4 Condições NOT</a></h4><p>Consultas SQL <code>NOT</code> podem ser construídas por <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods/WhereChain.html#method-i-not"><code>where.not</code></a>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">.</span><span class="nf">not</span><span class="p">(</span><span class="ss">orders_count: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.where.not(orders_count: [1,3,5])
">Copy</button>
</div>
<p>Em outras palavras, essa consulta pode ser gerada chamando <code>where</code> sem nenhum argumento, então imediatamente encadeie com condições <code>not</code> passando <code>where</code>. Isso irá gerar SQL como este:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">orders_count</span> <span class="k">NOT</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.orders_count NOT IN (1,3,5))
">Copy</button>
</div>
<p>Se uma consulta tiver uma condição usando <em>hash</em> com valores não nulos em uma coluna anulável, os registros que tiverem valores <code>nil</code> na coluna anulável não serão retornados. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">nullable_contry: </span><span class="kp">nil</span><span class="p">)</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">.</span><span class="nf">not</span><span class="p">(</span><span class="ss">nullable_country: </span><span class="s2">"UK"</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="p">[]</span>
<span class="c1"># Mas</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">nullable_contry: </span><span class="s2">"UK"</span><span class="p">)</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">.</span><span class="nf">not</span><span class="p">(</span><span class="ss">nullable_country: </span><span class="kp">nil</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="c1">#&lt;Customer id: 2, nullable_contry: "UK"&gt;]</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Customer.create!(nullable_contry: nil)
Customer.where.not(nullable_country: "UK")
=&gt; []
# Mas
Customer.create!(nullable_contry: "UK")
Customer.where.not(nullable_country: nil)
=&gt; [#&lt;Customer id: 2, nullable_contry: "UK"&gt;]
'>Copy</button>
</div>
<h4 id="condições-or"><a class="anchorlink" href="#condi%C3%A7%C3%B5es-or">3.5 Condições OR</a></h4><p>Condições <code>OR</code> entre duas relações podem ser construídas chamando <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-or"><code>or</code></a> na primeira relação, e passando o segundo como um argumento.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">last_name: </span><span class="s1">'Smith'</span><span class="p">).</span><span class="nf">or</span><span class="p">(</span><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">orders_count: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]))</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.where(last_name: 'Smith').or(Customer.where(orders_count: [1,3,5]))
">Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">last_name</span> <span class="o">=</span> <span class="s1">'Smith'</span> <span class="k">OR</span> <span class="n">customers</span><span class="p">.</span><span class="n">orders_count</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.last_name = 'Smith' OR customers.orders_count IN (1,3,5))
">Copy</button>
</div>
<h4 id="condições-and"><a class="anchorlink" href="#condi%C3%A7%C3%B5es-and">3.6 Condições AND</a></h4><p>Condições <code>AND</code> podem ser construídas encadeando condições <code>where</code>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">last_name: </span><span class="s1">'Smith'</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">orders_count: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]))</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.where(last_name: 'Smith').where(orders_count: [1,3,5]))
">Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="n">customers</span><span class="p">.</span><span class="n">last_name</span> <span class="o">=</span> <span class="s1">'Smith'</span> <span class="k">AND</span> <span class="n">customers</span><span class="p">.</span><span class="n">orders_count</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE customers.last_name = 'Smith' AND customers.orders_count IN (1,3,5)
">Copy</button>
</div>
<p>Condições <code>AND</code> para a interseção lógica entre as relações podem ser construídas 
chamando <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-and"><code>and</code></a> na primeira relação e passando a segunda como um
argumento.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]).</span><span class="nf">and</span><span class="p">(</span><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.where(id: [1, 2]).and(Customer.where(id: [2, 3]))
">Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">AND</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.id IN (1, 2) AND customers.id IN (2, 3))
">Copy</button>
</div>
<h3 id="ordenando"><a class="anchorlink" href="#ordenando">4 Ordenando</a></h3><p>Para recuperar registros do banco de dados em uma ordem específica, você pode usar o método de <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-order"><code>order</code></a>.</p><p>Por exemplo, se você deseja obter um conjunto de registros e ordená-los em ordem crescente pelo campo <code>created_at</code> na sua tabela:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:created_at</span><span class="p">)</span>
<span class="c1"># OU</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"created_at"</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Book.order(:created_at)
# OU
Book.order("created_at")
'>Copy</button>
</div>
<p>Você também pode especificar <code>ASC</code> ou<code>DESC</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">created_at: :desc</span><span class="p">)</span>
<span class="c1"># OU</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">created_at: :asc</span><span class="p">)</span>
<span class="c1"># OU</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"created_at DESC"</span><span class="p">)</span>
<span class="c1"># OU</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"created_at ASC"</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Book.order(created_at: :desc)
# OU
Book.order(created_at: :asc)
# OU
Book.order("created_at DESC")
# OU
Book.order("created_at ASC")
'>Copy</button>
</div>
<p>Ou ordenar por campos diversos:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">title: :asc</span><span class="p">,</span> <span class="ss">created_at: :desc</span><span class="p">)</span>
<span class="c1"># OU</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="ss">created_at: :desc</span><span class="p">)</span>
<span class="c1"># OU</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"title ASC, created_at DESC"</span><span class="p">)</span>
<span class="c1"># OU</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"title ASC"</span><span class="p">,</span> <span class="s2">"created_at DESC"</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Book.order(title: :asc, created_at: :desc)
# OU
Book.order(:title, created_at: :desc)
# OU
Book.order("title ASC, created_at DESC")
# OU
Book.order("title ASC", "created_at DESC")
'>Copy</button>
</div>
<p>Se você quiser chamar <code>order</code> várias vezes, as ordens subsequentes serão anexados à primeira:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"title ASC"</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s2">"created_at DESC"</span><span class="p">)</span>
<span class="go">SELECT * FROM books ORDER BY title ASC, created_at DESC
</span></code></pre>
<button class="clipboard-button" data-clipboard-text='Book.order("title ASC").order("created_at DESC")
'>Copy</button>
</div>
<div class="warning"><p>Na maioria dos sistemas de banco de dados, ao selecionar campos com <code>distinct</code> de um conjunto de resultados usando métodos como<code>select</code>, <code>pluck</code> e <code>ids</code>; o método <code>order</code> gerará uma exceção <code>ActiveRecord::StatementInvalid</code>, a menos que o(s) campo(s) usados ​​na cláusula <code>order</code> estejam incluídos na lista de seleção. Consulte a próxima seção para selecionar campos do conjunto de resultados.</p></div><h3 id="selecionando-campos-específicos"><a class="anchorlink" href="#selecionando-campos-espec%C3%ADficos">5 Selecionando Campos Específicos</a></h3><p>Por padrão, <code>Model.find</code> seleciona todos os campos do conjunto de resultado usando <code>select *</code>.</p><p>Para selecionar somente um subconjunto de campos do conjunto de resultado, você pode especificar o
subconjunto via método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-select"><code>select</code></a>.</p><p>Por exemplo, para selecionar somente as colunas <code>isbn</code> e <code>out_of_print</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:isbn</span><span class="p">,</span> <span class="ss">:out_of_print</span><span class="p">)</span>
<span class="c1"># OU</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"isbn, out_of_print"</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Book.select(:isbn, :out_of_print)
# OU
Book.select("isbn, out_of_print")
'>Copy</button>
</div>
<p>A <em>query</em> SQL usada por esta chamada de busca vai ser algo como:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">isbn</span><span class="p">,</span> <span class="n">out_of_print</span> <span class="k">FROM</span> <span class="n">books</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT isbn, out_of_print FROM books
">Copy</button>
</div>
<p>Tome cuidado pois isso também significa que você está inicializando um objeto <em>model</em> com somente os campos que você selecionou. Se você tentar acessar um campo que não está no registro inicializado,
você vai receber:</p><div class="code_container">
<pre><code class="highlight plaintext">ActiveModel::MissingAttributeError: missing attribute: &lt;attribute&gt;
</code></pre>
<button class="clipboard-button" data-clipboard-text="ActiveModel::MissingAttributeError: missing attribute: &lt;attribute&gt;
">Copy</button>
</div>
<p>Onde <code>&lt;attribute&gt;</code> é o atributo que você pediu. O método <code>id</code> não vai lançar o <code>ActiveRecord::MissingAttributeError</code>, então fique atento quando estiver trabalhando com associações, pois elas precisam do método <code>id</code> para funcionar corretamente.</p><p>Se você quiser pegar somente um registro por valor único em um certo campo, você pode usar <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-distinct"><code>distinct</code></a>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:last_name</span><span class="p">).</span><span class="nf">distinct</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.select(:last_name).distinct
">Copy</button>
</div>
<p>Isso vai gerar uma <em>query</em> SQL como:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">last_name</span> <span class="k">FROM</span> <span class="n">customers</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT DISTINCT last_name FROM customers
">Copy</button>
</div>
<p>Você pode também remover a restrição de unicidade:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># Retorna último nome únicos</span>
<span class="n">query</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:last_name</span><span class="p">).</span><span class="nf">distinct</span>

<span class="c1"># Retorna todos os últimos nomes, mesmo se houverem valores duplicados.</span>
<span class="n">query</span><span class="p">.</span><span class="nf">distinct</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="# Retorna último nome únicos
query = Customer.select(:last_name).distinct

# Retorna todos os últimos nomes, mesmo se houverem valores duplicados.
query.distinct(false)
">Copy</button>
</div>
<h3 id="limit-e-offset"><a class="anchorlink" href="#limit-e-offset">6 <em>Limit</em> e <em>Offset</em></a></h3><p>Para aplicar <code>LIMIT</code> ao SQL disparado pelo método <code>Model.find</code>, você pode especificar o <code>LIMIT</code> usando os métodos <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-limit"><code>limit</code></a> e <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-offset"><code>offset</code></a> na relação.</p><p>Você pode utilizar <code>limit</code> para especificar o número de registros para buscar, e usar <code>offset</code> para especificar o número de registros para pular antes de retornar os registros. Por exemplo</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.limit(5)
">Copy</button>
</div>
<p>retornará no máximo 5 clientes e devido ao método não especificar nenhum <em>offset</em> ele retornará os primeiros 5 registros na tabela. O SQL que o método executa será parecido com:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">LIMIT</span> <span class="mi">5</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers LIMIT 5
">Copy</button>
</div>
<p>Ao adicionar <code>offset</code></p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="nf">offset</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.limit(5).offset(30)
">Copy</button>
</div>
<p>a chamada retornará no lugar um máximo de 5 clientes iniciando com o trigésimo-primeiro. O SQL será parecido com:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">LIMIT</span> <span class="mi">5</span> <span class="k">OFFSET</span> <span class="mi">30</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers LIMIT 5 OFFSET 30
">Copy</button>
</div>
<h3 id="agrupando"><a class="anchorlink" href="#agrupando">7 Agrupando</a></h3><p>Para aplicar uma cláusula <code>GROUP BY</code> para o SQL disparado pelo localizador, você pode utilizar o método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-group"><code>group</code></a>.</p><p>Por exemplo, se você quer encontrar uma coleção das datas em que os pedidos foram criados:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Order</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"created_at"</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="s2">"created_at"</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Order.select("created_at").group("created_at")
'>Copy</button>
</div>
<p>E isso te dará um único objeto <code>Order</code> para cada data em que há pedidos no banco de dados.</p><p>O SQL que será executado parecerá com algo como isso:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">created_at</span>
<span class="k">FROM</span> <span class="n">orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">created_at</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT created_at
FROM orders
GROUP BY created_at
">Copy</button>
</div>
<h4 id="total-de-itens-agrupados"><a class="anchorlink" href="#total-de-itens-agrupados">7.1 Total de Itens Agrupados</a></h4><p>Para pegar o total de itens agrupados em uma única <em>query</em>, chame <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Calculations.html#method-i-count"><code>count</code></a> depois do <code>group</code>.</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Order</span><span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="ss">:status</span><span class="p">).</span><span class="nf">count</span>
<span class="p">=&gt;</span> <span class="p">{</span><span class="s2">"being_packed"</span><span class="o">=&gt;</span><span class="mi">7</span><span class="p">,</span> <span class="s2">"shipped"</span><span class="o">=&gt;</span><span class="mi">12</span><span class="p">}</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Order.group(:status).count
">Copy</button>
</div>
<p>O SQL que será executado parecerá com algo como isso:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="k">COUNT</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">count_all</span><span class="p">,</span> <span class="n">status</span> <span class="k">AS</span> <span class="n">status</span>
<span class="k">FROM</span> <span class="n">orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">status</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT COUNT (*) AS count_all, status AS status
FROM orders
GROUP BY status
">Copy</button>
</div>
<h3 id="having"><a class="anchorlink" href="#having">8 <em>Having</em></a></h3><p>O SQL usa a cláusula <code>HAVING</code> para especificar condições nos campos <code>GROUP BY</code>. Você pode adicionar a cláusula <code>HAVING</code> ao SQL disparado pelo <code>Model.find</code> ao adicionar o método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-having"><code>having</code></a> à busca.</p><p>Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Order</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"created_at, sum(total) as total_price"</span><span class="p">).</span>
  <span class="nf">group</span><span class="p">(</span><span class="s2">"created_at"</span><span class="p">).</span><span class="nf">having</span><span class="p">(</span><span class="s2">"sum(total) &gt; ?"</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Order.select("created_at, sum(total) as total_price").
  group("created_at").having("sum(total) &gt; ?", 200)
'>Copy</button>
</div>
<p>O SQL que será executado será parecido com isso:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">created_at</span> <span class="k">as</span> <span class="n">ordered_date</span><span class="p">,</span> <span class="k">sum</span><span class="p">(</span><span class="n">total</span><span class="p">)</span> <span class="k">as</span> <span class="n">total_price</span>
<span class="k">FROM</span> <span class="n">orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">created_at</span>
<span class="k">HAVING</span> <span class="k">sum</span><span class="p">(</span><span class="n">total</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">200</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT created_at as ordered_date, sum(total) as total_price
FROM orders
GROUP BY created_at
HAVING sum(total) &gt; 200
">Copy</button>
</div>
<p>Isso retorna a data e o preço total para cada objeto de pedido, agrupado pelo dia em que foram criados e se o preço é maior que $200.</p><p>Se você quiser acessar o <code>total_price</code> para cada objeto <code>order</code> retornado pode fazer assim:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">big_orders</span> <span class="o">=</span> <span class="no">Order</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"created_at, sum(total) as total_price"</span><span class="p">)</span>
                  <span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="s2">"created_at"</span><span class="p">)</span>
                  <span class="p">.</span><span class="nf">having</span><span class="p">(</span><span class="s2">"sum(total) &gt; ?"</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

<span class="n">big_orders</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">total_price</span>
<span class="c1"># Retorna o preço total para o primeiro objeto Order</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='big_orders = Order.select("created_at, sum(total) as total_price")
                  .group("created_at")
                  .having("sum(total) &gt; ?", 200)

big_orders[0].total_price
# Retorna o preço total para o primeiro objeto Order
'>Copy</button>
</div>
<h3 id="condições-de-substituição"><a class="anchorlink" href="#condi%C3%A7%C3%B5es-de-substitui%C3%A7%C3%A3o">9 Condições de Substituição</a></h3><h4 id="unscope"><a class="anchorlink" href="#unscope">9.1 <code>unscope</code></a></h4><p>Você pode especificar certas condições a serem removidas usando o método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-unscope"><code>unscope</code></a>. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'id &gt; 100'</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">20</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s1">'id desc'</span><span class="p">).</span><span class="nf">unscope</span><span class="p">(</span><span class="ss">:order</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.where('id &gt; 100').limit(20).order('id desc').unscope(:order)
">Copy</button>
</div>
<p>O SQL que será executado:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="k">LIMIT</span> <span class="mi">20</span>

<span class="c1">-- Query original sem `unscope`</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span> <span class="k">desc</span> <span class="k">LIMIT</span> <span class="mi">20</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE id &gt; 100 LIMIT 20

-- Query original sem `unscope`
SELECT * FROM books WHERE id &gt; 100 ORDER BY id desc LIMIT 20
">Copy</button>
</div>
<p>Você também pode remover o escopo de cláusulas <code>where</code> específicas. Por exemplo, isto irá remover a condição do <code>id</code> da cláusula de <em>where</em>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">10</span><span class="p">,</span> <span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">).</span><span class="nf">unscope</span><span class="p">(</span><span class="ss">where: :id</span><span class="p">)</span>
<span class="c1"># SELECT books.* FROM books WHERE out_of_print = 0</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.where(id: 10, out_of_print: false).unscope(where: :id)
# SELECT books.* FROM books WHERE out_of_print = 0
">Copy</button>
</div>
<p>A relação que usou <code>unscope</code> afetará quaisquer relações nas quais foi unida:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s1">'id desc'</span><span class="p">).</span><span class="nf">merge</span><span class="p">(</span><span class="no">Book</span><span class="p">.</span><span class="nf">unscope</span><span class="p">(</span><span class="ss">:order</span><span class="p">))</span>
<span class="c1"># SELECT books.* FROM books</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.order('id desc').merge(Book.unscope(:order))
# SELECT books.* FROM books
">Copy</button>
</div>
<h4 id="only"><a class="anchorlink" href="#only">9.2 <code>only</code></a></h4><p>Você também pode substituir condições com o método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/SpawnMethods.html#method-i-only"><code>only</code></a>. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'id &gt; 10'</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">20</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s1">'id desc'</span><span class="p">).</span><span class="nf">only</span><span class="p">(</span><span class="ss">:order</span><span class="p">,</span> <span class="ss">:where</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.where('id &gt; 10').limit(20).order('id desc').only(:order, :where)
">Copy</button>
</div>
<p>O SQL que será executado:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span> <span class="k">DESC</span>

<span class="c1">-- Query original sem o `only`</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">20</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE id &gt; 10 ORDER BY id DESC

-- Query original sem o `only`
SELECT * FROM books WHERE id &gt; 10 ORDER BY id DESC LIMIT 20
">Copy</button>
</div>
<h4 id="reselect"><a class="anchorlink" href="#reselect">9.3 <code>reselect</code></a></h4><p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-reselect"><code>reselect</code></a> substitui uma declaração de <em>select</em> existente. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="ss">:isbn</span><span class="p">).</span><span class="nf">reselect</span><span class="p">(</span><span class="ss">:created_at</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.select(:title, :isbn).reselect(:created_at)
">Copy</button>
</div>
<p>O SQL que será executado:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="n">created_at</span> <span class="k">FROM</span> <span class="n">books</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT books.created_at FROM books
">Copy</button>
</div>
<p>Compare com uma cláusula em que o <code>reselect</code> não é utilizado:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="ss">:isbn</span><span class="p">).</span><span class="nf">select</span><span class="p">(</span><span class="ss">:created_at</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.select(:title, :isbn).select(:created_at)
">Copy</button>
</div>
<p>o SQL executado será:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="n">title</span><span class="p">,</span> <span class="n">books</span><span class="p">.</span><span class="n">isbn</span><span class="p">,</span> <span class="n">books</span><span class="p">.</span><span class="n">created_at</span> <span class="k">FROM</span> <span class="n">books</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT books.title, books.isbn, books.created_at FROM books
">Copy</button>
</div>
<h4 id="reorder"><a class="anchorlink" href="#reorder">9.4 <code>reorder</code></a></h4><p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-reorder"><code>reorder</code></a> substitui a ordem de escopo padrão. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Author</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:books</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">order</span><span class="p">(</span><span class="ss">year_published: :desc</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Author &lt; ApplicationRecord
  has_many :books, -&gt; { order(year_published: :desc) }
end
">Copy</button>
</div>
<p>E você executa assim:</p><div class="code_container">
<pre><code class="highlight plaintext">Author.find(10).books
</code></pre>
<button class="clipboard-button" data-clipboard-text="Author.find(10).books
">Copy</button>
</div>
<p>O SQL que será executado:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">LIMIT</span> <span class="mi">1</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">author_id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">year_published</span> <span class="k">DESC</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM authors WHERE id = 10 LIMIT 1
SELECT * FROM books WHERE author_id = 10 ORDER BY year_published DESC
">Copy</button>
</div>
<p>Você pode usar o método <code>reorder</code> para especificar um jeito diferente de ordenar os livros:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Author</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">books</span><span class="p">.</span><span class="nf">reorder</span><span class="p">(</span><span class="s1">'year_published ASC'</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Author.find(10).books.reorder('year_published ASC')
">Copy</button>
</div>
<p>O SQL que será executado:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">LIMIT</span> <span class="mi">1</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">author_id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">year_published</span> <span class="k">ASC</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM authors WHERE id = 10 LIMIT 1
SELECT * FROM books WHERE author_id = 10 ORDER BY year_published ASC
">Copy</button>
</div>
<h4 id="reverse-order"><a class="anchorlink" href="#reverse-order">9.5 <code>reverse_order</code></a></h4><p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-reverse_order"><code>reverse_order</code></a> reverte a ordem da cláusula, se especificado.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"author_id &gt; 10"</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="ss">:year_published</span><span class="p">).</span><span class="nf">reverse_order</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Book.where("author_id &gt; 10").order(:year_published).reverse_order
'>Copy</button>
</div>
<p>O SQL que será executado:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">author_id</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">year_published</span> <span class="k">DESC</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE author_id &gt; 10 ORDER BY year_published DESC
">Copy</button>
</div>
<p>Se nenhuma cláusula de ordenação é especificada na <em>query</em>, o <code>reverse_order</code> ordena pela chave primária em ordem reversa.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"author_id &gt; 10"</span><span class="p">).</span><span class="nf">reverse_order</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Book.where("author_id &gt; 10").reverse_order
'>Copy</button>
</div>
<p>O SQL que será executado:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">author_id</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span> <span class="k">DESC</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE author_id &gt; 10 ORDER BY books.id DESC
">Copy</button>
</div>
<p>O método <code>reverse_order</code> <strong>não aceita</strong> argumentos.</p><h4 id="rewhere"><a class="anchorlink" href="#rewhere">9.6 <code>rewhere</code></a></h4><p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-rewhere"><code>rewhere</code></a> substitui uma existente, nomeada condição de <em>where</em>. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">rewhere</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.where(out_of_print: true).rewhere(out_of_print: false)
">Copy</button>
</div>
<p>O SQL que será executado:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">out_of_print</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE out_of_print = 0
">Copy</button>
</div>
<p>Se a cláusula <code>rewhere</code> não for utilizada, as cláusulas <code>where</code> são juntadas usando AND:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.where(out_of_print: true).where(out_of_print: false)
">Copy</button>
</div>
<p>o SQL será:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="n">out_of_print</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="n">out_of_print</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE out_of_print = 1 AND out_of_print = 0
">Copy</button>
</div>
<h3 id="relações-nulas"><a class="anchorlink" href="#rela%C3%A7%C3%B5es-nulas">10 Relações Nulas</a></h3><p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-none"><code>none</code></a> retorna uma relação encadeada sem registros. Quaisquer condições subsequentes encadeadas à relação retornada continuarão gerando relações vazias. Isso é útil em cenários onde você precisa de uma resposta encadeada para um método ou um escopo que pode retornar zero resultados.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">none</span> <span class="c1"># retorna uma Relation vazia e não dispara nenhuma query.</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.none # retorna uma Relation vazia e não dispara nenhuma query.
">Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># O método highlighted_review abaixo deve sempre retornar uma Relation.</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">highlighted_reviews</span><span class="p">.</span><span class="nf">average</span><span class="p">(</span><span class="ss">:rating</span><span class="p">)</span>
<span class="c1"># =&gt; Retorna a média de avaliações dos livros</span>

<span class="k">class</span> <span class="nc">Book</span>
  <span class="c1"># Retorna avaliações se forem pelo menos 5,</span>
  <span class="c1"># senão considere o livros como não avaliado</span>
  <span class="k">def</span> <span class="nf">highlighted_reviews</span>
    <span class="k">if</span> <span class="n">reviews</span><span class="p">.</span><span class="nf">count</span> <span class="o">&gt;</span> <span class="mi">5</span>
      <span class="n">reviews</span>
    <span class="k">else</span>
      <span class="no">Review</span><span class="p">.</span><span class="nf">none</span> <span class="c1"># Não atingiu o número mínimo de avaliações ainda</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="# O método highlighted_review abaixo deve sempre retornar uma Relation.
Book.first.highlighted_reviews.average(:rating)
# =&gt; Retorna a média de avaliações dos livros

class Book
  # Retorna avaliações se forem pelo menos 5,
  # senão considere o livros como não avaliado
  def highlighted_reviews
    if reviews.count &gt; 5
      reviews
    else
      Review.none # Não atingiu o número mínimo de avaliações ainda
    end
  end
end
">Copy</button>
</div>
<h3 id="objetos-readonly-somente-leitura"><a class="anchorlink" href="#objetos-readonly-somente-leitura">11 Objetos <em>Readonly</em> (Somente leitura)</a></h3><p>O <em>Active Record</em> provê o método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-readonly"><code>readonly</code></a> em uma relação para desabilitar modificações explicitamente em qualquer um dos objetos retornados. Qualquer tentativa de alterar um registro <em>readonly</em> não ocorrerá, disparando uma exceção <code>ActiveRecord::ReadOnlyRecord</code>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">readonly</span><span class="p">.</span><span class="nf">first</span>
<span class="n">customer</span><span class="p">.</span><span class="nf">visits</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">customer</span><span class="p">.</span><span class="nf">save</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="customer = Customer.readonly.first
customer.visits += 1
customer.save
">Copy</button>
</div>
<p>Como <code>customer</code> é explicitamente configurado para ser um objeto <em>readonly</em>, o código acima disparando uma exceção <code>ActiveRecord::ReadOnlyRecord</code> ao chamar <code>client.save</code> com o valor atualizado de <em>visits</em>.</p><h3 id="bloqueando-registros-para-alteração"><a class="anchorlink" href="#bloqueando-registros-para-altera%C3%A7%C3%A3o">12 Bloqueando registros para alteração</a></h3><p>O bloqueio é útil para prevenir condições de corrida ao alterar registros no banco de dados e para garantir alterações atômicas.</p><p>O Active Record provê dois mecanismos de bloqueio:</p>
<ul>
<li>Bloqueio otimista</li>
<li>Bloqueio pessimista</li>
</ul>
<h4 id="bloqueio-otimista"><a class="anchorlink" href="#bloqueio-otimista">12.1 Bloqueio Otimista</a></h4><p>O bloqueio otimista permite que múltiplos usuários acessem o mesmo registro para edição e presume um mínimo de conflitos com os dados. Isto é feito verificando se outro processo fez mudanças em um registro desde que ele foi aberto. Uma exceção <code>ActiveRecord::StaleObjectError</code> é disparada se isso ocorreu e a alteração é ignorada.</p><p><strong>Coluna de bloqueio otimista</strong></p><p>Para usar o bloqueio otimista, a tabela precisa ter uma coluna chamada <code>lock_version</code> do tipo inteiro. Cada vez que o registro é alterado, o Active Record incrementa o valor na coluna <code>lock_version</code>. Se uma requisição de alteração é feita com um valor menor no campo <code>lock_version</code> do que o valor que está atualmente na coluna <code>lock_version</code> no banco de dados, a requisição de alteração falhará com um <code>ActiveRecord::StaleObjectError</code>.</p><p>Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">c1</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">c1</span><span class="p">.</span><span class="nf">first_name</span> <span class="o">=</span> <span class="s2">"Sandra"</span>
<span class="n">c1</span><span class="p">.</span><span class="nf">save</span>

<span class="n">c2</span><span class="p">.</span><span class="nf">first_name</span> <span class="o">=</span> <span class="s2">"Michael"</span>
<span class="n">c2</span><span class="p">.</span><span class="nf">save</span> <span class="c1"># Dispara um ActiveRecord::StaleObjectError</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='c1 = Customer.find(1)
c2 = Customer.find(1)

c1.first_name = "Sandra"
c1.save

c2.first_name = "Michael"
c2.save # Dispara um ActiveRecord::StaleObjectError
'>Copy</button>
</div>
<p>Você fica então responsável por lidar com o conflito tratando a exceção e desfazendo as alterações, agrupando-as ou aplicando a lógica de negócio necessária para resolver o conflito.</p><p>Este comportamento pode ser desativado definindo <code>ActiveRecord::Base.lock_optimistically = false</code>.</p><p>Para usar outro nome para a coluna <code>lock_version</code>, <code>ActiveRecord::Base</code> oferece um atributo de classe chamado <code>locking_column</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">locking_column</span> <span class="o">=</span> <span class="ss">:lock_customer_column</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Customer &lt; ApplicationRecord
  self.locking_column = :lock_customer_column
end
">Copy</button>
</div>
<h4 id="bloqueio-pessimista"><a class="anchorlink" href="#bloqueio-pessimista">12.2 Bloqueio pessimista</a></h4><p>O bloqueio pessimista usa um mecansimo de bloqueio fornecido pelo banco de dados subjacente. Ao usar <code>lock</code> quando uma <em>relation</em> (objeto do tipo ActiveRecord::Relation) é criada, obtém-se um bloqueio exclusivo nas linhas selecionadas. Relations usando <code>lock</code> são normalmente executadas dentro de uma transação para permitir condições de deadlock.</p><p>Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
  <span class="n">book</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">lock</span><span class="p">.</span><span class="nf">first</span>
  <span class="n">book</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s1">'Algorithms, second edition'</span>
  <span class="n">book</span><span class="p">.</span><span class="nf">save!</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.transaction do
  book = Book.lock.first
  book.title = 'Algorithms, second edition'
  book.save!
end
">Copy</button>
</div>
<p>A sessão acima produz o seguinte SQL para um banco de dados MySQL:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SQL</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="n">ms</span><span class="p">)</span>   <span class="k">BEGIN</span>
<span class="n">Book</span> <span class="k">Load</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="n">ms</span><span class="p">)</span>   <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">LIMIT</span> <span class="mi">1</span> <span class="k">FOR</span> <span class="k">UPDATE</span>
<span class="n">Book</span> <span class="k">Update</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="n">ms</span><span class="p">)</span>   <span class="k">UPDATE</span> <span class="n">books</span> <span class="k">SET</span> <span class="n">updated_at</span> <span class="o">=</span> <span class="s1">'2009-02-07 18:05:56'</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="s1">'Algorithms, second edition'</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">SQL</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">8</span><span class="n">ms</span><span class="p">)</span>   <span class="k">COMMIT</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SQL (0.2ms)   BEGIN
Book Load (0.3ms)   SELECT * FROM books LIMIT 1 FOR UPDATE
Book Update (0.4ms)   UPDATE books SET updated_at = '2009-02-07 18:05:56', title = 'Algorithms, second edition' WHERE id = 1
SQL (0.8ms)   COMMIT
">Copy</button>
</div>
<p>Você também pode passar SQL diretamente para o método <code>lock</code> para permitir diferentes tipos de bloqueio. Por exemplo, MySQL tem uma expressão chamada <code>LOCK IN SHARE MODE</code> que permite bloquear um registro mas ainda assim permitir que outras consultas o leiam. Para especificar esta expressão, basta passá-la ao método <code>lock</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
  <span class="n">book</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">lock</span><span class="p">(</span><span class="s2">"LOCK IN SHARE MODE"</span><span class="p">).</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">book</span><span class="p">.</span><span class="nf">increment!</span><span class="p">(</span><span class="ss">:views</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Book.transaction do
  book = Book.lock("LOCK IN SHARE MODE").find(1)
  book.increment!(:views)
end
'>Copy</button>
</div>
<div class="note"><p>Observe que seu banco de dados deve suportar o SQL puro, que você irá passar para o método <code>lock</code>.</p></div><p>Se você já tem uma instância do seu modelo, você pode iniciar uma transação e obter o bloqueio de uma vez só usando o código seguinte:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">book</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">first</span>
<span class="n">book</span><span class="p">.</span><span class="nf">with_lock</span> <span class="k">do</span>
  <span class="c1"># Este bloco é chamado dentro de uma transação,</span>
  <span class="c1"># o livro já está bloqueado.</span>
  <span class="n">book</span><span class="p">.</span><span class="nf">increment!</span><span class="p">(</span><span class="ss">:views</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="book = Book.first
book.with_lock do
  # Este bloco é chamado dentro de uma transação,
  # o livro já está bloqueado.
  book.increment!(:views)
end
">Copy</button>
</div>
<h3 id="associando-tabelas"><a class="anchorlink" href="#associando-tabelas">13 Associando Tabelas</a></h3><p>O <em>Active Record</em> fornece dois métodos de busca para especificar cláusulas <code>JOIN</code> no SQL resultante: <code>joins</code> e <code>left_outer_joins</code>.
Enquanto <code>joins</code> deve ser utilizado para <code>INNER JOIN</code> em consultas personalizadas,
<code>left_outer_joins</code> é usado para consultas usando <code>LEFT OUTER JOIN</code>.</p><h4 id="joins"><a class="anchorlink" href="#joins">13.1 <code>joins</code></a></h4><p>Há múltiplas maneiras de usar o método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-joins"><code>joins</code></a>.</p><h5 id="usando-um-fragmento-de-string-sql"><a class="anchorlink" href="#usando-um-fragmento-de-string-sql">13.1.1 Usando um Fragmento de String SQL</a></h5><p>Você pode apenas fornecer o SQL literal especificando a cláusula <code>JOIN</code> para <code>joins</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Author</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="s2">"INNER JOIN books ON books.author_id = authors.id AND books.out_of_print = FALSE"</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Author.joins("INNER JOIN books ON books.author_id = authors.id AND books.out_of_print = FALSE")
'>Copy</button>
</div>
<p>Isso resultará no seguinte SQL:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">authors</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">books</span> <span class="k">ON</span> <span class="n">books</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span> <span class="k">AND</span> <span class="n">books</span><span class="p">.</span><span class="n">out_of_print</span> <span class="o">=</span> <span class="k">FALSE</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT authors.* FROM authors INNER JOIN books ON books.author_id = authors.id AND books.out_of_print = FALSE
">Copy</button>
</div>
<h5 id="usando-array-hash-de-associações-nomeadas"><a class="anchorlink" href="#usando-array-hash-de-associa%C3%A7%C3%B5es-nomeadas">13.1.2 Usando Array/Hash de Associações Nomeadas</a></h5><p>O <em>Active Record</em> permite que você use os nomes de <a href="association_basics.html">associações</a> definidos no <em>model</em> como um atalho para especificar cláusulas <code>JOIN</code> para essas associações quando estiver usando o método  <code>joins</code>.</p><p>Todas as seguintes irão produzir uma query com join usando <code>INNER JOIN</code>:</p><h6 id="unindo-uma-associação-única"><a class="anchorlink" href="#unindo-uma-associa%C3%A7%C3%A3o-%C3%BAnica">13.1.2.1 Unindo uma Associação Única</a></h6><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.joins(:reviews)
">Copy</button>
</div>
<p>Isso produz:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT books.* FROM books
  INNER JOIN reviews ON reviews.book_id = books.id
">Copy</button>
</div>
<p>Ou, em Português: "retorne um objeto <code>Book</code> para todos os livros com avalições". Observe que você verá livros duplicados se um livro tiver mais de uma avalição. Se você quiser livros únicos, pode usar <code>Book.joins(:reviews).distinct</code>.</p><h5 id="unindo-múltiplas-associações"><a class="anchorlink" href="#unindo-m%C3%BAltiplas-associa%C3%A7%C3%B5es">13.1.3 Unindo Múltiplas Associações</a></h5><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:author</span><span class="p">,</span> <span class="ss">:reviews</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.joins(:author, :reviews)
">Copy</button>
</div>
<p>Isso produz:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">customers</span> <span class="k">ON</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">reviews</span><span class="p">.</span><span class="n">customer_id</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT books.* FROM books
  INNER JOIN reviews ON reviews.book_id = books.id
  INNER JOIN customers ON customers.id = reviews.customer_id
">Copy</button>
</div>
<p>Ou, em Português: "retorne todos os livros que o seu autor tem no mínimo uma avalição". Observe novamente que livros com múltiplas avalições aparecerão múltiplas vezes.</p><h6 id="unindo-associações-aninhadas-nível-único"><a class="anchorlink" href="#unindo-associa%C3%A7%C3%B5es-aninhadas-n%C3%ADvel-%C3%BAnico">13.1.3.1 Unindo Associações Aninhadas (Nível Único)</a></h6><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">reviews: :customer</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.joins(reviews: :customer)
">Copy</button>
</div>
<p>Isso produz:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">book</span><span class="p">.</span><span class="n">id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">customer</span> <span class="k">ON</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">reviews</span><span class="p">.</span><span class="n">id</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT books.* FROM books
  INNER JOIN reviews ON reviews.book_id = book.id
  INNER JOIN customer ON customers.id = reviews.id
">Copy</button>
</div>
<p>Ou, em Português: "retorne todos os livros que tem avaliações de um cliente".</p><h6 id="unindo-associações-aninhadas-níveis-múltiplos"><a class="anchorlink" href="#unindo-associa%C3%A7%C3%B5es-aninhadas-n%C3%ADveis-m%C3%BAltiplos">13.1.3.2 Unindo Associações Aninhadas (Níveis Múltiplos)</a></h6><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Author</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">books: </span><span class="p">[{</span> <span class="ss">reviews: </span><span class="p">{</span> <span class="ss">customer: :orders</span> <span class="p">}</span> <span class="p">},</span> <span class="ss">:supplier</span><span class="p">]</span> <span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Author.joins(books: [{ reviews: { customer: :orders } }, :supplier] )
">Copy</button>
</div>
<p>Isso produz:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">books</span> <span class="k">ON</span> <span class="n">books</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">customers</span> <span class="k">ON</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">reviews</span><span class="p">.</span><span class="n">customer_id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">orders</span> <span class="k">ON</span> <span class="n">orders</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">suppliers</span> <span class="k">ON</span> <span class="n">suppliers</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">supplier_id</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM authors
  INNER JOIN books ON books.author_id = authors.id
  INNER JOIN reviews ON reviews.book_id = books.id
  INNER JOIN customers ON customers.id = reviews.customer_id
  INNER JOIN orders ON orders.customer_id = customers.id
INNER JOIN suppliers ON suppliers.id = books.supplier_id
">Copy</button>
</div>
<p>Ou, em Português: "retorne todas os autores que têm livros com avalições <strong>e</strong> tem pedidos de clientes, e com fornecedores para esses livros."</p><h5 id="especificando-condições-em-tabelas-associadas"><a class="anchorlink" href="#especificando-condi%C3%A7%C3%B5es-em-tabelas-associadas">13.1.4 Especificando Condições em Tabelas Associadas</a></h5><p>Você pode especificar condições nas tabelas associadas com condições <a href="#condicoes-de-array">Array</a> e <a href="#condicoes-de-strings-puras">String</a>. <a href="#condicoes-de-hash">Hash conditions</a> fornecem uma sintaxe especial para especificar condições para as tabelas associadas:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">time_range</span> <span class="o">=</span> <span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="s1">'orders.created_at'</span> <span class="o">=&gt;</span> <span class="n">time_range</span><span class="p">).</span><span class="nf">distinct</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Customer.joins(:orders).where('orders.created_at' =&gt; time_range).distinct
">Copy</button>
</div>
<p>Isso encontrará todos os clientes que têm pedidos criados ontem, usando uma expressão SQL <code>BETWEEN</code> para comparar <code>created_at</code>.</p><p>Uma sintaxe alternativa e mais limpa é aninhar as condições de <em>hash</em>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">time_range</span> <span class="o">=</span> <span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">orders: </span><span class="p">{</span> <span class="ss">created_at: </span><span class="n">time_range</span> <span class="p">}).</span><span class="nf">distinct</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Customer.joins(:orders).where(orders: { created_at: time_range }).distinct
">Copy</button>
</div>
<p>Para condições mais avançadas ou para reutilizar um escopo nomeado existente, <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/SpawnMethods.html#method-i-merge"><code>merge</code></a> pode ser usado. Primeiro, vamos adicionar um novo escopo nomeado ao modelo <code>Order</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:customer</span>

  <span class="n">scope</span> <span class="ss">:created_in_time_range</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">time_range</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="n">time_range</span><span class="p">)</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Order &lt; ApplicationRecord
  belongs_to :customer

  scope :created_in_time_range, -&gt;(time_range) {
    where(created_at: time_range)
  }
end
">Copy</button>
</div>
<p>Agora nós podemos usar <code>merge</code> para juntar o escopo <code>created_in_time_range</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">time_range</span> <span class="o">=</span> <span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">merge</span><span class="p">(</span><span class="no">Order</span><span class="p">.</span><span class="nf">created_in_time_range</span><span class="p">(</span><span class="n">time_range</span><span class="p">)).</span><span class="nf">distinct</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Customer.joins(:orders).merge(Order.created_in_time_range(time_range)).distinct
">Copy</button>
</div>
<p>Isso encontrará todos os clientes que têm pedidos criados ontem, novamente usando uma expressão SQL <code>BETWEEN</code>.</p><h4 id="left-outer-joins"><a class="anchorlink" href="#left-outer-joins">13.2 <code>left_outer_joins</code></a></h4><p>Se você deseja selecionar um conjunto de registros tendo ou não registros associados, você pode usar o método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-left_outer_joins"><code>left_outer_joins</code></a>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">left_outer_joins</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">).</span><span class="nf">distinct</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s1">'customers.*, COUNT(reviews.*) AS reviews_count'</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="s1">'customers.id'</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.left_outer_joins(:reviews).distinct.select('customers.*, COUNT(reviews.*) AS reviews_count').group('customers.id')
">Copy</button>
</div>
<p>Que resulta em:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">customers</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">reviews</span><span class="p">.</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">reviews_count</span> <span class="k">FROM</span> <span class="n">customers</span>
<span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">reviews</span> <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT DISTINCT customers.*, COUNT(reviews.*) AS reviews_count FROM customers
LEFT OUTER JOIN reviews ON reviews.customer_id = customers.id GROUP BY customers.id
">Copy</button>
</div>
<p>Que significa: "retorne todos os clientes com suas contagens de avaliações, tenham eles avaliações ou não"</p><h3 id="associations-com-eager-loading"><a class="anchorlink" href="#associations-com-eager-loading">14 Associations com <em>Eager Loading</em></a></h3><p>O <em>eager loading</em> rápido é o mecanismo para carregar os registros associados dos objetos retornados por <code>Model.find</code> usando o mínimo de consultas possível.</p><p><strong>Problema de consultas N + 1</strong></p><p>Considere o seguinte código, que encontra 10 livros e imprime o último nome de seus autores:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">books</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">books</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">book</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">book</span><span class="p">.</span><span class="nf">author</span><span class="p">.</span><span class="nf">last_name</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="books = Book.limit(10)

books.each do |book|
  puts book.author.last_name
end
">Copy</button>
</div>
<p>Este código parece bom à primeira vista. Mas o problema está no número total de consultas executadas. O código acima executa 1 (para encontrar 10 livros) + 10 (um para cada livro para carregar o autor) = <strong>11</strong> consultas no total.</p><p><strong>Solução para problemas de consultas N + 1</strong></p><p>o <em>Active Record</em> permite que você especifique com antecedência todas as associações que serão carregadas. Isso é possível especificando o método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-includes"><code>includes</code></a> da chamada <code>Model.find</code>. Com o <code>includes</code>, o <em>Active Record</em> garante que todas as associações especificadas sejam carregadas usando o número mínimo possível de consultas.</p><p>Os métodos são:</p>
<ul>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-includes"><code>includes</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-preload"><code>preload</code></a></li>
<li><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/QueryMethods.html#method-i-eager_load"><code>eager_load</code></a></li>
</ul>
<h4 id="includes"><a class="anchorlink" href="#includes">14.1 includes</a></h4><p>Com <code>includes</code>, o Active Record garante que todas as associações especificadas sejam carregadas usando o número mínimo possível de consultas.</p><p>Revisitando o caso acima, usando o método <code>includes</code>, poderíamos reescrever <code>Book.limit(10)</code> para carregamento antecipado dos autores:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">books</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:author</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">books</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">book</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">book</span><span class="p">.</span><span class="nf">author</span><span class="p">.</span><span class="nf">last_name</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="books = Book.includes(:author).limit(10)

books.each do |book|
  puts book.author.last_name
end
">Copy</button>
</div>
<p>O código acima executará apenas <strong>2</strong> consultas, em oposição às <strong>11</strong> consultas do caso original:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">LIMIT</span> <span class="mi">10</span>
<span class="k">SELECT</span> <span class="n">authors</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span>
  <span class="k">WHERE</span> <span class="n">authors</span><span class="p">.</span><span class="n">book_id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT books.* FROM books LIMIT 10
SELECT authors.* FROM authors
  WHERE authors.book_id IN (1,2,3,4,5,6,7,8,9,10)
">Copy</button>
</div>
<h5 id="eager-loading-multiple-associations"><a class="anchorlink" href="#eager-loading-multiple-associations">14.1.1 Eager Loading Multiple Associations</a></h5><p>O <em>Active Record</em> permite que você carregue rapidamente qualquer número de associações com uma única chamada <code>Model.find</code> usando um <em>array</em>, <em>hash</em>, ou um <em>hash</em> aninhado de <em>array</em> / <em>hash</em> com o método <code>includes</code>.</p><h5 id="array-de-associações-múltiplas"><a class="anchorlink" href="#array-de-associa%C3%A7%C3%B5es-m%C3%BAltiplas">14.1.2 <em>Array</em> de Associações Múltiplas</a></h5><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:orders</span><span class="p">,</span> <span class="ss">:reviews</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.includes(:orders, :reviews)
">Copy</button>
</div>
<p>Isso carrega todos os clientes e os pedidos e avaliações associados.</p><h6 id="hash-de-associações-aninhadas"><a class="anchorlink" href="#hash-de-associa%C3%A7%C3%B5es-aninhadas">14.1.2.1 <em>Hash</em> de Associações Aninhadas</a></h6><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">orders: </span><span class="p">{</span><span class="ss">books: </span><span class="p">[</span><span class="ss">:supplier</span><span class="p">,</span> <span class="ss">:author</span><span class="p">]}).</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.includes(orders: {books: [:supplier, :author]}).find(1)
">Copy</button>
</div>
<p>Isso encontrará a cliente com id 1 e carregará antecipadamente todos os pedidos associados, os livros para aqueles pedidos e autores e fornecedores para cada um dos livros.</p><h5 id="especificando-condições-em-associações-eager-loaded"><a class="anchorlink" href="#especificando-condi%C3%A7%C3%B5es-em-associa%C3%A7%C3%B5es-eager-loaded">14.1.3 Especificando Condições em Associações <em>Eager Loaded</em></a></h5><p>Mesmo que o <em>Active Record</em> permita que você especifique as condições nas associações carregadas antecipadamente como <code>joins</code>, a maneira recomendada é usar <a href="#associando-tabelas">joins</a> ao invés.</p><p>No entanto, se você deve fazer isso, você pode usar <code>where</code> como faria normalmente.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Author</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:books</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">books: </span><span class="p">{</span> <span class="ss">out_of_print: </span><span class="kp">true</span> <span class="p">})</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Author.includes(:books).where(books: { out_of_print: true })
">Copy</button>
</div>
<p>Isso geraria uma consulta que contém um <code>LEFT OUTER JOIN</code> enquanto o
O método <code>joins</code> geraria um usando a função <code>INNER JOIN</code>.</p><div class="code_container">
<pre><code class="highlight sql">  <span class="k">SELECT</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">t0_r0</span><span class="p">,</span> <span class="p">...</span> <span class="n">books</span><span class="p">.</span><span class="n">updated_at</span> <span class="k">AS</span> <span class="n">t1_r5</span> <span class="k">FROM</span> <span class="n">authors</span> <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">books</span> <span class="k">ON</span> <span class="n">books</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">books</span><span class="p">.</span><span class="n">out_of_print</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="  SELECT authors.id AS t0_r0, ... books.updated_at AS t1_r5 FROM authors LEFT OUTER JOIN books ON books.author_id = authors.id WHERE (books.out_of_print = 1)
">Copy</button>
</div>
<p>Se não houvesse uma condição <code>where</code>, isso geraria o conjunto normal de duas consultas.</p><p>NOTA: Usar <code>where</code> assim só funcionará quando você passar um Hash. Para
Fragmentos de SQL você precisa usar <code>references</code> para forçar tabelas unidas:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Author</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:books</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="s2">"books.out_of_print = true"</span><span class="p">).</span><span class="nf">references</span><span class="p">(</span><span class="ss">:books</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Author.includes(:books).where("books.out_of_print = true").references(:books)
'>Copy</button>
</div>
<p>Se, no caso desta consulta <code>includes</code>, não houver livros para qualquer
autor, todos os autores ainda seriam carregados. Usando <code>joins</code> (um INNER
JOIN), as condições de junção <strong>devem</strong> corresponder, caso contrário, nenhum registro será
devolvido.</p><div class="note"><p>Se uma associação for carregada antecipadamente como parte de uma junção, quaisquer campos de uma cláusula de seleção personalizada não estarão presentes nos <em>models</em> carregados.
Isso ocorre porque é ambíguo se eles devem aparecer no registro do pai ou do filho.</p></div><h4 id="preload"><a class="anchorlink" href="#preload">14.2 preload</a></h4><p>Com <code>preload</code>, o Active Record carrega usando uma consulta para cada associação especificada.</p><p>Revisitando o problema com consultas N + 1, poderíamos reescrever <code>Book.limit(10)</code> usar <code>preload</code> para autores:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">books</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">preload</span><span class="p">(</span><span class="ss">:author</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">books</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">book</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">book</span><span class="p">.</span><span class="nf">author</span><span class="p">.</span><span class="nf">last_name</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="books = Book.preload(:author).limit(10)

books.each do |book|
  puts book.author.last_name
end
">Copy</button>
</div>
<p>O código acima executará apenas <strong>2</strong> consultas, ao contrário de <strong>11</strong> consultas no caso original:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">LIMIT</span> <span class="mi">10</span>
<span class="k">SELECT</span> <span class="n">authors</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span>
  <span class="k">WHERE</span> <span class="n">authors</span><span class="p">.</span><span class="n">book_id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT books.* FROM books LIMIT 10
SELECT authors.* FROM authors
  WHERE authors.book_id IN (1,2,3,4,5,6,7,8,9,10)
">Copy</button>
</div>
<div class="note"><p>O método <code>preload</code> usa um <em>array</em>, <em>hash</em> ou um <em>hash</em> aninhado de <em>array/hash</em> da mesma forma que o método <code>includes</code> para carregar qualquer número de associações com uma única chamada <code>Model.find</code>. No entanto, ao contrário do método <code>includes</code>, não é possível especificar condições para associações carregadas antecipadamente (<code>preload</code>).</p></div><h4 id="eager-load"><a class="anchorlink" href="#eager-load">14.3 eager_load</a></h4><p>Com <code>eager_load</code>, o Active Record garante que force o carregamento antecipado usando <code>LEFT OUTER JOIN</code>.</p><p>Revisitando o caso em que N + 1 ocorreu usando o método <code>eager_load</code>, poderíamos reescrever <code>Book.limit(10)</code> para autores:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">books</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">eager_load</span><span class="p">(</span><span class="ss">:author</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">books</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">book</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">book</span><span class="p">.</span><span class="nf">author</span><span class="p">.</span><span class="nf">last_name</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="books = Book.eager_load(:author).limit(10)

books.each do |book|
  puts book.author.last_name
end
">Copy</button>
</div>
<p>O código acima executará apenas <strong>2</strong> consultas, ao contrário de <strong>11</strong> consultas no caso original:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">authors</span> <span class="k">ON</span> <span class="n">authors</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span> <span class="k">LIMIT</span> <span class="mi">10</span>
<span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="n">t0_r0</span><span class="p">,</span> <span class="n">books</span><span class="p">.</span><span class="n">last_name</span> <span class="k">AS</span> <span class="n">t0_r1</span><span class="p">,</span> <span class="p">...</span>
  <span class="k">FROM</span> <span class="n">books</span> <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">authors</span> <span class="k">ON</span> <span class="n">authors</span><span class="p">.</span><span class="n">book_id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span>
  <span class="k">WHERE</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT DISTINCT books.id FROM books LEFT OUTER JOIN authors ON authors.book_id = books.id LIMIT 10
SELECT books.id AS t0_r0, books.last_name AS t0_r1, ...
  FROM books LEFT OUTER JOIN authors ON authors.book_id = books.id
  WHERE books.id IN (1,2,3,4,5,6,7,8,9,10)
">Copy</button>
</div>
<div class="note"><p>O método <code>eager_load</code> usa um <em>array</em>, <em>hash</em> ou um <em>hash</em> aninhado de <em>array/hash</em> da mesma forma que o método <code>includes</code> para carregar qualquer número de associações com uma única chamada <code>Model.find</code>. Além disso, como o método <code>includes</code>, você pode especificar as condições da associação carregada antecipadamente.</p></div><h3 id="scopes"><a class="anchorlink" href="#scopes">15 <em>Scopes</em></a></h3><p>A definição do escopo permite que você especifique consultas comumente usadas, que podem ser referenciadas como chamadas de método nos objetos ou <em>modelos</em> associados. Com esses escopos, você pode usar todos os métodos cobertos anteriormente, como <code>where</code>, <code>joins</code> e <code>includes</code>. Todos os corpos de escopo devem retornar um <code>ActiveRecord::Relation</code> ou <code>nil</code> para permitir que métodos adicionais (como outros escopos) sejam chamados nele.</p><p>Para definir um escopo simples, usamos o método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Scoping/Named/ClassMethods.html#method-i-scope"><code>scope</code></a> dentro da classe, passando a consulta que gostaríamos de executar quando este escopo for chamado:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:out_of_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Book &lt; ApplicationRecord
  scope :out_of_print, -&gt; { where(out_of_print: true) }
end
">Copy</button>
</div>
<p>Para chamar este escopo <code>out_of_print</code> nós podemos chama-lo tanto na classe:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">out_of_print</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Relation</span><span class="kt">&gt;</span> <span class="c1"># todos os livros sem tiragem</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.out_of_print
">Copy</button>
</div>
<p>Ou numa associação consistida de objetos <code>Book</code>:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">author</span> <span class="o">=</span> <span class="no">Author</span><span class="p">.</span><span class="nf">first</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">author</span><span class="p">.</span><span class="nf">books</span><span class="p">.</span><span class="nf">out_of_print</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Relation</span><span class="kt">&gt;</span> <span class="c1"># todos os livros sem tiragem por autor</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="author = Author.first
author.books.out_of_print
">Copy</button>
</div>
<p>Os escopos também podem ser encadeados dentro dos escopos:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:out_of_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:out_of_print_and_expensive</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">out_of_print</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"price &gt; 500"</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='class Book &lt; ApplicationRecord
  scope :out_of_print, -&gt; { where(out_of_print: true) }
  scope :out_of_print_and_expensive, -&gt; { out_of_print.where("price &gt; 500") }
end
'>Copy</button>
</div>
<h4 id="transmitindo-argumentos"><a class="anchorlink" href="#transmitindo-argumentos">15.1 Transmitindo Argumentos</a></h4><p>Seu escopo pode receber argumentos:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:costs_more_than</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="s2">"price &gt; ?"</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='class Book &lt; ApplicationRecord
  scope :costs_more_than, -&gt;(amount) { where("price &gt; ?", amount) }
end
'>Copy</button>
</div>
<p>Chame o escopo como se fosse um método de classe:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">costs_more_than</span><span class="p">(</span><span class="mf">100.10</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.costs_more_than(100.10)
">Copy</button>
</div>
<p>No entanto, isso é apenas a duplicação da funcionalidade que seria fornecida a você por um método de classe.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">costs_more_than</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
    <span class="n">where</span><span class="p">(</span><span class="s2">"price &gt; ?"</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='class Book &lt; ApplicationRecord
  def self.costs_more_than(amount)
    where("price &gt; ?", amount)
  end
end
'>Copy</button>
</div>
<p>Esses métodos ainda estarão acessíveis nos objetos de associação:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">author</span><span class="p">.</span><span class="nf">books</span><span class="p">.</span><span class="nf">costs_more_than</span><span class="p">(</span><span class="mf">100.10</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="author.books.costs_more_than(100.10)
">Copy</button>
</div>
<h4 id="usando-condicionais"><a class="anchorlink" href="#usando-condicionais">15.2 Usando Condicionais</a></h4><p>Seu escopo pode utilizar condicionais:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:created_before</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="o">...</span><span class="n">time</span><span class="p">)</span> <span class="k">if</span> <span class="n">time</span><span class="p">.</span><span class="nf">present?</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Order &lt; ApplicationRecord
  scope :created_before, -&gt;(time) { where(created_at: ...time) if time.present? }
end
">Copy</button>
</div>
<p>Como os outros exemplos, isso se comportará de maneira semelhante a um método de classe.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">created_before</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="o">...</span><span class="n">time</span><span class="p">)</span> <span class="k">if</span> <span class="n">time</span><span class="p">.</span><span class="nf">present?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Order &lt; ApplicationRecord
  def self.created_before(time)
    where(created_at: ...time) if time.present?
  end
end
">Copy</button>
</div>
<p>No entanto, há uma advertência importante: um escopo sempre retornará um objeto <code>ActiveRecord::Relation</code>, mesmo se a condicional for avaliada como <code>false</code>, enquanto um método de classe retornará <code>nil</code>. Isso pode causar <code>NoMethodError</code> ao encadear métodos de classe com condicionais, se qualquer uma das condicionais retornar <code>false</code>.</p><h4 id="aplicando-um-escopo-padrão"><a class="anchorlink" href="#aplicando-um-escopo-padr%C3%A3o">15.3 Aplicando um Escopo Padrão</a></h4><p>Se desejarmos que um escopo seja aplicado em todas as consultas do <em>model</em>, podemos usar o
método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Scoping/Default/ClassMethods.html#method-i-default_scope"><code>default_scope</code></a> dentro do próprio <em>model</em>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Book &lt; ApplicationRecord
  default_scope { where(out_of_print: false) }
end
">Copy</button>
</div>
<p>Quando as consultas são executadas neste <em>model</em>, a consulta SQL agora será semelhante a
isto:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">books</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">out_of_print</span> <span class="o">=</span> <span class="k">false</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE (out_of_print = false)
">Copy</button>
</div>
<p>Se você precisa fazer coisas mais complexas com um escopo padrão, você pode alternativamente
defini-lo como um método de classe:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">default_scope</span>
    <span class="c1"># Deve retornar uma ActiveRecord::Relation.</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Book &lt; ApplicationRecord
  def self.default_scope
    # Deve retornar uma ActiveRecord::Relation.
  end
end
">Copy</button>
</div>
<div class="note"><p>O <code>default_scope</code> também é aplicado ao criar/construir um registro
quando os argumentos do escopo são fornecidos como <code>Hash</code>. Não é aplicado enquanto
atualizando um registro. E.g.:</p></div><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Book &lt; ApplicationRecord
  default_scope { where(out_of_print: false) }
end
">Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">new</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Book</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">out_of_print: </span><span class="kp">false</span><span class="kt">&gt;</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">new</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Book</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">out_of_print: </span><span class="kp">nil</span><span class="kt">&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.new
Book.unscoped.new
">Copy</button>
</div>
<p>Esteja ciente de que, quando fornecido no formato <code>Array</code>, os argumentos de consulta <code>default_scope</code>
não pode ser convertido em <code>Hash</code> para atribuição de atributo padrão. E.g.:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="s2">"out_of_print = ?"</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='class Book &lt; ApplicationRecord
  default_scope { where("out_of_print = ?", false) }
end
'>Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">new</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Book</span> <span class="ss">id: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">out_of_print: </span><span class="kp">nil</span><span class="kt">&gt;</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.new
">Copy</button>
</div>
<h4 id="mesclagem-de-escopos"><a class="anchorlink" href="#mesclagem-de-escopos">15.4 Mesclagem de Escopos</a></h4><p>Assim como os escopos das cláusulas <code>where</code> são mesclados usando as condições <code>AND</code>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:in_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:out_of_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">scope</span> <span class="ss">:recent</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">year_published: </span><span class="mi">50</span><span class="p">.</span><span class="nf">years</span><span class="p">.</span><span class="nf">ago</span><span class="p">.</span><span class="nf">year</span><span class="o">..</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:old</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">year_published: </span><span class="o">...</span><span class="mi">50</span><span class="p">.</span><span class="nf">years</span><span class="p">.</span><span class="nf">ago</span><span class="p">.</span><span class="nf">year</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Book &lt; ApplicationRecord
  scope :in_print, -&gt; { where(out_of_print: false) }
  scope :out_of_print, -&gt; { where(out_of_print: true) }

  scope :recent, -&gt; { where(year_published: 50.years.ago.year..) }
  scope :old, -&gt; { where(year_published: ...50.years.ago.year) }
end
">Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">out_of_print</span><span class="p">.</span><span class="nf">old</span>
<span class="go">SELECT books.* FROM books WHERE books.out_of_print = 'true' AND books.year_published &lt; 1969
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="Book.out_of_print.old
">Copy</button>
</div>
<p>Podemos misturar e combinar as condições <code>scope</code> e <code>where</code> e o SQL final
terá todas as condições unidas com <code>AND</code>.</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">in_print</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">price: </span><span class="o">...</span><span class="mi">100</span><span class="p">)</span>
<span class="go">SELECT books.* FROM books WHERE books.out_of_print = 'false' AND books.price &lt; 100
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="Book.in_print.where(price: ...100)
">Copy</button>
</div>
<p>Se quisermos que a última cláusula <code>where</code> vença, então <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/SpawnMethods.html#method-i-merge"><code>merge</code></a> pode
ser usado.</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">in_print</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="no">Book</span><span class="p">.</span><span class="nf">out_of_print</span><span class="p">)</span>
<span class="go">SELECT books.* FROM books WHERE books.out_of_print = true
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="Book.in_print.merge(Book.out_of_print)
">Copy</button>
</div>
<p>Uma advertência importante é que <code>default_scope</code> será anexado em
condições <code>scope</code> e <code>where</code>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">year_published: </span><span class="mi">50</span><span class="p">.</span><span class="nf">years</span><span class="p">.</span><span class="nf">ago</span><span class="p">.</span><span class="nf">year</span><span class="o">..</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">scope</span> <span class="ss">:in_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:out_of_print</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Book &lt; ApplicationRecord
  default_scope { where(year_published: 50.years.ago.year..) }

  scope :in_print, -&gt; { where(out_of_print: false) }
  scope :out_of_print, -&gt; { where(out_of_print: true) }
end
">Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">all</span>
<span class="go">SELECT books.* FROM books WHERE (year_published &gt;= 1969)
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">in_print</span>
<span class="go">SELECT books.* FROM books WHERE (year_published &gt;= 1969) AND books.out_of_print = false
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'price &gt; 50'</span><span class="p">)</span>
<span class="go">SELECT books.* FROM books WHERE (year_published &gt;= 1969) AND (price &gt; 50)
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="Book.all
Book.in_print
Book.where('price &gt; 50')
">Copy</button>
</div>
<p>Como você pode ver acima, o <code>default_scope</code> está sendo mesclado em ambos
condições <code>scope</code> e <code>where</code>.</p><h4 id="removendo-todo-o-escopo"><a class="anchorlink" href="#removendo-todo-o-escopo">15.5 Removendo Todo o Escopo</a></h4><p>Se desejarmos remover o escopo por qualquer motivo, podemos usar o método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Scoping/Default/ClassMethods.html#method-i-unscoped"><code>unscoped</code></a>. Isto é
especialmente útil se um <code>default_scope</code> é especificado no <em>model</em> e não deve ser
aplicado para esta consulta particular.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">load</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.unscoped.load
">Copy</button>
</div>
<p>Este método remove todo o escopo e fará uma consulta normal na tabela.</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">all</span>
<span class="go">SELECT books.* FROM books
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">all</span>
<span class="go">SELECT books.* FROM books
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="Book.unscoped.all
Book.where(out_of_print: true).unscoped.all
">Copy</button>
</div>
<p><code>unscoped</code> também pode aceitar um bloco:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">unscoped</span> <span class="p">{</span> <span class="no">Book</span><span class="p">.</span><span class="nf">out_of_print</span> <span class="p">}</span>
<span class="go">SELECT books.* FROM books WHERE books.out_of_print
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="Book.unscoped { Book.out_of_print }
">Copy</button>
</div>
<h3 id="localizadores-dinâmicos"><a class="anchorlink" href="#localizadores-din%C3%A2micos">16 Localizadores Dinâmicos</a></h3><p>Para cada campo (também conhecido como atributo) que você define na sua tabela, o <em>Active Record</em> fornece um método localizador. Se você tiver um campo chamado <code>first_name</code> no seu <em>model</em> <code>Customer</code> por exemplo, você terá de graça o método <code>find_by_first_name</code> fornecido pelo <em>Active Record</em>. Se você tiver o campo <code>locked</code> no seu <em>model</em> <code>Customer</code>, você também receberá o método <code>find_by_locked</code>.</p><p>Você pode especificar o ponto de exclamação (<code>!</code>) no final de um localizador dinâmico para que ele levante um erro <code>ActiveRecord::RecordNotFound</code> caso não seja retornado nenhum registro, por exemplo <code>Customer.find_by_first_name!("Ryan")</code></p><p>Se você deseja localizar ambos por <em>first_name</em> e <em>orders_count</em>, você pode encadear esses localizadores juntos simplesmente digitando "<code>and</code>" entre os campos. Por exemplo, <code>Customer.find_by_first_name_and_orders_count("Ryan", 5)</code>.</p><h3 id="enums"><a class="anchorlink" href="#enums">17 Enums</a></h3><p>Um <em>enum</em> permite que você defina um <em>Array</em> de valores para um atributo e se refira a eles pelo nome. O valor presente no banco de dados é um inteiro que foi mapeado para um dos valores.</p><p>Declarar um <em>enum</em> irá:</p>
<ul>
<li>Criar escopos que podem ser usados para encontrar todos objetos que tem ou não um dos valores do <em>enum</em>
</li>
<li>Criar um método de instância que pode ser usado para determinar se um objeto tem um valor específicio para o <em>enum</em>
</li>
<li>Criar um método de instância que pode ser usado para mudar o valor do <em>enum</em> de um objeto</li>
</ul>
<p>para todos os possíveis valores de um <em>enum</em>.</p><p>Por exemplo, dada essa declaração <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Enum.html#method-i-enum"><code>enum</code></a>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">enum</span> <span class="ss">:status</span><span class="p">,</span> <span class="p">[</span><span class="ss">:shipped</span><span class="p">,</span> <span class="ss">:being_packaged</span><span class="p">,</span> <span class="ss">:complete</span><span class="p">,</span> <span class="ss">:cancelled</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Order &lt; ApplicationRecord
  enum :status, [:shipped, :being_packaged, :complete, :cancelled]
end
">Copy</button>
</div>
<p>Esses <a href="#scopes">scopes</a> são criados automaticamente e podem ser usados para todos os objetos com ou sem um valor específico para <code>status</code>:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Order</span><span class="p">.</span><span class="nf">shipped</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Relation</span><span class="kt">&gt;</span> <span class="c1"># all orders with status == :shipped</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Order</span><span class="p">.</span><span class="nf">not_shipped</span>
<span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Relation</span><span class="kt">&gt;</span> <span class="c1"># all orders with status != :shipped</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Order.shipped
Order.not_shipped
">Copy</button>
</div>
<p>Esses métodos de instância são criados automaticamente e consultam se o <em>model</em> tem esse valor para o <em>enum</em> <code>status</code>:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">order</span> <span class="o">=</span> <span class="no">Order</span><span class="p">.</span><span class="nf">shipped</span><span class="p">.</span><span class="nf">first</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">order</span><span class="p">.</span><span class="nf">shipped?</span>
<span class="p">=&gt;</span> <span class="kp">true</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">order</span><span class="p">.</span><span class="nf">complete?</span>
<span class="p">=&gt;</span> <span class="kp">false</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="order = Order.shipped.first
order.shipped?
order.complete?
">Copy</button>
</div>
<p>Esses métodos de instância são criados automaticamente e atualizarão primeiro o valor do <code>status</code> para o valor nomeado
e, em seguida, consultar se o <em>status</em> foi ou não definido com sucesso para o valor:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">order</span> <span class="o">=</span> <span class="no">Order</span><span class="p">.</span><span class="nf">first</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">order</span><span class="p">.</span><span class="nf">shipped!</span>
<span class="go">UPDATE "orders" SET "status" = ?, "updated_at" = ? WHERE "orders"."id" = ?  [["status", 0], ["updated_at", "2019-01-24 07:13:08.524320"], ["id", 1]]
</span><span class="p">=&gt;</span> <span class="kp">true</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="order = Order.first
order.shipped!
">Copy</button>
</div>
<p>A documentação completa sobre <em>enums</em> pode ser encontrada <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Enum.html">aqui</a>.</p><h3 id="entendendo-encadeamento-de-métodos"><a class="anchorlink" href="#entendendo-encadeamento-de-m%C3%A9todos">18 Entendendo Encadeamento de Métodos</a></h3><p>O <em>Active Record</em> implementa o padrão <a href="https://en.wikipedia.org/wiki/Method_chaining">Encadeamento de Métodos</a>
(<em>method chaining</em>) que nos permite usar vários métodos do <em>Active Record</em> juntos de uma maneira simples e direta.</p><p>Você pode encadear métodos numa sentença quando o método chamado anteriormente retorna
uma <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Relation.html"><code>ActiveRecord::Relation</code></a>, como <code>all</code>, <code>where</code> e <code>joins</code>. Métodos que retornam um único objeto
(veja <a href="#retornando-um-unico-objeto">a seção Retornando um Único Objeto</a>) devem estar no fim da sentença.</p><p>Há alguns exemplos abaixo. Esse guia não vai mostrar todas as possibilidades, só alguns exemplos.
Quando um método <em>Active Record</em> é chamado, a consulta não é imediatamente gerada e enviada para o banco
de dados. A <em>query</em> é enviada só quando você precisa dos dados. Então cada
exemplo abaixo gera uma única consulta.</p><h4 id="buscando-dados-filtrados-de-múltiplas-tabelas"><a class="anchorlink" href="#buscando-dados-filtrados-de-m%C3%BAltiplas-tabelas">18.1 Buscando Dados Filtrados de Múltiplas Tabelas</a></h4><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span>
  <span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s1">'customers.id, customers.last_name, reviews.body'</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'reviews.created_at &gt; ?'</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="nf">week</span><span class="p">.</span><span class="nf">ago</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer
  .select('customers.id, customers.last_name, reviews.body')
  .joins(:reviews)
  .where('reviews.created_at &gt; ?', 1.week.ago)
">Copy</button>
</div>
<p>O resultado deve ser algo parecido com isso:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">customers</span><span class="p">.</span><span class="n">last_name</span><span class="p">,</span> <span class="n">reviews</span><span class="p">.</span><span class="n">body</span>
<span class="k">FROM</span> <span class="n">customers</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">reviews</span>
  <span class="k">ON</span> <span class="n">reviews</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="p">(</span><span class="n">reviews</span><span class="p">.</span><span class="n">created_at</span> <span class="o">&gt;</span> <span class="s1">'2019-01-08'</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT customers.id, customers.last_name, reviews.body
FROM customers
INNER JOIN reviews
  ON reviews.customer_id = customers.id
WHERE (reviews.created_at &gt; '2019-01-08')
">Copy</button>
</div>
<h4 id="buscando-dados-específicos-de-múltiplas-tabelas"><a class="anchorlink" href="#buscando-dados-espec%C3%ADficos-de-m%C3%BAltiplas-tabelas">18.2 Buscando Dados Específicos de Múltiplas Tabelas</a></h4><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Book</span>
  <span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s1">'books.id, books.title, authors.first_name'</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:author</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">title: </span><span class="s1">'Abstraction and Specification in Program Development'</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book
  .select('books.id, books.title, authors.first_name')
  .joins(:author)
  .find_by(title: 'Abstraction and Specification in Program Development')
">Copy</button>
</div>
<p>O comando acima deve gerar:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">books</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">books</span><span class="p">.</span><span class="n">title</span><span class="p">,</span> <span class="n">authors</span><span class="p">.</span><span class="n">first_name</span>
<span class="k">FROM</span> <span class="n">books</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">authors</span>
  <span class="k">ON</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="n">author_id</span>
<span class="k">WHERE</span> <span class="n">books</span><span class="p">.</span><span class="n">title</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span> <span class="p">[[</span><span class="nv">"title"</span><span class="p">,</span> <span class="nv">"Abstraction and Specification in Program Development"</span><span class="p">]]</span>
<span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='SELECT books.id, books.title, authors.first_name
FROM books
INNER JOIN authors
  ON authors.id = books.author_id
WHERE books.title = $1 [["title", "Abstraction and Specification in Program Development"]]
LIMIT 1
'>Copy</button>
</div>
<div class="note"><p>Note que se uma consulta trouxer múltiplos registros, o
método <code>find_by</code> irá retornar somente o primeiro e ignorar o
restante (perceba a sentença <code>LIMIT 1</code> acima).</p></div><h3 id="encontrando-ou-construindo-um-novo-objeto"><a class="anchorlink" href="#encontrando-ou-construindo-um-novo-objeto">19 Encontrando ou Construindo um Novo Objeto</a></h3><p>É comum que você precise localizar um registro ou criá-lo se ele não existir. Você pode fazer isso com os métodos <code>find_or_create_by</code> e <code>find_or_create_by!</code>.</p><h4 id="find-or-create-by"><a class="anchorlink" href="#find-or-create-by">19.1 <code>find_or_create_by</code></a></h4><p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Relation.html#method-i-find_or_create_by"><code>find_or_create_by</code></a> verifica se existe um registro com os atributos especificados. Se não, então <code>create</code> é chamado. Vejamos um exemplo.</p><p>Suponha que você queira encontrar um cliente chamado 'Andy' e, se não houver nenhum, crie um. Você pode fazer isso executando:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Andy'</span><span class="p">)</span>
<span class="gp">=&gt; #&lt;Customer id: 5, first_name: "Andy", last_name: nil, title: nil, visits: 0, orders_count: nil, lock_version: 0, created_at: "2019-01-17 07:06:45", updated_at: "2019-01-17 07:06:45"&gt;</span><span class="w">
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.find_or_create_by(first_name: 'Andy')
">Copy</button>
</div>
<p>O SQL gerado por esse método parece com isso:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Andy'</span><span class="p">)</span> <span class="k">LIMIT</span> <span class="mi">1</span>
<span class="k">BEGIN</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">customers</span> <span class="p">(</span><span class="n">created_at</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">locked</span><span class="p">,</span> <span class="n">orders_count</span><span class="p">,</span> <span class="n">updated_at</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'2011-08-30 05:22:57'</span><span class="p">,</span> <span class="s1">'Andy'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">NULL</span><span class="p">,</span> <span class="s1">'2011-08-30 05:22:57'</span><span class="p">)</span>
<span class="k">COMMIT</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.first_name = 'Andy') LIMIT 1
BEGIN
INSERT INTO customers (created_at, first_name, locked, orders_count, updated_at) VALUES ('2011-08-30 05:22:57', 'Andy', 1, NULL, '2011-08-30 05:22:57')
COMMIT
">Copy</button>
</div>
<p><code>find_or_create_by</code> retorna o registro que já existe ou o novo registro. Em nosso caso, ainda não tínhamos um cliente chamado Andy, então o registro é criado e retornado.</p><p>O novo registro pode não ser salvo no banco de dados; isso depende se as validações foram aprovadas ou não (assim como <code>create</code>).</p><p>Suponha que queremos definir o atributo 'bloqueado (<em>locked</em>)' para <code>false</code> se estamos
criando um novo registro, mas não queremos incluí-lo na consulta. Então
queremos encontrar o cliente chamado "Andy", ou se esse cliente não
existir, crie um cliente chamado "Andy" que não esteja bloqueado.</p><p>Podemos conseguir isso de duas maneiras. A primeira é usar <code>create_with</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">create_with</span><span class="p">(</span><span class="ss">locked: </span><span class="kp">false</span><span class="p">).</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Andy'</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.create_with(locked: false).find_or_create_by(first_name: 'Andy')
">Copy</button>
</div>
<p>A segunda maneira é usar um bloco:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Andy'</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
  <span class="n">c</span><span class="p">.</span><span class="nf">locked</span> <span class="o">=</span> <span class="kp">false</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.find_or_create_by(first_name: 'Andy') do |c|
  c.locked = false
end
">Copy</button>
</div>
<p>O bloco só será executado se o cliente estiver sendo criado. A segunda vez que rodarmos este código, o todo o bloco será ignorado.</p><h4 id="find-or-create-by-bang"><a class="anchorlink" href="#find-or-create-by-bang">19.2 <code>find_or_create_by!</code></a></h4><p>Você também pode usar <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Relation.html#method-i-find_or_create_by-21"><code>find_or_create_by!</code></a> para disparar uma exceção se o novo registro for inválido. As validações não são abordadas neste guia, mas vamos supor por um momento que você adiciona temporariamente</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">validates</span> <span class="ss">:orders_count</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="validates :orders_count, presence: true
">Copy</button>
</div>
<p>ao seu <em>model</em> <code>Customer</code>. Se você tentar criar um novo <code>Customer</code> sem passar <code>orders_count</code>, o registro será inválido e uma exceção será disparada:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_or_create_by!</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Andy'</span><span class="p">)</span>
<span class="go">ActiveRecord::RecordInvalid: Validation failed: Orders count can't be blank
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.find_or_create_by!(first_name: 'Andy')
">Copy</button>
</div>
<h4 id="find-or-initialize-by"><a class="anchorlink" href="#find-or-initialize-by">19.3 <code>find_or_initialize_by</code></a></h4><p>O método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Relation.html#method-i-find_or_initialize_by"><code>find_or_initialize_by</code></a> funcionará como o
<code>find_or_create_by</code> mas chamará <code>new</code> ao invés de <code>create</code>. Isso significa que uma nova instância do <em>model</em> será criada na memória, mas não será salva no banco de dados. Continuando com o exemplo <code>find_or_create_by</code>, agora queremos o cliente chamado 'Nick':</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">nina</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">find_or_initialize_by</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Nina'</span><span class="p">)</span>
<span class="gp">=&gt; #&lt;Customer id: nil, first_name: "Nina", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27"&gt;</span><span class="w">
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">nina</span><span class="p">.</span><span class="nf">persisted?</span>
<span class="p">=&gt;</span> <span class="kp">false</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">nina</span><span class="p">.</span><span class="nf">new_record?</span>
<span class="p">=&gt;</span> <span class="kp">true</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="nina = Customer.find_or_initialize_by(first_name: 'Nina')
nina.persisted?
nina.new_record?
">Copy</button>
</div>
<p>Como o objeto ainda não está armazenado no banco de dados, o SQL gerado tem a seguinte aparência:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">customers</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Nina'</span><span class="p">)</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.first_name = 'Nina') LIMIT 1
">Copy</button>
</div>
<p>Quando você quiser salvar no banco, apenas chame <code>save</code>:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">nina</span><span class="p">.</span><span class="nf">save</span>
<span class="p">=&gt;</span> <span class="kp">true</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="nina.save
">Copy</button>
</div>
<h3 id="encontrando-por-sql"><a class="anchorlink" href="#encontrando-por-sql">20 Encontrando por SQL</a></h3><p>Se você quiser usar seu próprio SQL para encontrar registros em uma tabela você
pode usar <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Querying.html#method-i-find_by_sql"><code>find_by_sql</code></a>.
O método <code>find_by_sql</code> vai retornar um <em>array</em> de objetos mesmo que a consulta
subjacente retorne apenas um único registro. Por exemplo, você poderia rodar a consulta:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">find_by_sql</span><span class="p">(</span><span class="s2">"SELECT * FROM customers INNER JOIN orders ON customers.id = orders.customer_id ORDER BY customers.created_at desc"</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Lucas"</span> <span class="o">...</span><span class="kt">&gt;</span><span class="p">,</span> <span class="kt">#&lt;</span><span class="no">Customer</span> <span class="ss">id: </span><span class="mi">2</span><span class="p">,</span> <span class="ss">first_name: </span><span class="s2">"Jan"</span> <span class="o">...</span><span class="kt">&gt;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Customer.find_by_sql("SELECT * FROM customers INNER JOIN orders ON customers.id = orders.customer_id ORDER BY customers.created_at desc")
'>Copy</button>
</div>
<p><code>find_by_sql</code> fornece uma forma simples de fazer chamadas personalizadas no
banco de dados e recuperar objetos instanciados.</p><h4 id="select-all"><a class="anchorlink" href="#select-all">20.1 <code>select_all</code></a></h4><p><code>find_by_sql</code> tem um parente próximo chamado <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/ConnectionAdapters/DatabaseStatements.html#method-i-select_all"><code>connection.select_all</code></a>.
<code>select_all</code> vai recuperar objetos de um banco de dados usando SQL personalizado
como <code>find_by_sql</code>, mas não vai instanciá-los. Esse método vai retornar uma
instância da classe <code>ActiveRecord::Result</code> e chamar <code>to_a</code> neste objeto te
retornaria um array de hashes, onde cada <em>hash</em> indica um registro.</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">connection</span><span class="p">.</span><span class="nf">select_all</span><span class="p">(</span><span class="s2">"SELECT first_name, created_at FROM customers WHERE id = '1'"</span><span class="p">).</span><span class="nf">to_a</span>
<span class="p">=&gt;</span> <span class="p">[{</span><span class="s2">"first_name"</span><span class="o">=&gt;</span><span class="s2">"Rafael"</span><span class="p">,</span> <span class="s2">"created_at"</span><span class="o">=&gt;</span><span class="s2">"2012-11-10 23:23:45.281189"</span><span class="p">},</span> <span class="p">{</span><span class="s2">"first_name"</span><span class="o">=&gt;</span><span class="s2">"Eileen"</span><span class="p">,</span> <span class="s2">"created_at"</span><span class="o">=&gt;</span><span class="s2">"2013-12-09 11:22:35.221282"</span><span class="p">}]</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.connection.select_all(&quot;SELECT first_name, created_at FROM customers WHERE id = '1'&quot;).to_a
">Copy</button>
</div>
<h4 id="pluck"><a class="anchorlink" href="#pluck">20.2 <code>pluck</code></a></h4><p><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Calculations.html#method-i-pluck"><code>pluck</code></a> pode ser usado para consultar uma ou múltiplas colunas da tabela de um
<em>model</em>. Ele aceita uma lista de nomes de colunas como argumento e retorna um
<em>array</em> dos valores das colunas especificadas com o tipo de dado correspondente.</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
<span class="go">SELECT id FROM books WHERE out_of_print = true
</span><span class="p">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Order</span><span class="p">.</span><span class="nf">distinct</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:status</span><span class="p">)</span>
<span class="go">SELECT DISTINCT status FROM orders
</span><span class="p">=&gt;</span> <span class="p">[</span><span class="s2">"shipped"</span><span class="p">,</span> <span class="s2">"being_packed"</span><span class="p">,</span> <span class="s2">"cancelled"</span><span class="p">]</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:first_name</span><span class="p">)</span>
<span class="go">SELECT customers.id, customers.first_name FROM customers
</span><span class="p">=&gt;</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="s2">"David"</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s2">"Fran"</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s2">"Jose"</span><span class="p">]]</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Book.where(out_of_print: true).pluck(:id)
Order.distinct.pluck(:status)
Customer.pluck(:id, :first_name)
">Copy</button>
</div>
<p><code>pluck</code> possibilita substituir código como:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="n">c</span><span class="p">.</span><span class="nf">id</span> <span class="p">}</span>
<span class="c1"># ou</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:id</span><span class="p">)</span>
<span class="c1"># ou</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:first_name</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="p">[</span><span class="n">c</span><span class="p">.</span><span class="nf">id</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="nf">first_name</span><span class="p">]</span> <span class="p">}</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.select(:id).map { |c| c.id }
# ou
Customer.select(:id).map(&amp;:id)
# ou
Customer.select(:id, :first_name).map { |c| [c.id, c.first_name] }
">Copy</button>
</div>
<p>com:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
<span class="c1"># ou</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:first_name</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.pluck(:id)
# ou
Customer.pluck(:id, :first_name)
">Copy</button>
</div>
<p>Diferentemente do <code>select</code>, <code>pluck</code> converte diretamente os resultados do banco
de dados em um <code>Array</code> Ruby, sem construir objetos <code>ActiveRecord</code>. Isso pode
significar melhor performance para consultas grandes ou frequentemente rodadas.
No entanto, qualquer método de <em>model</em> sobrescrito não estará disponível. Por
exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nf">name</span>
    <span class="s2">"I am </span><span class="si">#{</span><span class="n">first_name</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='class Customer &lt; ApplicationRecord
  def name
    "I am #{first_name}"
  end
end
'>Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">).</span><span class="nf">map</span> <span class="o">&amp;</span><span class="ss">:name</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="s2">"I am David"</span><span class="p">,</span> <span class="s2">"I am Jeremy"</span><span class="p">,</span> <span class="s2">"I am Jose"</span><span class="p">]</span>

<span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="s2">"David"</span><span class="p">,</span> <span class="s2">"Jeremy"</span><span class="p">,</span> <span class="s2">"Jose"</span><span class="p">]</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.select(:first_name).map &amp;:name
Customer.pluck(:first_name)
">Copy</button>
</div>
<p>Suas buscas não ficam limitadas a campos de uma única tabela, você também pode
consultar múltiplas tabelas.</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Order</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:customer</span><span class="p">,</span> <span class="ss">:books</span><span class="p">).</span><span class="nf">pluck</span><span class="p">(</span><span class="s2">"orders.created_at, customers.email, books.title"</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Order.joins(:customer, :books).pluck("orders.created_at, customers.email, books.title")
'>Copy</button>
</div>
<p>Além disso, diferente do <code>select</code> e outros escopos <code>Relation</code>, <code>pluck</code>
desencadeia uma consulta imediata, e portanto não pode ser encadeado com
outros escopos, apesar de poder funcionar com escopos construídos anteriormente.</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gr">NoMethodError: undefined method `limit' for #&lt;Array:0x007ff34d3ad6d8&gt;
</span><span class="err">
</span><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="s2">"David"</span><span class="p">]</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.pluck(:first_name).limit(1)
Customer.limit(1).pluck(:first_name)
">Copy</button>
</div>
<div class="note"><p>Você deve saber que usar o <code>pluck</code> vai desencadear <em>eager loading</em> se o
objeto relacional contiver valores <code>include</code>, mesmo que <em>eager loading</em> não
seja necessário para consulta. Por exemplo:</p></div><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">assoc</span> <span class="o">=</span> <span class="no">Customer</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:reviews</span><span class="p">)</span>
<span class="gp">irb&gt;</span><span class="w"> </span><span class="n">assoc</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
<span class="go">SELECT "customers"."id" FROM "customers" LEFT OUTER JOIN "reviews" ON "reviews"."id" = "customers"."review_id"
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="assoc = Customer.includes(:reviews)
assoc.pluck(:id)
">Copy</button>
</div>
<p>Uma maneira de evitar isso é usar <code>unscope</code> com <code>includes</code>:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="n">assoc</span><span class="p">.</span><span class="nf">unscope</span><span class="p">(</span><span class="ss">:includes</span><span class="p">).</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="assoc.unscope(:includes).pluck(:id)
">Copy</button>
</div>
<h4 id="ids"><a class="anchorlink" href="#ids">20.3 <code>ids</code></a></h4><p><a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Calculations.html#method-i-ids"><code>ids</code></a> pode ser usado para obter todos os IDs da relação usando a chave
primária da tabela.</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">ids</span>
<span class="go">SELECT id FROM customers
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.ids
">Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Customer</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">primary_key</span> <span class="o">=</span> <span class="s2">"customer_id"</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='class Customer &lt; ApplicationRecord
  self.primary_key = "customer_id"
end
'>Copy</button>
</div>
<div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">ids</span>
<span class="go">SELECT customer_id FROM customers
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.ids
">Copy</button>
</div>
<h3 id="existência-de-objetos"><a class="anchorlink" href="#exist%C3%AAncia-de-objetos">21 Existência de Objetos</a></h3><p>Se você simplesmente quer checar a existência do objeto, existe um método chamado <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/FinderMethods.html#method-i-exists-3F"><code>exists?</code></a>.
Este método irá consultar o banco de dados usando a mesma consulta que <code>find</code>, mas ao invés de retornar um objeto ou uma coleção de objetos, irá retornar <code>true</code> ou <code>false</code>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.exists?(1)
">Copy</button>
</div>
<p>O método <code>exists?</code> também assume valores múltiplos, mas o problema é que retornará <code>true</code> se algum desses registros existirem.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(</span><span class="ss">id: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="c1"># ou</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(</span><span class="ss">name: </span><span class="p">[</span><span class="s1">'Jane'</span><span class="p">,</span> <span class="s1">'Sergei'</span><span class="p">])</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.exists?(id: [1,2,3])
# ou
Customer.exists?(name: ['Jane', 'Sergei'])
">Copy</button>
</div>
<p>É até possível usar <code>exists?</code> sem algum argumento em um <em>model</em> ou relação.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Ryan'</span><span class="p">).</span><span class="nf">exists?</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.where(first_name: 'Ryan').exists?
">Copy</button>
</div>
<p>O código acima retorna <code>true</code> se existir ao menos um cliente com o <code>first_name</code> 'Ryan' e <code>false</code> caso não exista.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">exists?</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.exists?
">Copy</button>
</div>
<p>O código acima retorna <code>false</code> se a tabela <code>customers</code> estiver vazia e <code>true</code> caso não esteja.</p><p>Você também pode usar <code>any?</code> e <code>many?</code> para verificar a existência de um <em>model</em> ou relação. <code>many?</code> irá usar o <code>count</code> do SQL para determinar se o item existe.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># via a model</span>
<span class="no">Order</span><span class="p">.</span><span class="nf">any?</span>
<span class="c1"># =&gt; SELECT 1 FROM orders LIMIT 1</span>
<span class="no">Order</span><span class="p">.</span><span class="nf">many?</span>
<span class="c1"># =&gt; SELECT COUNT(*) FROM (SELECT 1 FROM orders LIMIT 2)</span>

<span class="c1"># via um scope nomeado</span>
<span class="no">Order</span><span class="p">.</span><span class="nf">shipped</span><span class="p">.</span><span class="nf">any?</span>
<span class="c1"># =&gt; SELECT 1 FROM orders WHERE orders.status = 0 LIMIT 1</span>
<span class="no">Order</span><span class="p">.</span><span class="nf">shipped</span><span class="p">.</span><span class="nf">many?</span>
<span class="c1"># =&gt; SELECT COUNT(*) FROM (SELECT 1 FROM orders WHERE orders.status = 0 LIMIT 2)</span>

<span class="c1"># via uma relação</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">any?</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">out_of_print: </span><span class="kp">true</span><span class="p">).</span><span class="nf">many?</span>

<span class="c1"># via uma associação</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">any?</span>
<span class="no">Customer</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">orders</span><span class="p">.</span><span class="nf">many?</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="# via a model
Order.any?
# =&gt; SELECT 1 FROM orders LIMIT 1
Order.many?
# =&gt; SELECT COUNT(*) FROM (SELECT 1 FROM orders LIMIT 2)

# via um scope nomeado
Order.shipped.any?
# =&gt; SELECT 1 FROM orders WHERE orders.status = 0 LIMIT 1
Order.shipped.many?
# =&gt; SELECT COUNT(*) FROM (SELECT 1 FROM orders WHERE orders.status = 0 LIMIT 2)

# via uma relação
Book.where(out_of_print: true).any?
Book.where(out_of_print: true).many?

# via uma associação
Customer.first.orders.any?
Customer.first.orders.many?
">Copy</button>
</div>
<h3 id="cálculos"><a class="anchorlink" href="#c%C3%A1lculos">22 Cálculos</a></h3><p>Essa seção usa <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Calculations.html#method-i-count"><code>count</code></a> como exemplo de método nessa introdução, mas as opções descritas se aplicam para todas as
subseções.</p><p>Todos os métodos de cálculo funcionam diretamente em um <em>model</em>:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">count</span>
<span class="go">SELECT COUNT(*) FROM customers
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.count
">Copy</button>
</div>
<p>Ou em uma relação:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Ryan'</span><span class="p">).</span><span class="nf">count</span>
<span class="go">SELECT COUNT(*) FROM customers WHERE (first_name = 'Ryan')
</span></code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.where(first_name: 'Ryan').count
">Copy</button>
</div>
<p>Você também pode utilizar vários métodos de busca em uma relação para fazer cálculos complexos:</p><div class="code_container">
<pre><code class="highlight irb"><span class="gp">irb&gt;</span><span class="w"> </span><span class="no">Customer</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="s2">"orders"</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Ryan'</span><span class="p">,</span> <span class="ss">orders: </span><span class="p">{</span> <span class="ss">status: </span><span class="s1">'shipped'</span> <span class="p">}).</span><span class="nf">count</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.includes(&quot;orders&quot;).where(first_name: 'Ryan', orders: { status: 'shipped' }).count
">Copy</button>
</div>
<p>O que vai executar:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">customers</span>
  <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">orders</span> <span class="k">ON</span> <span class="n">orders</span><span class="p">.</span><span class="n">customer_id</span> <span class="o">=</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span>
  <span class="k">WHERE</span> <span class="p">(</span><span class="n">customers</span><span class="p">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Ryan'</span> <span class="k">AND</span> <span class="n">orders</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="SELECT COUNT(DISTINCT customers.id) FROM customers
  LEFT OUTER JOIN orders ON orders.customer_id = customers.id
  WHERE (customers.first_name = 'Ryan' AND orders.status = 0)
">Copy</button>
</div>
<p>assumindo que a classe <code>Order</code> tenha um <code>enum status: [ :shipped, :being_packed, :cancelled  ]</code>.</p><h4 id="contar-count"><a class="anchorlink" href="#contar-count">22.1 Contar (<em>count</em>)</a></h4><p>Se você quiser saber quantos registros estão na tabela do seu <em>model</em> você pode chamar <code>Customer.count</code> e isso vai retornar um número.
Se você quiser ser mais específico e encontrar todos os clientes que tem idade presente no banco de dados, você pode utilizar
<code>Customer.count(:age)</code></p><p>Para mais opções, veja a seção pai, <a href="#calculos">Cálculos</a>.</p><h4 id="média-average"><a class="anchorlink" href="#m%C3%A9dia-average">22.2 Média (<em>average</em>)</a></h4><p>Se você quiser saber a média de um certo número em uma das suas tabelas, você pode chamar o método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Calculations.html#method-i-average"><code>average</code></a>
na sua classe que se relaciona com essa tabela. Essa chamada de método vai parecer desse jeito:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Order</span><span class="p">.</span><span class="nf">average</span><span class="p">(</span><span class="s2">"subtotal"</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Order.average("subtotal")
'>Copy</button>
</div>
<p>Isso vai retornar um número (possivelmente um número de ponto flutuante como 3.14159265) representando o valor médio
desse campo.</p><p>Para mais opções, veja a seção pai, <a href="#calculos">Cálculos</a>.</p><h4 id="mínimo-minimum"><a class="anchorlink" href="#m%C3%ADnimo-minimum">22.3 Mínimo (<em>minimum</em>)</a></h4><p>Se você quiser encontrar o valor mínimo de um campo na sua tabela, você pode chamar o método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Calculations.html#method-i-minimum"><code>minimum</code></a>
na classe que se relaciona com a tabela. Essa chamada de método vai parecer desse jeito:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Order</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="s2">"subtotal"</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Order.minimum("subtotal")
'>Copy</button>
</div>
<p>Para mais opções, veja a seção pai, <a href="#calculos">Cálculos</a>.</p><h4 id="máximo-maximum"><a class="anchorlink" href="#m%C3%A1ximo-maximum">22.4 Máximo (<em>maximum</em>)</a></h4><p>Se você quiser encontrar o valor máximo de um campo na sua tabela, você pode chamar o método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Calculations.html#method-i-maximum"><code>maximum</code></a>
na classe que se relaciona com a tabela. Essa chamada de método vai parecer desse jeito:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Order</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="s2">"subtotal"</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Order.maximum("subtotal")
'>Copy</button>
</div>
<p>Para mais opções, veja a seção pai, <a href="#calculos">Cálculos</a>.</p><h4 id="soma-sum"><a class="anchorlink" href="#soma-sum">22.5 Soma (<em>sum</em>)</a></h4><p>Se você quiser encontrar a soma de todos os registros na sua tabela, você pode chamar o método <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Calculations.html#method-i-sum"><code>sum</code></a>
na classe que se relaciona com a tabela. Essa chamada de método vai parecer desse jeito:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Order</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="s2">"subtotal"</span><span class="p">)</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text='Order.sum("subtotal")
'>Copy</button>
</div>
<p>Para mais opções, veja a seção pai, <a href="#calculos">Cálculos</a>.</p><h3 id="executando-o-explain"><a class="anchorlink" href="#executando-o-explain">23 Executando o EXPLAIN</a></h3><p>Você pode executar o <a href="https://api.rubyonrails.org/v7.0.8/classes/ActiveRecord/Relation.html#method-i-explain"><code>explain</code></a> nas <em>queries</em> disparadas por relações. O retorno de <em>EXPLAIN</em> varia entre os banco de dados.</p><p>Por exemplo, executar</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">explain</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.where(id: 1).joins(:orders).explain
">Copy</button>
</div>
<p>pode produzir</p><div class="code_container">
<pre><code class="highlight plaintext">EXPLAIN for: SELECT `customers`.* FROM `customers` INNER JOIN `orders` ON `orders`.`customer_id` = `customers`.`id` WHERE `customers`.`id` = 1
+----+-------------+------------+-------+---------------+
| id | select_type | table      | type  | possible_keys |
+----+-------------+------------+-------+---------------+
|  1 | SIMPLE      | customers  | const | PRIMARY       |
|  1 | SIMPLE      | orders     | ALL   | NULL          |
+----+-------------+------------+-------+---------------+
+---------+---------+-------+------+-------------+
| key     | key_len | ref   | rows | Extra       |
+---------+---------+-------+------+-------------+
| PRIMARY | 4       | const |    1 |             |
| NULL    | NULL    | NULL  |    1 | Using where |
+---------+---------+-------+------+-------------+

2 rows in set (0.00 sec)
</code></pre>
<button class="clipboard-button" data-clipboard-text="EXPLAIN for: SELECT `customers`.* FROM `customers` INNER JOIN `orders` ON `orders`.`customer_id` = `customers`.`id` WHERE `customers`.`id` = 1
+----+-------------+------------+-------+---------------+
| id | select_type | table      | type  | possible_keys |
+----+-------------+------------+-------+---------------+
|  1 | SIMPLE      | customers  | const | PRIMARY       |
|  1 | SIMPLE      | orders     | ALL   | NULL          |
+----+-------------+------------+-------+---------------+
+---------+---------+-------+------+-------------+
| key     | key_len | ref   | rows | Extra       |
+---------+---------+-------+------+-------------+
| PRIMARY | 4       | const |    1 |             |
| NULL    | NULL    | NULL  |    1 | Using where |
+---------+---------+-------+------+-------------+

2 rows in set (0.00 sec)
">Copy</button>
</div>
<p>em MySQL e MariaDB.</p><p>O <em>Active Record</em> exibe uma impressão que simula a do <em>shell</em> do banco de dados correspondente. Então, a mesma <em>query</em> sendo executada quando usado o adaptador de PostgreSQL poderá produzir o seguinte:</p><div class="code_container">
<pre><code class="highlight plaintext">EXPLAIN for: SELECT "customers".* FROM "customers" INNER JOIN "orders" ON "orders"."customer_id" = "customers"."id" WHERE "customers"."id" = $1 [["id", 1]]
                                  QUERY PLAN
------------------------------------------------------------------------------
 Nested Loop  (cost=4.33..20.85 rows=4 width=164)
    -&gt;  Index Scan using customers_pkey on customers  (cost=0.15..8.17 rows=1 width=164)
          Index Cond: (id = '1'::bigint)
    -&gt;  Bitmap Heap Scan on orders  (cost=4.18..12.64 rows=4 width=8)
          Recheck Cond: (customer_id = '1'::bigint)
          -&gt;  Bitmap Index Scan on index_orders_on_customer_id  (cost=0.00..4.18 rows=4 width=0)
                Index Cond: (customer_id = '1'::bigint)
(7 rows)
</code></pre>
<button class="clipboard-button" data-clipboard-text="EXPLAIN for: SELECT &quot;customers&quot;.* FROM &quot;customers&quot; INNER JOIN &quot;orders&quot; ON &quot;orders&quot;.&quot;customer_id&quot; = &quot;customers&quot;.&quot;id&quot; WHERE &quot;customers&quot;.&quot;id&quot; = $1 [[&quot;id&quot;, 1]]
                                  QUERY PLAN
------------------------------------------------------------------------------
 Nested Loop  (cost=4.33..20.85 rows=4 width=164)
    -&gt;  Index Scan using customers_pkey on customers  (cost=0.15..8.17 rows=1 width=164)
          Index Cond: (id = '1'::bigint)
    -&gt;  Bitmap Heap Scan on orders  (cost=4.18..12.64 rows=4 width=8)
          Recheck Cond: (customer_id = '1'::bigint)
          -&gt;  Bitmap Index Scan on index_orders_on_customer_id  (cost=0.00..4.18 rows=4 width=0)
                Index Cond: (customer_id = '1'::bigint)
(7 rows)
">Copy</button>
</div>
<p>O <em>Eager Loading</em> pode disparar mais que uma <em>query</em> por debaixo dos panos,
e algumas <em>queries</em> podem necessitar de resultados prévios. Por causa disso,
o <code>explain</code> na verdade executa a <em>query</em> e somente depois solicita o que a <em>query</em> planeja.
Por exemplo,</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Customer</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">explain</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="Customer.where(id: 1).includes(:orders).explain
">Copy</button>
</div>
<p>produz isso em MySQL e MariaDB.</p><div class="code_container">
<pre><code class="highlight plaintext">EXPLAIN for: SELECT `customers`.* FROM `customers`  WHERE `customers`.`id` = 1
+----+-------------+-----------+-------+---------------+
| id | select_type | table     | type  | possible_keys |
+----+-------------+-----------+-------+---------------+
|  1 | SIMPLE      | customers | const | PRIMARY       |
+----+-------------+-----------+-------+---------------+
+---------+---------+-------+------+-------+
| key     | key_len | ref   | rows | Extra |
+---------+---------+-------+------+-------+
| PRIMARY | 4       | const |    1 |       |
+---------+---------+-------+------+-------+

1 row in set (0.00 sec)

EXPLAIN for: SELECT `orders`.* FROM `orders`  WHERE `orders`.`customer_id` IN (1)
+----+-------------+--------+------+---------------+
| id | select_type | table  | type | possible_keys |
+----+-------------+--------+------+---------------+
|  1 | SIMPLE      | orders | ALL  | NULL          |
+----+-------------+--------+------+---------------+
+------+---------+------+------+-------------+
| key  | key_len | ref  | rows | Extra       |
+------+---------+------+------+-------------+
| NULL | NULL    | NULL |    1 | Using where |
+------+---------+------+------+-------------+


1 row in set (0.00 sec)
</code></pre>
<button class="clipboard-button" data-clipboard-text="EXPLAIN for: SELECT `customers`.* FROM `customers`  WHERE `customers`.`id` = 1
+----+-------------+-----------+-------+---------------+
| id | select_type | table     | type  | possible_keys |
+----+-------------+-----------+-------+---------------+
|  1 | SIMPLE      | customers | const | PRIMARY       |
+----+-------------+-----------+-------+---------------+
+---------+---------+-------+------+-------+
| key     | key_len | ref   | rows | Extra |
+---------+---------+-------+------+-------+
| PRIMARY | 4       | const |    1 |       |
+---------+---------+-------+------+-------+

1 row in set (0.00 sec)

EXPLAIN for: SELECT `orders`.* FROM `orders`  WHERE `orders`.`customer_id` IN (1)
+----+-------------+--------+------+---------------+
| id | select_type | table  | type | possible_keys |
+----+-------------+--------+------+---------------+
|  1 | SIMPLE      | orders | ALL  | NULL          |
+----+-------------+--------+------+---------------+
+------+---------+------+------+-------------+
| key  | key_len | ref  | rows | Extra       |
+------+---------+------+------+-------------+
| NULL | NULL    | NULL |    1 | Using where |
+------+---------+------+------+-------------+


1 row in set (0.00 sec)
">Copy</button>
</div>
<p>e isso no PostgreSQL:</p><div class="code_container">
<pre><code class="highlight plaintext">  Customer Load (0.3ms)  SELECT "customers".* FROM "customers" WHERE "customers"."id" = $1  [["id", 1]]
  Order Load (0.3ms)  SELECT "orders".* FROM "orders" WHERE "orders"."customer_id" = $1  [["customer_id", 1]]
=&gt; EXPLAIN for: SELECT "customers".* FROM "customers" WHERE "customers"."id" = $1 [["id", 1]]
                                    QUERY PLAN
----------------------------------------------------------------------------------
 Index Scan using customers_pkey on customers  (cost=0.15..8.17 rows=1 width=164)
   Index Cond: (id = '1'::bigint)
(2 rows)
</code></pre>
<button class="clipboard-button" data-clipboard-text="  Customer Load (0.3ms)  SELECT &quot;customers&quot;.* FROM &quot;customers&quot; WHERE &quot;customers&quot;.&quot;id&quot; = $1  [[&quot;id&quot;, 1]]
  Order Load (0.3ms)  SELECT &quot;orders&quot;.* FROM &quot;orders&quot; WHERE &quot;orders&quot;.&quot;customer_id&quot; = $1  [[&quot;customer_id&quot;, 1]]
=&gt; EXPLAIN for: SELECT &quot;customers&quot;.* FROM &quot;customers&quot; WHERE &quot;customers&quot;.&quot;id&quot; = $1 [[&quot;id&quot;, 1]]
                                    QUERY PLAN
----------------------------------------------------------------------------------
 Index Scan using customers_pkey on customers  (cost=0.15..8.17 rows=1 width=164)
   Index Cond: (id = '1'::bigint)
(2 rows)
">Copy</button>
</div>
<h4 id="interpretando-o-explain"><a class="anchorlink" href="#interpretando-o-explain">23.1 Interpretando o EXPLAIN</a></h4><p>A interpretação da saída do <em>EXPLAIN</em> está além do escopo deste guia. Os links
a seguir podem servir de ajuda:</p>
<ul>
<li><p>SQLite3: <a href="https://www.sqlite.org/eqp.html">EXPLAIN QUERY PLAN</a></p></li>
<li><p>MySQL: <a href="https://dev.mysql.com/doc/refman/en/explain-output.html">EXPLAIN Output Format</a></p></li>
<li><p>MariaDB: <a href="https://mariadb.com/kb/en/mariadb/explain/">EXPLAIN</a></p></li>
<li><p>PostgreSQL: <a href="https://www.postgresql.org/docs/current/static/using-explain.html">Using EXPLAIN</a></p></li>
</ul>


        <h3>Feedback</h3>
        <p>
          Você é incentivado a ajudar a melhorar a qualidade deste guia.
        </p>
        <p>
          Por favor, contribua caso veja quaisquer erros, inclusive erros de digitação.
          Para começar, você pode ler nossa sessão de <a href="https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">contribuindo com a documentação</a>.
        </p>
        <p>
          Você também pode encontrar conteúdo incompleto ou coisas que não estão atualizadas.
          Por favor, adicione qualquer documentação em falta na main do Rails. Certifique-se de checar o
          <a href="http://edgeguides.rubyonrails.org">Edge Guides (en-US)</a> primeiro para verificar
          se o problema já foi resolvido ou não no branch main.
          Verifique as <a href="ruby_on_rails_guides_guidelines.html">Diretrizes do Guia Ruby on Rails</a>
          para estilo e convenções.
        </p>
        <p>
          Se, por qualquer motivo, você encontrar algo para consertar, mas não conseguir consertá-lo, por favor
          <a href="https://github.com/campuscode/rails-guides-pt-BR/issues">abra uma issue no nosso Guia</a>.
        </p>
        <p>
          E por último, mas não menos importante, qualquer tipo de discussão sobre a documentação do Ruby on Rails
          é muito bem vinda na <a href="https://discuss.rubyonrails.org/c/rubyonrails-docs">forum oficial do Ruby on Rails</a> e nas
          <a href="https://github.com/campuscode/rails-guides-pt-BR/issues">issues do Guia em português</a>.
        </p>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p> Este projeto está licenciado sob uma licença <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International</a></p>
<p>"Rails", "Ruby on Rails", e o logotipo Rails são marcas comerciais de David Heinemeier Hansson. Todos os direitos reservados.</p>

    </div>
  </div>
  <div id="toggle">
    <img alt="dark theme icon" class="icon">
  </div>
</body>
</html>
