<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Interface de Consulta do Active Record — Ruby on Rails Guides</title>
  <link rel="stylesheet" type="text/css" href="stylesheets/style.css" data-turbolinks-track="reload">
  <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
  <link rel="stylesheet" type="text/css" href="stylesheets/highlight.css" data-turbolinks-track="reload">
  <link rel="stylesheet" type="text/css" href="stylesheets/search.css" data-turbolinks-track="reload">
  <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
  <script src="javascripts/turbolinks.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/clipboard.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/guides.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/search.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/lunr-documents.js" data-turbolinks-track="reload"></script>
  <script src="javascripts/lunr.js" data-turbolinks-track="reload"></script>
  <meta property="og:title" content="Interface de Consulta do Active Record — Ruby on Rails Guides" />
  <meta name="description" content="Interface de Consulta do Active RecordEste guia cobre diferentes maneiras de recuperar dados de um banco de dados utilizando o Active RecordApós ler esse guia, você saberá: Como encontrar registros usando uma variedade de métodos e condições. Como especificar a ordem, os atributos recuperados, agrupamento e outras propriedades dos registros encontrados. Como usar o eager loading para reduzir o número de consultas necessárias no banco de dados para recuperar os dados. Como utilizar métodos localizadores dinâmicos. Como utilizar encadeamento de métodos para usar múltiplos métodos do Active Record em conjunto. Como checar a existência de determinados registros. Como executar diversos cálculos nos models do Active Record. Como executar o EXPLAIN nas relações." />
  <meta property="og:description" content="Interface de Consulta do Active RecordEste guia cobre diferentes maneiras de recuperar dados de um banco de dados utilizando o Active RecordApós ler esse guia, você saberá: Como encontrar registros usando uma variedade de métodos e condições. Como especificar a ordem, os atributos recuperados, agrupamento e outras propriedades dos registros encontrados. Como usar o eager loading para reduzir o número de consultas necessárias no banco de dados para recuperar os dados. Como utilizar métodos localizadores dinâmicos. Como utilizar encadeamento de métodos para usar múltiplos métodos do Active Record em conjunto. Como checar a existência de determinados registros. Como executar diversos cálculos nos models do Active Record. Como executar o EXPLAIN nas relações." />
  <meta property="og:locale" content="pt_BR" />
  <meta property="og:site_name" content="Guia Ruby on Rails" />
  <meta property="og:image" content="https://avatars.githubusercontent.com/u/4223" />
  <meta property="og:type" content="website" />
</head>
<body class="guide">
  <div id="topNav">
    <div class="wrapper">
      <strong class="more-info-label">Veja mais em <a href="https://rubyonrails.org/">rubyonrails.org:</a> </strong>
      <span class="red-button more-info-button">
        Mais Ruby on Rails
      </span>
      <ul class="more-info-links s-hidden">
        <li class="more-info"><a href="https://weblog.rubyonrails.org/">Blog</a></li>
        <li class="more-info"><a href="https://guides.rubyonrails.org/">Guia oficial</a></li>
        <li class="more-info"><a href="https://api.rubyonrails.org/">API</a></li>
        <li class="more-info"><a href="https://stackoverflow.com/questions/tagged/ruby-on-rails">Peça por ajuda</a></li>
        <li class="more-info"><a href="https://github.com/rails/rails">Contribua no GitHub</a></li>
      </ul>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="Voltar para a página principal">Guiarails.com.br</a></h1>
      <ul class="nav">
        <li><a class="nav-item" href="index.html">Home</a></li>
        <li class="guides-search guides-search-large">
          <input class="search-box search-box-large nav-item" type="text" placeholder="Digite o termo...">
          <div class="search-results"></div>
          <div class="search-spinner">Aguarde...</div>
        </li>
        <li class="guides-index guides-index-large">
          <a href="index.html" id="guidesMenu" class="guides-index-item nav-item">Guias</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <div class="guides-section-container">
                <div class="guides-section">
                  <dt>Comece aqui</dt>
                  <dd><a href="getting_started.html">Começando com Rails</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Models</dt>
                  <dd><a href="active_record_basics.html">Active Record Basics</a></dd>
                  <dd><a href="active_record_migrations.html">Active Record Migrations</a></dd>
                  <dd><a href="active_record_validations.html">Active Record Validations</a></dd>
                  <dd><a href="active_record_callbacks.html">Active Record Callbacks</a></dd>
                  <dd><a href="association_basics.html">Active Record Associations</a></dd>
                  <dd><a href="active_record_querying.html">Active Record Query Interface</a></dd>
                  <dd><a href="active_model_basics.html">Active Model Basics</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Views</dt>
                  <dd><a href="action_view_overview.html">Action View Overview</a></dd>
                  <dd><a href="layouts_and_rendering.html">Layouts and Rendering in Rails</a></dd>
                  <dd><a href="form_helpers.html">Action View Form Helpers</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Controllers</dt>
                  <dd><a href="action_controller_overview.html">Action Controller Overview</a></dd>
                  <dd><a href="routing.html">Rails Routing from the Outside In</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Outros componentes</dt>
                  <dd><a href="active_support_core_extensions.html">Active Support Core Extensions</a></dd>
                  <dd><a href="action_mailer_basics.html">Action Mailer Basics</a></dd>
                  <dd><a href="action_mailbox_basics.html">Action Mailbox Basics</a></dd>
                  <dd><a href="action_text_overview.html">Action Text Overview</a></dd>
                  <dd><a href="active_job_basics.html">Active Job Basics</a></dd>
                  <dd><a href="active_storage_overview.html">Active Storage Overview</a></dd>
                  <dd><a href="action_cable_overview.html">Action Cable Overview</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Indo mais fundo</dt>
                  <dd><a href="i18n.html">Rails Internationalization (I18n) API</a></dd>
                  <dd><a href="testing.html">Testing Rails Applications</a></dd>
                  <dd><a href="security.html">Securing Rails Applications</a></dd>
                  <dd><a href="debugging_rails_applications.html">Debugging Rails Applications</a></dd>
                  <dd><a href="configuring.html">Configuring Rails Applications</a></dd>
                  <dd><a href="command_line.html">The Rails Command Line</a></dd>
                  <dd><a href="asset_pipeline.html">The Asset Pipeline</a></dd>
                  <dd><a href="working_with_javascript_in_rails.html">Working with JavaScript in Rails</a></dd>
                  <dd><a href="initialization.html">The Rails Initialization Process</a></dd>
                  <dd><a href="autoloading_and_reloading_constants.html">Autoloading and Reloading Constants (Zeitwerk Mode)</a></dd>
                  <dd><a href="autoloading_and_reloading_constants_classic_mode.html">Autoloading and Reloading Constants (Classic Mode)</a></dd>
                  <dd><a href="caching_with_rails.html">Caching with Rails: An Overview</a></dd>
                  <dd><a href="active_support_instrumentation.html">Active Support Instrumentation</a></dd>
                  <dd><a href="api_app.html">Using Rails for API-only Applications</a></dd>
                  <dd><a href="active_record_postgresql.html">Active Record and PostgreSQL</a></dd>
                  <dd><a href="active_record_multiple_databases.html">Multiple Databases with Active Record</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Estendendo o Rails</dt>
                  <dd><a href="plugins.html">The Basics of Creating Rails Plugins</a></dd>
                  <dd><a href="rails_on_rack.html">Rails on Rack</a></dd>
                  <dd><a href="generators.html">Creating and Customizing Rails Generators &amp; Templates</a></dd>
                  <dd><a href="engines.html">Getting Started with Engines</a></dd>
                  <dd><a href="threading_and_code_execution.html">Threading and Code Execution in Rails</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Contribuições</dt>
                  <dd><a href="contributing_to_ruby_on_rails.html">Contributing to Ruby on Rails</a></dd>
                  <dd><a href="api_documentation_guidelines.html">API Documentation Guidelines</a></dd>
                  <dd><a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Políticas</dt>
                  <dd><a href="maintenance_policy.html">Maintenance Policy for Ruby on Rails</a></dd>
                </div>
                <div class="guides-section">
                  <dt>Release Notes</dt>
                  <dd><a href="upgrading_ruby_on_rails.html">Upgrading Ruby on Rails</a></dd>
                  <dd><a href="6_0_release_notes.html">6.0 Release Notes - Agosto 2019</a></dd>
                  <dd><a href="5_2_release_notes.html">Version 5.2 - April 2018</a></dd>
                  <dd><a href="5_1_release_notes.html">Version 5.1 - April 2017</a></dd>
                  <dd><a href="5_0_release_notes.html">Version 5.0 - June 2016</a></dd>
                  <dd><a href="4_2_release_notes.html">Version 4.2 - December 2014</a></dd>
                  <dd><a href="4_1_release_notes.html">Version 4.1 - April 2014</a></dd>
                  <dd><a href="4_0_release_notes.html">Version 4.0 - June 2013</a></dd>
                  <dd><a href="3_2_release_notes.html">Version 3.2 - January 2012</a></dd>
                  <dd><a href="3_1_release_notes.html">Version 3.1 - August 2011</a></dd>
                  <dd><a href="3_0_release_notes.html">Version 3.0 - August 2010</a></dd>
                  <dd><a href="2_3_release_notes.html">Version 2.3 - March 2009</a></dd>
                  <dd><a href="2_2_release_notes.html">Version 2.2 - November 2008</a></dd>
                </div>
            </div>
          </div>
        </li>
        <li><a class="nav-item" href="contributing_to_ruby_on_rails.html">Contribua</a></li>
        <li class="guides-search guides-search-small">
          <input class="search-box search-box-small nav-item" type="text" placeholder="Digite o termo...">
          <div class="search-results"></div>
          <div class="search-spinner">Aguarde...</div>
        </li>
        <li class="guides-index guides-index-small">
          <select class="guides-index-item nav-item">
            <option value="index.html">Guias</option>
              <optgroup label="Comece aqui">
                  <option value="getting_started.html">Começando com Rails</option>
              </optgroup>
              <optgroup label="Models">
                  <option value="active_record_basics.html">Active Record Basics</option>
                  <option value="active_record_migrations.html">Active Record Migrations</option>
                  <option value="active_record_validations.html">Active Record Validations</option>
                  <option value="active_record_callbacks.html">Active Record Callbacks</option>
                  <option value="association_basics.html">Active Record Associations</option>
                  <option value="active_record_querying.html">Active Record Query Interface</option>
                  <option value="active_model_basics.html">Active Model Basics</option>
              </optgroup>
              <optgroup label="Views">
                  <option value="action_view_overview.html">Action View Overview</option>
                  <option value="layouts_and_rendering.html">Layouts and Rendering in Rails</option>
                  <option value="form_helpers.html">Action View Form Helpers</option>
              </optgroup>
              <optgroup label="Controllers">
                  <option value="action_controller_overview.html">Action Controller Overview</option>
                  <option value="routing.html">Rails Routing from the Outside In</option>
              </optgroup>
              <optgroup label="Outros componentes">
                  <option value="active_support_core_extensions.html">Active Support Core Extensions</option>
                  <option value="action_mailer_basics.html">Action Mailer Basics</option>
                  <option value="action_mailbox_basics.html">Action Mailbox Basics</option>
                  <option value="action_text_overview.html">Action Text Overview</option>
                  <option value="active_job_basics.html">Active Job Basics</option>
                  <option value="active_storage_overview.html">Active Storage Overview</option>
                  <option value="action_cable_overview.html">Action Cable Overview</option>
              </optgroup>
              <optgroup label="Indo mais fundo">
                  <option value="i18n.html">Rails Internationalization (I18n) API</option>
                  <option value="testing.html">Testing Rails Applications</option>
                  <option value="security.html">Securing Rails Applications</option>
                  <option value="debugging_rails_applications.html">Debugging Rails Applications</option>
                  <option value="configuring.html">Configuring Rails Applications</option>
                  <option value="command_line.html">The Rails Command Line</option>
                  <option value="asset_pipeline.html">The Asset Pipeline</option>
                  <option value="working_with_javascript_in_rails.html">Working with JavaScript in Rails</option>
                  <option value="initialization.html">The Rails Initialization Process</option>
                  <option value="autoloading_and_reloading_constants.html">Autoloading and Reloading Constants (Zeitwerk Mode)</option>
                  <option value="autoloading_and_reloading_constants_classic_mode.html">Autoloading and Reloading Constants (Classic Mode)</option>
                  <option value="caching_with_rails.html">Caching with Rails: An Overview</option>
                  <option value="active_support_instrumentation.html">Active Support Instrumentation</option>
                  <option value="api_app.html">Using Rails for API-only Applications</option>
                  <option value="active_record_postgresql.html">Active Record and PostgreSQL</option>
                  <option value="active_record_multiple_databases.html">Multiple Databases with Active Record</option>
              </optgroup>
              <optgroup label="Estendendo o Rails">
                  <option value="plugins.html">The Basics of Creating Rails Plugins</option>
                  <option value="rails_on_rack.html">Rails on Rack</option>
                  <option value="generators.html">Creating and Customizing Rails Generators &amp; Templates</option>
                  <option value="engines.html">Getting Started with Engines</option>
                  <option value="threading_and_code_execution.html">Threading and Code Execution in Rails</option>
              </optgroup>
              <optgroup label="Contribuições">
                  <option value="contributing_to_ruby_on_rails.html">Contributing to Ruby on Rails</option>
                  <option value="api_documentation_guidelines.html">API Documentation Guidelines</option>
                  <option value="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</option>
              </optgroup>
              <optgroup label="Políticas">
                  <option value="maintenance_policy.html">Maintenance Policy for Ruby on Rails</option>
              </optgroup>
              <optgroup label="Release Notes">
                  <option value="upgrading_ruby_on_rails.html">Upgrading Ruby on Rails</option>
                  <option value="6_0_release_notes.html">6.0 Release Notes - Agosto 2019</option>
                  <option value="5_2_release_notes.html">Version 5.2 - April 2018</option>
                  <option value="5_1_release_notes.html">Version 5.1 - April 2017</option>
                  <option value="5_0_release_notes.html">Version 5.0 - June 2016</option>
                  <option value="4_2_release_notes.html">Version 4.2 - December 2014</option>
                  <option value="4_1_release_notes.html">Version 4.1 - April 2014</option>
                  <option value="4_0_release_notes.html">Version 4.0 - June 2013</option>
                  <option value="3_2_release_notes.html">Version 3.2 - January 2012</option>
                  <option value="3_1_release_notes.html">Version 3.1 - August 2011</option>
                  <option value="3_0_release_notes.html">Version 3.0 - August 2010</option>
                  <option value="2_3_release_notes.html">Version 2.3 - March 2009</option>
                  <option value="2_2_release_notes.html">Version 2.2 - November 2008</option>
              </optgroup>
          </select>
        </li>
      </ul>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      <h2>Interface de Consulta do <em>Active Record</em></h2><p>Este guia cobre diferentes maneiras de recuperar dados de um banco de dados utilizando o <em>Active Record</em></p><p>Após ler esse guia, você saberá:</p>
<ul>
<li>Como encontrar registros usando uma variedade de métodos e condições.</li>
<li>Como especificar a ordem, os atributos recuperados, agrupamento e outras propriedades dos registros encontrados.</li>
<li>Como usar o <em>eager loading</em> para reduzir o número de consultas necessárias no banco de dados para recuperar os dados.</li>
<li>Como utilizar métodos localizadores dinâmicos.</li>
<li>Como utilizar encadeamento de métodos para usar múltiplos métodos do <em>Active Record</em> em conjunto.</li>
<li>Como checar a existência de determinados registros.</li>
<li>Como executar diversos cálculos nos <em>models</em> do <em>Active Record</em>.</li>
<li>Como executar o <em>EXPLAIN</em> nas relações.</li>
</ul>


                <div id="subCol">
            <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
            <ol class="chapters">
<li>
<a href="#recuperando-objetos-do-banco-de-dados">Recuperando Objetos do Banco de Dados</a>

<ul>
<li><a href="#retornando-um-unico-objeto">Retornando um Único Objeto</a></li>
<li><a href="#retornando-multiplos-objetos-em-lotes">Retornando Múltiplos Objetos em Lotes</a></li>
</ul>
</li>
<li>
<a href="#condicoes">Condições</a>

<ul>
<li><a href="#condicoes-de-strings-puras">Condições de Strings Puras</a></li>
<li><a href="#condicoes-de-array">Condições de Array</a></li>
<li><a href="#condicoes-de-hash">Condições de Hash</a></li>
<li><a href="#condicoes-not">Condições NOT</a></li>
<li><a href="#condicoes-or">Condições OR</a></li>
</ul>
</li>
<li><a href="#ordenando">Ordenando</a></li>
<li><a href="#selecionando-campos-especificos">Selecionando Campos Específicos</a></li>
<li><a href="#limit-e-offset"><em>Limit</em> e <em>Offset</em></a></li>
<li>
<a href="#agrupando">Agrupando</a>

<ul>
<li><a href="#total-de-itens-agrupados">Total de itens agrupados</a></li>
</ul>
</li>
<li><a href="#having"><em>Having</em></a></li>
<li>
<a href="#condicoes-de-substituicao">Condições de Substituição</a>

<ul>
<li><a href="#unscope"><code>unscope</code></a></li>
<li><a href="#only"><code>only</code></a></li>
<li><a href="#reselect"><code>reselect</code></a></li>
<li><a href="#reorder"><code>reorder</code></a></li>
<li><a href="#reverse-order"><code>reverse_order</code></a></li>
<li><a href="#rewhere"><code>rewhere</code></a></li>
</ul>
</li>
<li><a href="#relacoes-nulas">Relações Nulas</a></li>
<li><a href="#objetos-readonly-somente-leitura">Objetos <em>Readonly</em> (Somente leitura)</a></li>
<li>
<a href="#bloqueando-registros-para-alteracao">Bloqueando registros para alteração</a>

<ul>
<li><a href="#bloqueio-otimista">Bloqueio Otimista</a></li>
<li><a href="#bloqueio-pessimista">Bloqueio pessimista</a></li>
</ul>
</li>
<li>
<a href="#associando-tabelas">Associando Tabelas</a>

<ul>
<li><a href="#joins"><code>joins</code></a></li>
<li><a href="#left-outer-joins"><code>left_outer_joins</code></a></li>
</ul>
</li>
<li>
<a href="#associations-com-eager-loading">Associations com <em>Eager Loading</em></a>

<ul>
<li><a href="#eager-loading-multiple-associations">Eager Loading Multiple Associations</a></li>
<li><a href="#especificando-condicoes-em-associacoes-eager-loaded">Especificando Condições em Associações <em>Eager Loaded</em></a></li>
</ul>
</li>
<li>
<a href="#scopes"><em>Scopes</em></a>

<ul>
<li><a href="#transmitindo-argumentos">Transmitindo argumentos</a></li>
<li><a href="#usando-condicionais">Usando condicionais</a></li>
<li><a href="#aplicando-um-escopo-padrao">Aplicando um escopo padrão</a></li>
<li><a href="#mesclagem-de-escopos">Mesclagem de escopos</a></li>
<li><a href="#removendo-todo-o-escopo">Removendo todo o escopo</a></li>
</ul>
</li>
<li><a href="#localizadores-dinamicos">Localizadores Dinâmicos</a></li>
<li><a href="#enums">Enums</a></li>
<li>
<a href="#entendendo-o-encadeamento-de-metodos">Entendendo o Encadeamento de Métodos</a>

<ul>
<li><a href="#buscando-dados-filtrados-de-multiplas-tabelas">Buscando dados filtrados de múltiplas tabelas</a></li>
<li><a href="#buscando-dados-especificos-de-multiplas-tabelas">Buscando dados específicos de múltiplas tabelas</a></li>
</ul>
</li>
<li>
<a href="#encontrando-ou-construindo-um-novo-objeto">Encontrando ou Construindo um Novo Objeto</a>

<ul>
<li><a href="#find-or-create-by"><code>find_or_create_by</code></a></li>
<li><a href="#find-or-create-by-bang"><code>find_or_create_by!</code></a></li>
<li><a href="#find-or-initialize-by"><code>find_or_initialize_by</code></a></li>
</ul>
</li>
<li>
<a href="#finding-by-sql">Finding by SQL</a>

<ul>
<li><a href="#select-all"><code>select_all</code></a></li>
<li><a href="#pluck"><code>pluck</code></a></li>
<li><a href="#ids"><code>ids</code></a></li>
</ul>
</li>
<li><a href="#existencia-de-objetos">Existência de Objetos</a></li>
<li>
<a href="#calculos">Cálculos</a>

<ul>
<li><a href="#contar-count">Contar (<em>count</em>)</a></li>
<li><a href="#media-average">Média (<em>average</em>)</a></li>
<li><a href="#minimo-minimum">Mínimo (<em>minimum</em>)</a></li>
<li><a href="#maximo-maximum">Máximo (<em>maximum</em>)</a></li>
<li><a href="#soma-sum">Soma (<em>sum</em>)</a></li>
</ul>
</li>
<li>
<a href="#executando-o-explain">Executando o EXPLAIN</a>

<ul>
<li><a href="#interpretando-o-explain">Interpretando o EXPLAIN</a></li>
</ul>
</li>
</ol>

          </div>

    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <p>Se você está acostumado com SQL puro para encontrar registros no banco de dados, então você provavelmente encontrará
maneiras melhores de realizar as mesmas operações no Rails. O <em>Active Record</em> te isola da necessidade de usar o SQL
na maioria dos casos.</p><p>Os exemplos de código ao longo desse guia irão se referir à um ou mais dos seguintes modelos:</p><div class="info"><p>Todos os <em>models</em> seguintes utilizam <code>id</code> como <em>primary key</em> (chave primária), a não ser quando especificado o
contrário.</p></div><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Client</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_one</span> <span class="ss">:address</span>
  <span class="n">has_many</span> <span class="ss">:orders</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:roles</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-9f106526758564bf55cd4becf35e9570">class Client &lt; ApplicationRecord
  has_one :address
  has_many :orders
  has_and_belongs_to_many :roles
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-9f106526758564bf55cd4becf35e9570">Copiar</button>
</div>
<div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Address</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:client</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-230c090ab41ca6830629cf39ae36ee4b">class Address &lt; ApplicationRecord
  belongs_to :client
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-230c090ab41ca6830629cf39ae36ee4b">Copiar</button>
</div>
<div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Order</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:client</span><span class="p">,</span> <span class="ss">counter_cache: </span><span class="kp">true</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-8be21e858bf85f3638c82a93ffa1d364">class Order &lt; ApplicationRecord
  belongs_to :client, counter_cache: true
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-8be21e858bf85f3638c82a93ffa1d364">Copiar</button>
</div>
<div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Role</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:clients</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-4f4f7cc30eaaba6ea69c7cb1d03d8617">class Role &lt; ApplicationRecord
  has_and_belongs_to_many :clients
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-4f4f7cc30eaaba6ea69c7cb1d03d8617">Copiar</button>
</div>
<p>O <em>Active Record</em> irá executar consultas no banco de dados para você e é compatível com a maioria dos sistemas de banco de dados,
incluindo MySQL, MariaDB, PostgreSQL e SQLite. Independente de qual sistema de banco de dados você utilize, o formato do método do <em>Active Record</em>
será sempre o mesmo.</p><h3 id="recuperando-objetos-do-banco-de-dados"><a class="anchorlink" href="#recuperando-objetos-do-banco-de-dados">1 Recuperando Objetos do Banco de Dados</a></h3><p>Para recuperar objetos do banco de dados, o <em>Active Record</em> fornece diversos métodos de localização. Cada método de localização permite que você
passe argumentos para o mesmo para executar determinada consulta no seu banco de dados sem a necessidade de escrever SQL puro.</p><p>Os métodos são:</p>
<ul>
<li><code>annotate</code></li>
<li><code>find</code></li>
<li><code>create_with</code></li>
<li><code>distinct</code></li>
<li><code>eager_load</code></li>
<li><code>extending</code></li>
<li><code>extract_associated</code></li>
<li><code>from</code></li>
<li><code>group</code></li>
<li><code>having</code></li>
<li><code>includes</code></li>
<li><code>joins</code></li>
<li><code>left_outer_joins</code></li>
<li><code>limit</code></li>
<li><code>lock</code></li>
<li><code>none</code></li>
<li><code>offset</code></li>
<li><code>optimizer_hints</code></li>
<li><code>order</code></li>
<li><code>preload</code></li>
<li><code>readonly</code></li>
<li><code>references</code></li>
<li><code>reorder</code></li>
<li><code>reselect</code></li>
<li><code>reverse_order</code></li>
<li><code>select</code></li>
<li><code>where</code></li>
</ul>
<p>Métodos de localização que retornam uma coleção, como o <code>where</code> e <code>group</code>, retornam uma instância do <code>ActiveRecord::Relation</code>.
Os métodos que localizam uma única entidade, como o <code>find</code> e o <code>first</code>, retornam uma única instância do <em>model</em>.</p><p>A principal operação do <code>Model.find(options)</code> pode ser resumida como:</p>
<ul>
<li>Converter as opções fornecidas em uma consulta equivalente no SQL.</li>
<li>Disparar uma consulta SQL e recuperar os resultados correspondentes no banco de dados.</li>
<li>Instanciar o objeto Ruby equivalente do <em>model</em> apropriado para cada linha resultante.</li>
<li>Executar <code>after_find</code> e, em seguida, retornos de chamada com <code>after_initialize</code>, se houver.</li>
</ul>
<h4 id="retornando-um-unico-objeto"><a class="anchorlink" href="#retornando-um-unico-objeto">1.1 Retornando um Único Objeto</a></h4><p>O <em>Active Record</em> possui diferentes formas de retornar um único objeto.</p><h5 id="find"><a class="anchorlink" href="#find">1.1.1 <code>find</code></a></h5><p>Utilizando o método <code>find</code>, você pode retornar o objeto correspondente à <em>primary key</em> especificada que corresponde às opções fornecidas.
Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># Encontra o cliente com a primary key (id) 10.</span>
<span class="n">client</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="c1"># =&gt; #&lt;Client id: 10, first_name: "Ryan"&gt;</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-287640ef27833c758e2b81a0a72e96cc"># Encontra o cliente com a primary key (id) 10.
client = Client.find(10)
# =&gt; #&lt;Client id: 10, first_name: "Ryan"&gt;
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-287640ef27833c758e2b81a0a72e96cc">Copiar</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">clients</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-3857753f0c3372cc9eacdf0588ee8e28">SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-3857753f0c3372cc9eacdf0588ee8e28">Copiar</button>
</div>
<p>O método <code>find</code> irá gerar uma exceção <code>ActiveRecord::RecordNotFound</code> se nenhum registro correspondente for encontrado.</p><p>Você pode, também, utilizar este método para consultar múltiplos objetos. Chame o método <code>find</code> e passe um array de <em>primary keys</em>.
Será retornado um array contendo todos os registros correspondentes para as <em>primary keys</em> fornecidas. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># Encontra os clientes com as primary keys 1 e 10.</span>
<span class="n">clients</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">find</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span> <span class="c1"># Or even Client.find(1, 10)</span>
<span class="c1"># =&gt; [#&lt;Client id: 1, first_name: "Lifo"&gt;, #&lt;Client id: 10, first_name: "Ryan"&gt;]</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-af03afe572c0c426e45faf71831869d8"># Encontra os clientes com as primary keys 1 e 10.
clients = Client.find([1, 10]) # Or even Client.find(1, 10)
# =&gt; [#&lt;Client id: 1, first_name: "Lifo"&gt;, #&lt;Client id: 10, first_name: "Ryan"&gt;]
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-af03afe572c0c426e45faf71831869d8">Copiar</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">clients</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-eab6291642cd7262a3f8a1bc45072a37">SELECT * FROM clients WHERE (clients.id IN (1,10))
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-eab6291642cd7262a3f8a1bc45072a37">Copiar</button>
</div>
<div class="warning"><p>O método <code>find</code> irá gerar uma excecão <code>ActiveRecord::RecordNotFound</code> a não ser que um registro correspondente seja encontrado para <strong>todas</strong> as primary keys fornecidas.</p></div><h5 id="take"><a class="anchorlink" href="#take">1.1.2 <code>take</code></a></h5><p>O método <code>take</code> retorna um registro sem nenhuma ordem implícita. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">client</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">take</span>
<span class="c1"># =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-91758db90d6ffce7a4e3816eaab6a73d">client = Client.take
# =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-91758db90d6ffce7a4e3816eaab6a73d">Copiar</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-222d0897666222f355530d55cf27ab4b">SELECT * FROM clients LIMIT 1
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-222d0897666222f355530d55cf27ab4b">Copiar</button>
</div>
<p>O método <code>take</code> retorna <code>nil</code> se nenhum registro for encontrado e nenhuma exceção será levantada.</p><p>Você pode passar um argumento numérico para o método <code>take</code> para retornar o mesmo número em resultados. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">clients</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">take</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#   #&lt;Client id: 1, first_name: "Lifo"&gt;,</span>
<span class="c1">#   #&lt;Client id: 220, first_name: "Sara"&gt;</span>
<span class="c1"># ]</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-9ced56ff9dce099296b1a0c82fba36be">clients = Client.take(2)
# =&gt; [
#   #&lt;Client id: 1, first_name: "Lifo"&gt;,
#   #&lt;Client id: 220, first_name: "Sara"&gt;
# ]
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-9ced56ff9dce099296b1a0c82fba36be">Copiar</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">LIMIT</span> <span class="mi">2</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-c05e48376bb217cdc3b571758e6224b0">SELECT * FROM clients LIMIT 2
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-c05e48376bb217cdc3b571758e6224b0">Copiar</button>
</div>
<p>O método <code>take!</code> se comporta exatamente como o <code>take</code>, exceto que irá gerar uma exceção <code>ActiveRecord::RecordNotFound</code> caso não encontre nenhum registro correspondente.</p><div class="info"><p>O registro retornado pode variar dependendo do mecanismo do banco de dados.</p></div><h5 id="first"><a class="anchorlink" href="#first">1.1.3 <code>first</code></a></h5><p>O método <code>first</code> encontra o primeiro registro ordenado pela <em>primary key</em> (padrão). Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">client</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">first</span>
<span class="c1"># =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-7c900a0826eb5db99d8900260b541739">client = Client.first
# =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-7c900a0826eb5db99d8900260b541739">Copiar</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">clients</span><span class="p">.</span><span class="n">id</span> <span class="k">ASC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-d5c05dc3975aa0f6c14e0a752aa7db1e">SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-d5c05dc3975aa0f6c14e0a752aa7db1e">Copiar</button>
</div>
<p>O método <code>first</code> retorna <code>nil</code> se não for encontrado nenhum registro correspondente e nenhuma exceção é gerada.</p><p>Se o seu <a href="active_record_querying.html#applying-a-default-scope">default scope</a> contém um método de ordenação, <code>first</code> irá retornar o primeiro
registro de acordo com essa ordenação.</p><p>Você pode passar um argumento número para o métoddo <code>first</code> para retornar o mesmo número em resultados. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">clients</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">first</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#   #&lt;Client id: 1, first_name: "Lifo"&gt;,</span>
<span class="c1">#   #&lt;Client id: 2, first_name: "Fifo"&gt;,</span>
<span class="c1">#   #&lt;Client id: 3, first_name: "Filo"&gt;</span>
<span class="c1"># ]</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-c3b47733a1915393b9c1a392babcd60f">clients = Client.first(3)
# =&gt; [
#   #&lt;Client id: 1, first_name: "Lifo"&gt;,
#   #&lt;Client id: 2, first_name: "Fifo"&gt;,
#   #&lt;Client id: 3, first_name: "Filo"&gt;
# ]
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-c3b47733a1915393b9c1a392babcd60f">Copiar</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">clients</span><span class="p">.</span><span class="n">id</span> <span class="k">ASC</span> <span class="k">LIMIT</span> <span class="mi">3</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-ab33b01bb96c3dda727cfc3b9887408b">SELECT * FROM clients ORDER BY clients.id ASC LIMIT 3
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-ab33b01bb96c3dda727cfc3b9887408b">Copiar</button>
</div>
<p>Em uma coleção ordenada utilizando o <code>order</code>, <code>first</code> irá retornar o primeiro registro que foi ordenado com o atributo especificado em <code>order</code>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">client</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">).</span><span class="nf">first</span>
<span class="c1"># =&gt; #&lt;Client id: 2, first_name: "Fifo"&gt;</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-1e4d29b768a625a02f9118b3d25cce10">client = Client.order(:first_name).first
# =&gt; #&lt;Client id: 2, first_name: "Fifo"&gt;
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-1e4d29b768a625a02f9118b3d25cce10">Copiar</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">clients</span><span class="p">.</span><span class="n">first_name</span> <span class="k">ASC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-3d156a20351571bfb6ea3cb31a8550ad">SELECT * FROM clients ORDER BY clients.first_name ASC LIMIT 1
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-3d156a20351571bfb6ea3cb31a8550ad">Copiar</button>
</div>
<p>O método <code>first!</code> se comporta exatamente como o <code>first</code>, exceto que irá gerar uma exceção <code>ActiveRecord::RecordNotFound</code> se nenhum registro
correspondente for encontrado.</p><h5 id="last"><a class="anchorlink" href="#last">1.1.4 <code>last</code></a></h5><p>O método <code>last</code> encontra o último registro ordenado pela <em>primary key</em> (padrão). Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">client</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">last</span>
<span class="c1"># =&gt; #&lt;Client id: 221, first_name: "Russel"&gt;</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-e3ae4d458994520358f7dde7aa09e437">client = Client.last
# =&gt; #&lt;Client id: 221, first_name: "Russel"&gt;
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-e3ae4d458994520358f7dde7aa09e437">Copiar</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">clients</span><span class="p">.</span><span class="n">id</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-7fa543d7211f172c06c98ba44456aa38">SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-7fa543d7211f172c06c98ba44456aa38">Copiar</button>
</div>
<p>O método <code>last</code> retorna <code>nil</code> se não encontrar nenhum registro correspondente e nenhuma exceção será levantada.</p><p>Se o seu <a href="active_record_querying.html#applying-a-default-scope">default scope</a> contém um método de ordenação, <code>last</code> irá retornar
o último registro de acordo com essa ordenação.</p><p>Você pode passar um argumento número para o método <code>last</code> para retornar o mesmo número em resultados. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">clients</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">last</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#   #&lt;Client id: 219, first_name: "James"&gt;,</span>
<span class="c1">#   #&lt;Client id: 220, first_name: "Sara"&gt;,</span>
<span class="c1">#   #&lt;Client id: 221, first_name: "Russel"&gt;</span>
<span class="c1"># ]</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-df86b20166417702e40f1578756255d5">clients = Client.last(3)
# =&gt; [
#   #&lt;Client id: 219, first_name: "James"&gt;,
#   #&lt;Client id: 220, first_name: "Sara"&gt;,
#   #&lt;Client id: 221, first_name: "Russel"&gt;
# ]
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-df86b20166417702e40f1578756255d5">Copiar</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">clients</span><span class="p">.</span><span class="n">id</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">3</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-ca61d4fb0318ab283a2ab869a575af44">SELECT * FROM clients ORDER BY clients.id DESC LIMIT 3
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-ca61d4fb0318ab283a2ab869a575af44">Copiar</button>
</div>
<p>Em uma coleção ordenada utilizando o <code>order</code>, <code>last</code> irá retornar o último registro que foi ordenado com o atributo especificado em <code>order</code>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">client</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">).</span><span class="nf">last</span>
<span class="c1"># =&gt; #&lt;Client id: 220, first_name: "Sara"&gt;</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-83c5a7302486070a8a241f7ac8d9072c">client = Client.order(:first_name).last
# =&gt; #&lt;Client id: 220, first_name: "Sara"&gt;
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-83c5a7302486070a8a241f7ac8d9072c">Copiar</button>
</div>
<p>O equivalente ao de cima, em SQL, seria:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">clients</span><span class="p">.</span><span class="n">first_name</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-76f249ac4dcd7302f2926f369db854eb">SELECT * FROM clients ORDER BY clients.first_name DESC LIMIT 1
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-76f249ac4dcd7302f2926f369db854eb">Copiar</button>
</div>
<p>O método <code>last!</code> se comporta exatamente como o <code>last</code>, exceto que irá gerar uma exceção <code>ActiveRecord::RecordNotFound</code> se nenhum registro
correspondente for encontrado.</p><h5 id="find-by"><a class="anchorlink" href="#find-by">1.1.5 <code>find_by</code></a></h5><p>O método <code>find_by</code> irá retornar o primeiro registro que corresponde às condições. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">find_by</span> <span class="ss">first_name: </span><span class="s1">'Lifo'</span>
<span class="c1"># =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;</span>

<span class="no">Client</span><span class="p">.</span><span class="nf">find_by</span> <span class="ss">first_name: </span><span class="s1">'Jon'</span>
<span class="c1"># =&gt; nil</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-c813f1853476c8d641424d19b2fc4d33">Client.find_by first_name: 'Lifo'
# =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;

Client.find_by first_name: 'Jon'
# =&gt; nil
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-c813f1853476c8d641424d19b2fc4d33">Copiar</button>
</div>
<p>É equivalente à escrever:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Lifo'</span><span class="p">).</span><span class="nf">take</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-e50b8304a76e402623a2c2ae2904e807">Client.where(first_name: 'Lifo').take
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-e50b8304a76e402623a2c2ae2904e807">Copiar</button>
</div>
<p>O equivalente ao de cima, em SQL, seria</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">clients</span><span class="p">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Lifo'</span><span class="p">)</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-3d62cb5cb032518526785d2cdaffda86">SELECT * FROM clients WHERE (clients.first_name = 'Lifo') LIMIT 1
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-3d62cb5cb032518526785d2cdaffda86">Copiar</button>
</div>
<p>O método <code>find_by</code> se comporta exatamente como o <code>find_by</code>, exceto que irá gerar uma exceção <code>ActiveRecord::RecordNotFound</code> se nenhum registro
correspondente for encontrado. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">find_by!</span> <span class="ss">first_name: </span><span class="s1">'does not exist'</span>
<span class="c1"># =&gt; ActiveRecord::RecordNotFound</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-5eeb048e4ad079dadc8273195c80d03c">Client.find_by! first_name: 'does not exist'
# =&gt; ActiveRecord::RecordNotFound
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-5eeb048e4ad079dadc8273195c80d03c">Copiar</button>
</div>
<p>Isto é equivalente à escrever:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'does not exist'</span><span class="p">).</span><span class="nf">take!</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-b62db94c9ea242c335552635d87ca22d">Client.where(first_name: 'does not exist').take!
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-b62db94c9ea242c335552635d87ca22d">Copiar</button>
</div>
<h4 id="retornando-multiplos-objetos-em-lotes"><a class="anchorlink" href="#retornando-multiplos-objetos-em-lotes">1.2 Retornando Múltiplos Objetos em Lotes</a></h4><p>Nós frequentemente precisamos iterar sobre um grande número de registros, seja quando precisamos enviar <em>newsletter</em> para
um grande número de usuários, ou quando vamos exportar dados.</p><p>Isso pode parecer simples:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># Isso pode consumir muita memória se a tabela for grande.</span>
<span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">user</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-348032d766fbaa0f2d024a1bd0387a5c"># Isso pode consumir muita memória se a tabela for grande.
User.all.each do |user|
  NewsMailer.weekly(user).deliver_now
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-348032d766fbaa0f2d024a1bd0387a5c">Copiar</button>
</div>
<p>Mas essa abordagem se torna cada vez mais impraticável à medida que o tamanho da tabela aumenta, pois o <code>User.all.each</code>
instrui o <em>Active Record</em> à buscar a <strong>tabela inteira</strong> em uma única passagem, cria um <em>model</em> de objeto por linha e
mantém todo o array de objetos de <em>model</em> na memória. De fato, se você tem um grande número de registros, a coleção inteira
pode exceder a quantidade de memória disponível.</p><p>O Rails fornece dois métodos para solucionar esse problema, dividindo os registros em lotes <em>memory-friendly</em> para o processamento.
O primeiro método, <code>find_each</code>, retorna um lote de registros e depois submete <em>cada</em> registro individualmente para um bloco como um <em>model</em>.
O segundo método, <code>find_in_batches</code>, retorna um lote de registros e depois submete <em>o lote inteiro</em> ao bloco como um array de <em>models</em>.</p><div class="info"><p>Os métodos <code>find_each</code> e <code>find_in_batches</code> são destinados ao uso no processamento em lotes de grandes numéros de registros
que não irão caber na memória de uma só vez. Se você apenas precisa fazer um  <em>loop</em> em milhares de registros, os métodos
regulares do <code>find</code> são a opção preferida.</p></div><h5 id="find-each"><a class="anchorlink" href="#find-each">1.2.1 <code>find_each</code></a></h5><p>O método <code>find_each</code> retorna os registros em lotes e depois aloca <em>cada</em> um no bloco. No exemplo a seguir, <code>find_each</code> retorna
<em>users</em> em lotes de 1000 e os aloca no bloco um à um:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">User</span><span class="p">.</span><span class="nf">find_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">user</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-e5edf9c6a9f465286a467b6054fb90e5">User.find_each do |user|
  NewsMailer.weekly(user).deliver_now
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-e5edf9c6a9f465286a467b6054fb90e5">Copiar</button>
</div>
<p>Esse processo é repetido, buscando mais lotes sempre que preciso, até que todos os registros tenham sido processados.</p><p><code>find_each</code> funciona com classes de <em>model</em>, como visto acima, assim como relações:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">weekly_subscriber: </span><span class="kp">true</span><span class="p">).</span><span class="nf">find_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">user</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-65b3d540a8c2fce02c36ff94df9e344b">User.where(weekly_subscriber: true).find_each do |user|
  NewsMailer.weekly(user).deliver_now
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-65b3d540a8c2fce02c36ff94df9e344b">Copiar</button>
</div>
<p>contanto que ele não tenha nenhuma ordenação, pois o método necessita forçar uma ordem interna para iterar.</p><p>Se houver uma ordem presente no receptor, o comportamento depende da <em>flag</em> <code>config.active_record.error_on_ignored_order</code>.
Se verdadeiro, <code>ArgumentError</code> é levantado, caso contrário a ordem será ignorada e um aviso gerado, que é o padrão. Isto pode
ser substituído com a opção <code>:error_on_ignore</code>, explicado abaixo.</p><h6 id="options-for-find-each"><a class="anchorlink" href="#options-for-find-each">1.2.1.1 Options for <code>find_each</code></a></h6><h6 id="opcoes-para-find-each"><a class="anchorlink" href="#opcoes-para-find-each">1.2.1.2 Opções para <code>find_each</code></a></h6><p><strong><code>:batch_size</code></strong></p><p>A opção <code>:batch_size</code> permite que você especifique o número de registros à serem retornados em cada lote, antes de serem passados, individualmente, para o bloco.
Por exemplo, para retornar registros de um lote de 5000:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">User</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">batch_size: </span><span class="mi">5000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">user</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-3b2ec3b9c732ed224d320d3239aefc65">User.find_each(batch_size: 5000) do |user|
  NewsMailer.weekly(user).deliver_now
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-3b2ec3b9c732ed224d320d3239aefc65">Copiar</button>
</div>
<p><strong><code>:start</code></strong></p><p>Por padrão, os registros são buscados em ordem ascendente de <em>primary key</em>. A opção <code>:start</code> permite que você configure o primeiro ID da sequência sempre que o menor
ID não seja o que você precisa. Isto pode ser útil, por exemplo, se você quer retomar um processo interrompido de lotes, desde que você
tenha salvo o último ID processado como ponto de retorno.</p><p>Por exemplo, para enviar <em>newsletters</em> apenas para os usuários com a <em>primary key</em> começando com 2000:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">User</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">start: </span><span class="mi">2000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">user</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-9e2696d51462cba24836aef44986d5d9">User.find_each(start: 2000) do |user|
  NewsMailer.weekly(user).deliver_now
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-9e2696d51462cba24836aef44986d5d9">Copiar</button>
</div>
<p><strong><code>:finish</code></strong></p><p>Similar à opção <code>:start</code>, <code>:finish</code> permite que você configure o último ID da sequência sempre que o maior ID não seja o que você necessite.
Isso pode ser útil, por exemplo, se você quer executar um processo de lotes utilizando subconjuntos de registros baseados no <code>:start</code> e <code>:finish</code></p><p>Por exemplo, para enviar <em>newsletters</em> apenas para os usuários com a <em>primary key</em> começando em 2000 e indo até 10000:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">User</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">start: </span><span class="mi">2000</span><span class="p">,</span> <span class="ss">finish: </span><span class="mi">10000</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
  <span class="no">NewsMailer</span><span class="p">.</span><span class="nf">weekly</span><span class="p">(</span><span class="n">user</span><span class="p">).</span><span class="nf">deliver_now</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-011797108b2ee70fea76bb55acd43cc1">User.find_each(start: 2000, finish: 10000) do |user|
  NewsMailer.weekly(user).deliver_now
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-011797108b2ee70fea76bb55acd43cc1">Copiar</button>
</div>
<p>Outro exemplo seria se você queira múltiplos <em>workers</em> manipulando a mesma fila de processamento. Você pode ter cada <em>worker</em>
lidando com 10000 registros atribuindo a opção <code>:start</code> e <code>finish</code> apropriadas para cada <em>worker</em></p><p><strong><code>:error_on_ignore</code></strong></p><p>Sobrescreve as configurações da aplicação para especificar se um erro deve ser levantado quando a ordem está presente
na relação.</p><h5 id="find-in-batches"><a class="anchorlink" href="#find-in-batches">1.2.2 <code>find_in_batches</code></a></h5><p>O método <code>find_in_batches</code> é similar ao <code>find_each</code>, pois ambos retornam lotes de registros. A diferença é que o <code>find_in_batches</code> fornece <em>lotes</em> ao bloco como um array de <em>models</em>,
em vez de individualmente. O exemplo à seguir irá produzir ao bloco fornecido um array com até 1000 notas fiscais de uma vez,
com o bloco final contendo qualquer nota fiscal remanescente:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># Fornece à add_invoices um array com 1000 notas fiscais de uma vez.</span>
<span class="no">Invoice</span><span class="p">.</span><span class="nf">find_in_batches</span> <span class="k">do</span> <span class="o">|</span><span class="n">invoices</span><span class="o">|</span>
  <span class="n">export</span><span class="p">.</span><span class="nf">add_invoices</span><span class="p">(</span><span class="n">invoices</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-53e87381d14514e57f8665d4261bfdc0"># Fornece à add_invoices um array com 1000 notas fiscais de uma vez.
Invoice.find_in_batches do |invoices|
  export.add_invoices(invoices)
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-53e87381d14514e57f8665d4261bfdc0">Copiar</button>
</div>
<p><code>find_in_batches</code> funcional com classes de <em>model</em>, como visto acima, e também com relações:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Invoice</span><span class="p">.</span><span class="nf">pending</span><span class="p">.</span><span class="nf">find_in_batches</span> <span class="k">do</span> <span class="o">|</span><span class="n">invoices</span><span class="o">|</span>
  <span class="n">pending_invoices_export</span><span class="p">.</span><span class="nf">add_invoices</span><span class="p">(</span><span class="n">invoices</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-4685b02f414fa8b985ce099bfa0bf573">Invoice.pending.find_in_batches do |invoices|
  pending_invoices_export.add_invoices(invoices)
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-4685b02f414fa8b985ce099bfa0bf573">Copiar</button>
</div>
<p>contanto que não há ordenação, pois o método irá forçar uma ordem interna para a iteração.</p><h6 id="opcoes-parafind-in-batches"><a class="anchorlink" href="#opcoes-parafind-in-batches">1.2.2.1 Opções para<code>find_in_batches</code></a></h6><p>O método <code>find_in_batches</code> aceita as mesmas opção que o <code>find_each</code></p><h3 id="condicoes"><a class="anchorlink" href="#condicoes">2 Condições</a></h3><p>O método <code>where</code>  permite que você especifique condições para limitar os registros retornados, representando a parte <code>where</code> da instrução SQL. Condições podem ser especificadas como uma <em>string</em>, <em>array</em>, ou <em>hash</em>.</p><h4 id="condicoes-de-strings-puras"><a class="anchorlink" href="#condicoes-de-strings-puras">2.1 Condições de Strings Puras</a></h4><p>Se você gostaria de adicionar condições para sua busca, poderia apenas especificá-las, como, por exemplo <code>Client.where("orders_count = '2'")</code>. Isso encontrará todos os clientes em que o campo <code>ordes_count</code> tenha o valor igual a 2.</p><div class="warning"><p>Construindo sua própria condições como <em>strings</em> pura pode te deixar vulnerável a ataques de injeção SQL. Por exemplo, <code>Client.where("first_name LIKE '%#{params[:first_name]}%'")</code> não é seguro. Veja a próxima seção para saber a maneira preferida de lidar com  condições usando array.</p></div><h4 id="condicoes-de-array"><a class="anchorlink" href="#condicoes-de-array">2.2 Condições de Array</a></h4><p>Agora, se esse número pudesse variar, digamos como um argumento de algum lugar? O comando da busca então levaria a forma:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"orders_count = ?"</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:orders</span><span class="p">])</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-71d76464b8a5ed01e551068300cd9460">Client.where("orders_count = ?", params[:orders])
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-71d76464b8a5ed01e551068300cd9460">Copiar</button>
</div>
<p><em>Active Record</em> tomará o primeiro argumento como a string de condições e quaisquer argumentos adicionais vão substituir os pontos de interrogação <code>(?)</code> nele.</p><p>Se você quer especificar múltiplas condições:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"orders_count = ? AND locked = ?"</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:orders</span><span class="p">],</span> <span class="kp">false</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-d9f28fdffa768cb0f2b0929e357555fb">Client.where("orders_count = ? AND locked = ?", params[:orders], false)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-d9f28fdffa768cb0f2b0929e357555fb">Copiar</button>
</div>
<p>Neste exemplo, o primeiro ponto de interrogação será substituído com o valor em <code>params[:orders]</code> e o segundo será substituído com a representação SQL para <code>false</code>, que depende do adaptador.</p><p>Este código é altamente preferível:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"orders_count = ?"</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:orders</span><span class="p">])</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-06d615276b5a6d6c776b2c5940df18ef">Client.where("orders_count = ?", params[:orders])
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-06d615276b5a6d6c776b2c5940df18ef">Copiar</button>
</div>
<p>Para este código:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"orders_count = </span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="ss">:orders</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-680e4dc4b18801941863a446f1315127">Client.where("orders_count = #{params[:orders]}")
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-680e4dc4b18801941863a446f1315127">Copiar</button>
</div>
<p>Devido à segurança do argumento. Colocando a variável dentro da condição de <em>string</em>, passará a variável para o banco de dados <strong>como se encontra</strong>. Isto significa que será uma variável sem escape diretamente de um usuário que pode ter intenções maliciosas. Se você fizer isso, coloca todo seu banco de dados em risco, porque uma vez que um usuário descobre que pode explorar seu banco de dados, ele pode fazer qualquer coisa com ele. Nunca, jamais, coloque seus argumentos diretamente dentro da condição de <em>string</em>.</p><div class="info"><p>Para mais informações sobre os perigos da injeção de SQL, veja em <a href="https://guides.rubyonrails.org/security.html#sql-injection">Ruby on Rails Security Guide</a> / <a href="security.html#sql-injection">Ruby on Rails Security Guide PT-Br</a></p></div><h5 id="condicoes-com-placeholder"><a class="anchorlink" href="#condicoes-com-placeholder">2.2.1 Condições com <em>Placeholder</em></a></h5><p>Similar ao estilo de substituição <code>(?)</code> dos parâmetros, você também pode especificar chaves em sua condição de <em>string</em> junto com uma <em>hash</em> de chaves/valores (<em>keys/values</em>) correspondentes:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"created_at &gt;= :start_date AND created_at &lt;= :end_date"</span><span class="p">,</span>
  <span class="p">{</span><span class="ss">start_date: </span><span class="n">params</span><span class="p">[</span><span class="ss">:start_date</span><span class="p">],</span> <span class="ss">end_date: </span><span class="n">params</span><span class="p">[</span><span class="ss">:end_date</span><span class="p">]})</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-5929af33d029f8ae2540cf27bd21d74e">Client.where("created_at &gt;= :start_date AND created_at &lt;= :end_date",
  {start_date: params[:start_date], end_date: params[:end_date]})
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-5929af33d029f8ae2540cf27bd21d74e">Copiar</button>
</div>
<p>Isso torna a legibilidade mais clara se você tem um grande número de condições variáveis.</p><h4 id="condicoes-de-hash"><a class="anchorlink" href="#condicoes-de-hash">2.3 Condições de Hash</a></h4><p><em>Active Record</em> também permite que você passe em condições de <em>hash</em> o que pode aumentar a legibilidade de suas sintaxes de condições. Com condições de <em>hash</em>, você passa em uma <em>hash</em> com chaves (<em>keys</em>) dos campos que deseja qualificados e os valores (<em>values</em>) de como deseja qualificá-los:</p><div class="note"><p>Apenas igualdade, intervalo, e subconjunto são possíveis com as condições de <em>hash</em>.</p></div><h5 id="condicoes-de-igualdade"><a class="anchorlink" href="#condicoes-de-igualdade">2.3.1 Condições de igualdade</a></h5><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">locked: </span><span class="kp">true</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-4f37e0549fca4192e83655ea3558678e">Client.where(locked: true)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-4f37e0549fca4192e83655ea3558678e">Copiar</button>
</div>
<p>Isso irá gerar um SQL como este:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">clients</span><span class="p">.</span><span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-7259c7e9f585689c28e6f5e389217f48">SELECT * FROM clients WHERE (clients.locked = 1)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-7259c7e9f585689c28e6f5e389217f48">Copiar</button>
</div>
<p>O nome do campo também pode ser uma <em>string</em>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'locked'</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-458eb5ef40125e4175df34e5c2863953">Client.where('locked' =&gt; true)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-458eb5ef40125e4175df34e5c2863953">Copiar</button>
</div>
<p>No caso de um relacionamento <code>belongs_to</code>, uma chave de associação pode ser usada para especificar o model se um objeto <em>Active Record</em> for usado como o valor. Este método também funciona com relacionamentos polimórficos.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Article</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">author: </span><span class="n">author</span><span class="p">)</span>
<span class="no">Author</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:articles</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">articles: </span><span class="p">{</span> <span class="ss">author: </span><span class="n">author</span> <span class="p">})</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-e153f7065f2d4b249e5d7809689a151e">Article.where(author: author)
Author.joins(:articles).where(articles: { author: author })
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-e153f7065f2d4b249e5d7809689a151e">Copiar</button>
</div>
<h5 id="condicoes-de-intervalos"><a class="anchorlink" href="#condicoes-de-intervalos">2.3.2 Condições de intervalos</a></h5><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">created_at: </span><span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-9329dab533557b6a96b5b9405bb9b457">Client.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-9329dab533557b6a96b5b9405bb9b457">Copiar</button>
</div>
<p>Isso irá encontrar todos clientes criados ontem usando uma instrução SQL <code>BETWEEN</code>:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">clients</span><span class="p">.</span><span class="n">created_at</span> <span class="k">BETWEEN</span> <span class="s1">'2008-12-21 00:00:00'</span> <span class="k">AND</span> <span class="s1">'2008-12-22 00:00:00'</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-1983ab3f8e0bb71045d9ff9a909e7b4c">SELECT * FROM clients WHERE (clients.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-1983ab3f8e0bb71045d9ff9a909e7b4c">Copiar</button>
</div>
<p>Isso demonstra uma sintaxe mais curta para exemplos em <a href="#condicoes-de-array">Condições de Array</a></p><h5 id="subconjunto-de-condicoes"><a class="anchorlink" href="#subconjunto-de-condicoes">2.3.3 Subconjunto de Condições</a></h5><p>Se você deseja procurar registros usando a expressão <code>IN</code> pode passar um <em>array</em> para a <em>hash</em> de condições:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">orders_count: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-8dc630277c6738fcc056aced466bc0db">Client.where(orders_count: [1,3,5])
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-8dc630277c6738fcc056aced466bc0db">Copiar</button>
</div>
<p>Esse código irá gerar um SQL como este:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">clients</span><span class="p">.</span><span class="n">orders_count</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-02fd1694c96a96aef1c9ffbf6bc5ee6c">SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-02fd1694c96a96aef1c9ffbf6bc5ee6c">Copiar</button>
</div>
<h4 id="condicoes-not"><a class="anchorlink" href="#condicoes-not">2.4 Condições NOT</a></h4><p>Consultas SQL <code>NOT</code> podem ser construídas por <code>where.not</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">.</span><span class="nf">not</span><span class="p">(</span><span class="ss">locked: </span><span class="kp">true</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-f2ff539c3f6297b1fc45489190752733">Client.where.not(locked: true)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-f2ff539c3f6297b1fc45489190752733">Copiar</button>
</div>
<p>Em outras palavras, essa consulta pode ser gerada chamando <code>where</code> sem nenhum argumento, então imediatamente encadeie com condições <code>not</code> passando <code>where</code>. Isso irá gerar SQL como este:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">clients</span><span class="p">.</span><span class="n">locked</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-ead35bbb7b61f14cf51ec80dfc00364c">SELECT * FROM clients WHERE (clients.locked != 1)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-ead35bbb7b61f14cf51ec80dfc00364c">Copiar</button>
</div>
<h4 id="condicoes-or"><a class="anchorlink" href="#condicoes-or">2.5 Condições OR</a></h4><p>Condições <code>OR</code> entre duas relações podem ser construídas chamando <code>or</code> na primeira relação, e passando o segundo como um argumento.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">locked: </span><span class="kp">true</span><span class="p">).</span><span class="nf">or</span><span class="p">(</span><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">orders_count: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]))</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-9f5d4d4b2437364075e788dfab0c6c6d">Client.where(locked: true).or(Client.where(orders_count: [1,3,5]))
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-9f5d4d4b2437364075e788dfab0c6c6d">Copiar</button>
</div>
<div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">clients</span><span class="p">.</span><span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">OR</span> <span class="n">clients</span><span class="p">.</span><span class="n">orders_count</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-adb9bb5de1710f87f6ad9b6c9e691455">SELECT * FROM clients WHERE (clients.locked = 1 OR clients.orders_count IN (1,3,5))
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-adb9bb5de1710f87f6ad9b6c9e691455">Copiar</button>
</div>
<h3 id="ordenando"><a class="anchorlink" href="#ordenando">3 Ordenando</a></h3><p>Para recuperar registros do banco de dados em uma ordem específica, você pode usar o método de <code>order</code>.</p><p>Por exemplo, se você deseja obter um conjunto de registros e ordená-los em ordem crescente pelo campo <code>created_at</code> na sua tabela:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:created_at</span><span class="p">)</span>
<span class="c1"># OU</span>
<span class="no">Client</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"created_at"</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-4384d7e62f0b8edf894fc674310423d6">Client.order(:created_at)
# OU
Client.order("created_at")
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-4384d7e62f0b8edf894fc674310423d6">Copiar</button>
</div>
<p>Você também pode especificar <code>ASC</code> ou<code>DESC</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">created_at: :desc</span><span class="p">)</span>
<span class="c1"># OU</span>
<span class="no">Client</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">created_at: :asc</span><span class="p">)</span>
<span class="c1"># OU</span>
<span class="no">Client</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"created_at DESC"</span><span class="p">)</span>
<span class="c1"># OU</span>
<span class="no">Client</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"created_at ASC"</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-0414c432e8fac28ce12e554da4dd5959">Client.order(created_at: :desc)
# OU
Client.order(created_at: :asc)
# OU
Client.order("created_at DESC")
# OU
Client.order("created_at ASC")
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-0414c432e8fac28ce12e554da4dd5959">Copiar</button>
</div>
<p>Ou ordenar por campos diversos:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">orders_count: :asc</span><span class="p">,</span> <span class="ss">created_at: :desc</span><span class="p">)</span>
<span class="c1"># OU</span>
<span class="no">Client</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:orders_count</span><span class="p">,</span> <span class="ss">created_at: :desc</span><span class="p">)</span>
<span class="c1"># OU</span>
<span class="no">Client</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"orders_count ASC, created_at DESC"</span><span class="p">)</span>
<span class="c1"># OU</span>
<span class="no">Client</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"orders_count ASC"</span><span class="p">,</span> <span class="s2">"created_at DESC"</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-0fa6db455b5e14fdd9004912a309a6bf">Client.order(orders_count: :asc, created_at: :desc)
# OU
Client.order(:orders_count, created_at: :desc)
# OU
Client.order("orders_count ASC, created_at DESC")
# OU
Client.order("orders_count ASC", "created_at DESC")
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-0fa6db455b5e14fdd9004912a309a6bf">Copiar</button>
</div>
<p>Se você quiser chamar <code>order</code> várias vezes, as ordens subsequentes serão anexados à primeira:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"orders_count ASC"</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s2">"created_at DESC"</span><span class="p">)</span>
<span class="c1"># SELECT * FROM clients ORDER BY orders_count ASC, created_at DESC</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-fd78470ba4142856d154f8247443a376">Client.order("orders_count ASC").order("created_at DESC")
# SELECT * FROM clients ORDER BY orders_count ASC, created_at DESC
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-fd78470ba4142856d154f8247443a376">Copiar</button>
</div>
<div class="warning"><p>Na maioria dos sistemas de banco de dados, ao selecionar campos com <code>distinct</code> de um conjunto de resultados usando métodos como<code>select</code>, <code>pluck</code> e <code>ids</code>; o método <code>order</code> gerará uma exceção <code>ActiveRecord::StatementInvalid</code>, a menos que o(s) campo(s) usados ​​na cláusula <code>order</code> estejam incluídos na lista de seleção. Consulte a próxima seção para selecionar campos do conjunto de resultados.</p></div><h3 id="selecionando-campos-especificos"><a class="anchorlink" href="#selecionando-campos-especificos">4 Selecionando Campos Específicos</a></h3><p>Por padrão, <code>Model.find</code> seleciona todos os campos do conjunto de resultado usando <code>select *</code>.</p><p>Para selecionar somente um subconjunto de campos do conjunto de resultado, você pode especificar o
subconjunto via método <code>select</code>.</p><p>Por exemplo, para selecionar somente as colunas <code>viewable_by</code> e <code>locked</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:viewable_by</span><span class="p">,</span> <span class="ss">:locked</span><span class="p">)</span>
<span class="c1"># OU</span>
<span class="no">Client</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"viewable_by, locked"</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-520e1f8a2807e769d5e7a6229fdabc32">Client.select(:viewable_by, :locked)
# OU
Client.select("viewable_by, locked")
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-520e1f8a2807e769d5e7a6229fdabc32">Copiar</button>
</div>
<p>A <em>query</em> SQL usada por esta chamada de busca vai ser algo como:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">viewable_by</span><span class="p">,</span> <span class="n">locked</span> <span class="k">FROM</span> <span class="n">clients</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-a7cd59b7b9d96827c54a54294ea43bb6">SELECT viewable_by, locked FROM clients
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-a7cd59b7b9d96827c54a54294ea43bb6">Copiar</button>
</div>
<p>Tome cuidado pois isso também significa que você está inicializando um objeto <em>model</em> com somente os campos que você selecionou. Se você tentar acessar um campo que não está no registro inicializado,
você vai receber:</p><div class="code_container">
<pre><code class="highlight console"><span class="gp">ActiveModel::MissingAttributeError: missing attribute: &lt;attribute&gt;</span><span class="w">
</span></code></pre>
<textarea class="clipboard-content" id="clipboard-00e5723c9c445a7ac6e1b29f894ef9c3"></textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-00e5723c9c445a7ac6e1b29f894ef9c3">Copiar</button>
</div>
<p>Onde <code>&lt;attribute&gt;</code> é o atributo que você pediu. O método <code>id</code> não vai lançar o <code>ActiveRecord::MissingAttributeError</code>, então fique atento quando estiver trabalhando com associações, pois elas precisam do método <code>id</code> para funcionar corretamente.</p><p>Se você quiser pegar somente um registro por valor único em um certo campo, você pode usar <code>distinct</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:name</span><span class="p">).</span><span class="nf">distinct</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-63cf9f37df0e959aa95a6ccd1e5a2219">Client.select(:name).distinct
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-63cf9f37df0e959aa95a6ccd1e5a2219">Copiar</button>
</div>
<p>Isso vai gerar uma <em>query</em> SQL como:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">clients</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-77d7b206f064938b0a5e47dce000b745">SELECT DISTINCT name FROM clients
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-77d7b206f064938b0a5e47dce000b745">Copiar</button>
</div>
<p>Você pode também remover a restrição de unicidade:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">query</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:name</span><span class="p">).</span><span class="nf">distinct</span>
<span class="c1"># =&gt; Retorna nomes únicos</span>

<span class="n">query</span><span class="p">.</span><span class="nf">distinct</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span>
<span class="c1"># =&gt; Retorna todos os nomes, mesmo se houverem valores duplicados.</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-4d8fefca08075ec1a078ebf1ced90ade">query = Client.select(:name).distinct
# =&gt; Retorna nomes únicos

query.distinct(false)
# =&gt; Retorna todos os nomes, mesmo se houverem valores duplicados.
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-4d8fefca08075ec1a078ebf1ced90ade">Copiar</button>
</div>
<h3 id="limit-e-offset"><a class="anchorlink" href="#limit-e-offset">5 <em>Limit</em> e <em>Offset</em></a></h3><p>Para aplicar <code>LIMIT</code> ao SQL disparado pelo método <code>Model.find</code>, você pode especificar o <code>LIMIT</code> usando os métodos <code>limit</code> e <code>offset</code> na relação.</p><p>Você pode utilizar <code>limit</code> para especificar o número de registros para buscar, e usar <code>offset</code> para especificar o número de registros para pular antes de retornar os registros. Por exemplo</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-eb49375d4e922df419849d1283ec1b04">Client.limit(5)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-eb49375d4e922df419849d1283ec1b04">Copiar</button>
</div>
<p>retornará no máximo 5 clientes e devido ao método não especificar nenhum <em>offset</em> ele retornará os primeiros 5 registros na tabela. O SQL que o método executa será parecido com:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">LIMIT</span> <span class="mi">5</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-60b8000719abddc2942fc82a80429835">SELECT * FROM clients LIMIT 5
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-60b8000719abddc2942fc82a80429835">Copiar</button>
</div>
<p>Ao adicionar <code>offset</code></p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="nf">offset</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-8079a50d92bd978bf88b8e5db0f142f4">Client.limit(5).offset(30)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-8079a50d92bd978bf88b8e5db0f142f4">Copiar</button>
</div>
<p>a chamada retornará no lugar um máximo de 5 clientes iniciando com o trigésimo-primeiro. O SQL será parecido com:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">LIMIT</span> <span class="mi">5</span> <span class="k">OFFSET</span> <span class="mi">30</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-3fecebf424e2579a4fab35d2af82a53f">SELECT * FROM clients LIMIT 5 OFFSET 30
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-3fecebf424e2579a4fab35d2af82a53f">Copiar</button>
</div>
<h3 id="agrupando"><a class="anchorlink" href="#agrupando">6 Agrupando</a></h3><p>Para aplicar uma cláusula <code>GROUP BY</code> para o SQL disparado pelo localizador, você pode utilizar o método <code>group</code>.</p><p>Por exemplo, se você quer encontrar uma coleção das datas em que os pedidos foram criados:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Order</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"date(created_at) as ordered_date, sum(price) as total_price"</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="s2">"date(created_at)"</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-0443c46f490291dcf6d355f808eef657">Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)")
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-0443c46f490291dcf6d355f808eef657">Copiar</button>
</div>
<p>E isso te dará um único objeto <code>Order</code> para cada data em que há pedidos no banco de dados.</p><p>O SQL que será executado parecerá com algo como isso:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="nb">date</span><span class="p">(</span><span class="n">created_at</span><span class="p">)</span> <span class="k">as</span> <span class="n">ordered_date</span><span class="p">,</span> <span class="k">sum</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="k">as</span> <span class="n">total_price</span>
<span class="k">FROM</span> <span class="n">orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="nb">date</span><span class="p">(</span><span class="n">created_at</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-d8f52e079e1bd9f3b851712a7b0d7c0e">SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-d8f52e079e1bd9f3b851712a7b0d7c0e">Copiar</button>
</div>
<h4 id="total-de-itens-agrupados"><a class="anchorlink" href="#total-de-itens-agrupados">6.1 Total de itens agrupados</a></h4><p>Para pegar o total de itens agrupados em uma única <em>query</em>, chame <code>count</code> depois do <code>group</code>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Order</span><span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="ss">:status</span><span class="p">).</span><span class="nf">count</span>
<span class="c1"># =&gt; { 'awaiting_approval' =&gt; 7, 'paid' =&gt; 12 }</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-faa48ba38f57786ee35ea76f5819a31a">Order.group(:status).count
# =&gt; { 'awaiting_approval' =&gt; 7, 'paid' =&gt; 12 }
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-faa48ba38f57786ee35ea76f5819a31a">Copiar</button>
</div>
<p>O SQL que será executado parecerá com algo como isso:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="k">COUNT</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">count_all</span><span class="p">,</span> <span class="n">status</span> <span class="k">AS</span> <span class="n">status</span>
<span class="k">FROM</span> <span class="nv">"orders"</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">status</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-0c088c5122bbd33298fdc7562ce25b76">SELECT COUNT (*) AS count_all, status AS status
FROM "orders"
GROUP BY status
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-0c088c5122bbd33298fdc7562ce25b76">Copiar</button>
</div>
<h3 id="having"><a class="anchorlink" href="#having">7 <em>Having</em></a></h3><p>O SQL usa a cláusula <code>HAVING</code> para especificar condições nos campos <code>GROUP BY</code>. Você pode adicionar a cláusula <code>HAVING</code> ao SQL disparado pelo <code>Model.find</code> ao adicionar o método <code>having</code> à busca.</p><p>Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Order</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"date(created_at) as ordered_date, sum(price) as total_price"</span><span class="p">).</span>
  <span class="nf">group</span><span class="p">(</span><span class="s2">"date(created_at)"</span><span class="p">).</span><span class="nf">having</span><span class="p">(</span><span class="s2">"sum(price) &gt; ?"</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-090f3111514749699f1c6f4d96ad7674">Order.select("date(created_at) as ordered_date, sum(price) as total_price").
  group("date(created_at)").having("sum(price) &gt; ?", 100)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-090f3111514749699f1c6f4d96ad7674">Copiar</button>
</div>
<p>O SQL que será executado será parecido com isso:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="nb">date</span><span class="p">(</span><span class="n">created_at</span><span class="p">)</span> <span class="k">as</span> <span class="n">ordered_date</span><span class="p">,</span> <span class="k">sum</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="k">as</span> <span class="n">total_price</span>
<span class="k">FROM</span> <span class="n">orders</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="nb">date</span><span class="p">(</span><span class="n">created_at</span><span class="p">)</span>
<span class="k">HAVING</span> <span class="k">sum</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-1fafdc129202eb78348bc31d7932e167">SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
HAVING sum(price) &gt; 100
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-1fafdc129202eb78348bc31d7932e167">Copiar</button>
</div>
<p>Isso retorna a data e o preço total para cada objeto de pedido, agrupado pelo dia em que foram criados e se o preço é maior que $100.</p><h3 id="condicoes-de-substituicao"><a class="anchorlink" href="#condicoes-de-substituicao">8 Condições de Substituição</a></h3><h4 id="unscope"><a class="anchorlink" href="#unscope">8.1 <code>unscope</code></a></h4><p>Você pode especificar certas condições a serem removidas usando o método <code>unscope</code>. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Article</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'id &gt; 10'</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">20</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s1">'id asc'</span><span class="p">).</span><span class="nf">unscope</span><span class="p">(</span><span class="ss">:order</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-4d68f1d2ad4d552bbeb05edfb77a4efc">Article.where('id &gt; 10').limit(20).order('id asc').unscope(:order)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-4d68f1d2ad4d552bbeb05edfb77a4efc">Copiar</button>
</div>
<p>O SQL que será executado:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">articles</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">LIMIT</span> <span class="mi">20</span>

<span class="o">#</span> <span class="n">Original</span> <span class="n">query</span> <span class="k">without</span> <span class="nv">`unscope`</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">articles</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span> <span class="k">asc</span> <span class="k">LIMIT</span> <span class="mi">20</span>

</code></pre>
<textarea class="clipboard-content" id="clipboard-1843d00fee3df73aad2c730114f774eb">SELECT * FROM articles WHERE id &gt; 10 LIMIT 20

# Original query without `unscope`
SELECT * FROM articles WHERE id &gt; 10 ORDER BY id asc LIMIT 20

</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-1843d00fee3df73aad2c730114f774eb">Copiar</button>
</div>
<p>Você também pode remover o escopo de cláusulas <code>where</code> específicas. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Article</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">10</span><span class="p">,</span> <span class="ss">trashed: </span><span class="kp">false</span><span class="p">).</span><span class="nf">unscope</span><span class="p">(</span><span class="ss">where: :id</span><span class="p">)</span>
<span class="c1"># SELECT "articles".* FROM "articles" WHERE trashed = 0</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-05eb0551dff93fe0d7da9acaee89be3e">Article.where(id: 10, trashed: false).unscope(where: :id)
# SELECT "articles".* FROM "articles" WHERE trashed = 0
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-05eb0551dff93fe0d7da9acaee89be3e">Copiar</button>
</div>
<p>A relação que usou <code>unscope</code> afetará quaisquer relações nas quais foi unida:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Article</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s1">'id asc'</span><span class="p">).</span><span class="nf">merge</span><span class="p">(</span><span class="no">Article</span><span class="p">.</span><span class="nf">unscope</span><span class="p">(</span><span class="ss">:order</span><span class="p">))</span>
<span class="c1"># SELECT "articles".* FROM "articles"</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-afbb34a26d891c9ed1d38407bf0a0924">Article.order('id asc').merge(Article.unscope(:order))
# SELECT "articles".* FROM "articles"
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-afbb34a26d891c9ed1d38407bf0a0924">Copiar</button>
</div>
<h4 id="only"><a class="anchorlink" href="#only">8.2 <code>only</code></a></h4><p>Você também pode substituir condições com o método <code>only</code>. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Article</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'id &gt; 10'</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">20</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s1">'id desc'</span><span class="p">).</span><span class="nf">only</span><span class="p">(</span><span class="ss">:order</span><span class="p">,</span> <span class="ss">:where</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-9893bbffd2b59f5bc2554326fed183ae">Article.where('id &gt; 10').limit(20).order('id desc').only(:order, :where)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-9893bbffd2b59f5bc2554326fed183ae">Copiar</button>
</div>
<p>O SQL que será executado:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">articles</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span> <span class="k">DESC</span>

<span class="o">#</span> <span class="n">Query</span> <span class="n">original</span> <span class="n">sem</span> <span class="nv">`only`</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">articles</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">20</span>

</code></pre>
<textarea class="clipboard-content" id="clipboard-78b9c26ab19b6790d2954b4b8b4b2ac0">SELECT * FROM articles WHERE id &gt; 10 ORDER BY id DESC

# Query original sem `only`
SELECT * FROM articles WHERE id &gt; 10 ORDER BY id DESC LIMIT 20

</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-78b9c26ab19b6790d2954b4b8b4b2ac0">Copiar</button>
</div>
<h4 id="reselect"><a class="anchorlink" href="#reselect">8.3 <code>reselect</code></a></h4><p>O método <code>reselect</code> substitui uma declaração de <em>select</em> existente. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Post</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="ss">:body</span><span class="p">).</span><span class="nf">reselect</span><span class="p">(</span><span class="ss">:created_at</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-5ff15b0e29e3493bff2f3f6b847b1eff">Post.select(:title, :body).reselect(:created_at)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-5ff15b0e29e3493bff2f3f6b847b1eff">Copiar</button>
</div>
<p>O SQL que será executado:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="nv">`posts`</span><span class="p">.</span><span class="nv">`created_at`</span> <span class="k">FROM</span> <span class="nv">`posts`</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-4c2eaab83d41dd9e0aaf8fa7275e67dc">SELECT `posts`.`created_at` FROM `posts`
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-4c2eaab83d41dd9e0aaf8fa7275e67dc">Copiar</button>
</div>
<p>No caso em que a cláusula <code>reselect</code> não é utilizada,</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Post</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="ss">:body</span><span class="p">).</span><span class="nf">select</span><span class="p">(</span><span class="ss">:created_at</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-5948c3324d9faf961d70a030171ecad7">Post.select(:title, :body).select(:created_at)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-5948c3324d9faf961d70a030171ecad7">Copiar</button>
</div>
<p>o SQL executado será:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="nv">`posts`</span><span class="p">.</span><span class="nv">`title`</span><span class="p">,</span> <span class="nv">`posts`</span><span class="p">.</span><span class="nv">`body`</span><span class="p">,</span> <span class="nv">`posts`</span><span class="p">.</span><span class="nv">`created_at`</span> <span class="k">FROM</span> <span class="nv">`posts`</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-8eb0e2196a91d51ad13854e68caf3a25">SELECT `posts`.`title`, `posts`.`body`, `posts`.`created_at` FROM `posts`
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-8eb0e2196a91d51ad13854e68caf3a25">Copiar</button>
</div>
<h4 id="reorder"><a class="anchorlink" href="#reorder">8.4 <code>reorder</code></a></h4><p>O método <code>reorder</code> substitui a ordem de escopo padrão. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:comments</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">order</span><span class="p">(</span><span class="s1">'posted_at DESC'</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>

<span class="no">Article</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nf">comments</span><span class="p">.</span><span class="nf">reorder</span><span class="p">(</span><span class="s1">'name'</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-b51e2f7dd96cc591e74d2b9abd8883c1">class Article &lt; ApplicationRecord
  has_many :comments, -&gt; { order('posted_at DESC') }
end

Article.find(10).comments.reorder('name')
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-b51e2f7dd96cc591e74d2b9abd8883c1">Copiar</button>
</div>
<p>O SQL que será executado:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">articles</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">LIMIT</span> <span class="mi">1</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">comments</span> <span class="k">WHERE</span> <span class="n">article_id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">name</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-382bfbea043e2c0f16921804587b43f0">SELECT * FROM articles WHERE id = 10 LIMIT 1
SELECT * FROM comments WHERE article_id = 10 ORDER BY name
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-382bfbea043e2c0f16921804587b43f0">Copiar</button>
</div>
<p>No caso em que <code>reorder</code> não é utilizado, o SQL executado será:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">articles</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">LIMIT</span> <span class="mi">1</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">comments</span> <span class="k">WHERE</span> <span class="n">article_id</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">posted_at</span> <span class="k">DESC</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-42170fa947270172db1c131add01bd02">SELECT * FROM articles WHERE id = 10 LIMIT 1
SELECT * FROM comments WHERE article_id = 10 ORDER BY posted_at DESC
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-42170fa947270172db1c131add01bd02">Copiar</button>
</div>
<h4 id="reverse-order"><a class="anchorlink" href="#reverse-order">8.5 <code>reverse_order</code></a></h4><p>O método <code>reverse_order</code> reverte a ordem da cláusula, se especificado.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"orders_count &gt; 10"</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="ss">:name</span><span class="p">).</span><span class="nf">reverse_order</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-0d13bfb4a2e3415fb5039974ce9234d1">Client.where("orders_count &gt; 10").order(:name).reverse_order
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-0d13bfb4a2e3415fb5039974ce9234d1">Copiar</button>
</div>
<p>O SQL que será executado:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">WHERE</span> <span class="n">orders_count</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">name</span> <span class="k">DESC</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-8f3f9df71af08439e6ac2014d9ce6c73">SELECT * FROM clients WHERE orders_count &gt; 10 ORDER BY name DESC
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-8f3f9df71af08439e6ac2014d9ce6c73">Copiar</button>
</div>
<p>Se nenhuma cláusula de ordenação é especificada na <em>query</em>, o <code>reverse_order</code> ordena pela chave primária em ordem reversa.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"orders_count &gt; 10"</span><span class="p">).</span><span class="nf">reverse_order</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-c646a15d5cbd2dcffab342480d6fcfe8">Client.where("orders_count &gt; 10").reverse_order
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-c646a15d5cbd2dcffab342480d6fcfe8">Copiar</button>
</div>
<p>O SQL que será executado:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">WHERE</span> <span class="n">orders_count</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">clients</span><span class="p">.</span><span class="n">id</span> <span class="k">DESC</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-147f7658f4b9a790e96b7295eacad04c">SELECT * FROM clients WHERE orders_count &gt; 10 ORDER BY clients.id DESC
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-147f7658f4b9a790e96b7295eacad04c">Copiar</button>
</div>
<p>Esse método <strong>não aceita</strong> argumentos.</p><h4 id="rewhere"><a class="anchorlink" href="#rewhere">8.6 <code>rewhere</code></a></h4><p>O método <code>rewhere</code> substitui uma existente, nomeada condição de <em>where</em>. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Article</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">trashed: </span><span class="kp">true</span><span class="p">).</span><span class="nf">rewhere</span><span class="p">(</span><span class="ss">trashed: </span><span class="kp">false</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-1f563b6facf6bd14d4cf0e599cb12183">Article.where(trashed: true).rewhere(trashed: false)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-1f563b6facf6bd14d4cf0e599cb12183">Copiar</button>
</div>
<p>O SQL que será executado:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">articles</span> <span class="k">WHERE</span> <span class="nv">`trashed`</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-8b345e27d962281fd48d41a234ee3e7a">SELECT * FROM articles WHERE `trashed` = 0
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-8b345e27d962281fd48d41a234ee3e7a">Copiar</button>
</div>
<p>No caso em que a cláusula <code>rewhere</code> não é usada,</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Article</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">trashed: </span><span class="kp">true</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">trashed: </span><span class="kp">false</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-5cb705390a21406d8aac261829c5cc09">Article.where(trashed: true).where(trashed: false)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-5cb705390a21406d8aac261829c5cc09">Copiar</button>
</div>
<p>o SQL será:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">articles</span> <span class="k">WHERE</span> <span class="nv">`trashed`</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="nv">`trashed`</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-2165e37a15727f5db11f79f3008ded21">SELECT * FROM articles WHERE `trashed` = 1 AND `trashed` = 0
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-2165e37a15727f5db11f79f3008ded21">Copiar</button>
</div>
<h3 id="relacoes-nulas"><a class="anchorlink" href="#relacoes-nulas">9 Relações Nulas</a></h3><p>O método <code>none</code> retorna uma relação encadeada sem registros. Quaisquer condições subsequentes encadeadas à relação retornada continuarão gerando relações vazias. Isso é útil em cenários onde você precisa de uma resposta encadeada para um método ou um escopo que pode retornar zero resultados.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Article</span><span class="p">.</span><span class="nf">none</span> <span class="c1"># retorna uma Relation vazia e não dispara nenhuma query.</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-60e552144048d319ad31e00ce77b09df">Article.none # retorna uma Relation vazia e não dispara nenhuma query.
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-60e552144048d319ad31e00ce77b09df">Copiar</button>
</div>
<div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># O método visible_articles abaixo deve retornar uma Relation.</span>
<span class="vi">@articles</span> <span class="o">=</span> <span class="n">current_user</span><span class="p">.</span><span class="nf">visible_articles</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="n">params</span><span class="p">[</span><span class="ss">:name</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">visible_articles</span>
  <span class="k">case</span> <span class="n">role</span>
  <span class="k">when</span> <span class="s1">'Country Manager'</span>
    <span class="no">Article</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">country: </span><span class="n">country</span><span class="p">)</span>
  <span class="k">when</span> <span class="s1">'Reviewer'</span>
    <span class="no">Article</span><span class="p">.</span><span class="nf">published</span>
  <span class="k">when</span> <span class="s1">'Bad User'</span>
    <span class="no">Article</span><span class="p">.</span><span class="nf">none</span> <span class="c1"># =&gt; neste caso, retornar [] ou nil quebrará o código que invocou</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-cfb7ea68ba7e8aa61e674f54e17090e9"># O método visible_articles abaixo deve retornar uma Relation.
@articles = current_user.visible_articles.where(name: params[:name])

def visible_articles
  case role
  when 'Country Manager'
    Article.where(country: country)
  when 'Reviewer'
    Article.published
  when 'Bad User'
    Article.none # =&gt; neste caso, retornar [] ou nil quebrará o código que invocou
  end
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-cfb7ea68ba7e8aa61e674f54e17090e9">Copiar</button>
</div>
<h3 id="objetos-readonly-somente-leitura"><a class="anchorlink" href="#objetos-readonly-somente-leitura">10 Objetos <em>Readonly</em> (Somente leitura)</a></h3><p>O <em>Active Record</em> provê o método <code>readonly</code> em uma relação para desabilitar modificações explicitamente em qualquer um dos objetos retornados. Qualquer tentativa de alterar um registro <em>readonly</em> não ocorrerá, levantando uma exceção <code>ActiveRecord::ReadOnlyRecord</code>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">client</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">readonly</span><span class="p">.</span><span class="nf">first</span>
<span class="n">client</span><span class="p">.</span><span class="nf">visits</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">client</span><span class="p">.</span><span class="nf">save</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-3e7e06f820a53f408942c9137da57377">client = Client.readonly.first
client.visits += 1
client.save
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-3e7e06f820a53f408942c9137da57377">Copiar</button>
</div>
<p>Como <code>client</code> é explicitamente configurado para ser um objeto <em>readonly</em>, o código acima levantará uma exceção <code>ActiveRecord::ReadOnlyRecord</code> ao chamar <code>client.save</code> com o valor atualizado de <em>visits</em>.</p><h3 id="bloqueando-registros-para-alteracao"><a class="anchorlink" href="#bloqueando-registros-para-alteracao">11 Bloqueando registros para alteração</a></h3><p>O bloqueio é útil para prevenir condições de corrida ao alterar registros no banco de dados e para garantir alterações atômicas.</p><p>O Active Record provê dois mecanismos de bloqueio:</p>
<ul>
<li>Bloqueio otimista</li>
<li>Bloqueio pessimista</li>
</ul>
<h4 id="bloqueio-otimista"><a class="anchorlink" href="#bloqueio-otimista">11.1 Bloqueio Otimista</a></h4><p>O bloqueio otimista permite que múltiplos usuários acessem o mesmo registro para edição e presume um mínimo de conflitos com os dados. Isto é feito verificando se outro processo fez mudanças em um registro desde que ele foi aberto. Uma exceção <code>ActiveRecord::StaleObjectError</code> é disparada se isso ocorreu e a alteração é ignorada.</p><p><strong>Coluna de bloqueio otimista</strong></p><p>Para usar o bloqueio otimista, a tabela precisa ter uma coluna chamada <code>lock_version</code> do tipo inteiro. Cada vez que o registro é alterado, o Active Record incrementa o valor na coluna <code>lock_version</code>. Se uma requisição de alteração é feita com um valor menor no campo <code>lock_version</code> do que o valor que está atualmente na coluna <code>lock_version</code> no banco de dados, a requisição de alteração falhará com um <code>ActiveRecord::StaleObjectError</code>. Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">c1</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">c1</span><span class="p">.</span><span class="nf">first_name</span> <span class="o">=</span> <span class="s2">"Michael"</span>
<span class="n">c1</span><span class="p">.</span><span class="nf">save</span>

<span class="n">c2</span><span class="p">.</span><span class="nf">name</span> <span class="o">=</span> <span class="s2">"vai falhar"</span>
<span class="n">c2</span><span class="p">.</span><span class="nf">save</span> <span class="c1"># Dispara um ActiveRecord::StaleObjectError</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-68fcf57cfef1ecbb27273235cd221734">c1 = Client.find(1)
c2 = Client.find(1)

c1.first_name = "Michael"
c1.save

c2.name = "vai falhar"
c2.save # Dispara um ActiveRecord::StaleObjectError
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-68fcf57cfef1ecbb27273235cd221734">Copiar</button>
</div>
<p>Você fica então responsável por lidar com o conflito tratando a exceção e desfazendo as alterações, agrupando-as ou aplicando a lógica de negócio necessária para resolver o conflito.</p><p>Este comportamento pode ser desativado definindo <code>ActiveRecord::Base.lock_optimistically = false</code>.</p><p>Para usar outro nome para a coluna <code>lock_version</code>, <code>ActiveRecord::Base</code> oferece um atributo de classe chamado <code>locking_column</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Client</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">locking_column</span> <span class="o">=</span> <span class="ss">:lock_client_column</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-8a87984826fa64199376fb0e38798330">class Client &lt; ApplicationRecord
  self.locking_column = :lock_client_column
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-8a87984826fa64199376fb0e38798330">Copiar</button>
</div>
<h4 id="bloqueio-pessimista"><a class="anchorlink" href="#bloqueio-pessimista">11.2 Bloqueio pessimista</a></h4><p>O bloqueio pessimista usa um mecansimo de bloqueio fornecido pelo banco de dados subjacente. Ao usar <code>lock</code> quando uma <em>relation</em> (objeto do tipo ActiveRecord::Relation) é criada, obtém-se um bloqueio exclusivo nas linhas selecionadas. Relations usando <code>lock</code> são normalmente executadas dentro de uma transação para permitir condições de deadlock.</p><p>Por exemplo:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Item</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
  <span class="n">i</span> <span class="o">=</span> <span class="no">Item</span><span class="p">.</span><span class="nf">lock</span><span class="p">.</span><span class="nf">first</span>
  <span class="n">i</span><span class="p">.</span><span class="nf">name</span> <span class="o">=</span> <span class="s1">'Jones'</span>
  <span class="n">i</span><span class="p">.</span><span class="nf">save!</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-a77a8d58416df50a4e8d3ddd4772ff8e">Item.transaction do
  i = Item.lock.first
  i.name = 'Jones'
  i.save!
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-a77a8d58416df50a4e8d3ddd4772ff8e">Copiar</button>
</div>
<p>A sessão acima produz o seguinte SQL para um banco de dados MySQL:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SQL</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="n">ms</span><span class="p">)</span>   <span class="k">BEGIN</span>
<span class="n">Item</span> <span class="k">Load</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="n">ms</span><span class="p">)</span>   <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="nv">`items`</span> <span class="k">LIMIT</span> <span class="mi">1</span> <span class="k">FOR</span> <span class="k">UPDATE</span>
<span class="n">Item</span> <span class="k">Update</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">4</span><span class="n">ms</span><span class="p">)</span>   <span class="k">UPDATE</span> <span class="nv">`items`</span> <span class="k">SET</span> <span class="nv">`updated_at`</span> <span class="o">=</span> <span class="s1">'2009-02-07 18:05:56'</span><span class="p">,</span> <span class="nv">`name`</span> <span class="o">=</span> <span class="s1">'Jones'</span> <span class="k">WHERE</span> <span class="nv">`id`</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">SQL</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">8</span><span class="n">ms</span><span class="p">)</span>   <span class="k">COMMIT</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-3df4d44b06c8d9df8a0e49e8467d126e">SQL (0.2ms)   BEGIN
Item Load (0.3ms)   SELECT * FROM `items` LIMIT 1 FOR UPDATE
Item Update (0.4ms)   UPDATE `items` SET `updated_at` = '2009-02-07 18:05:56', `name` = 'Jones' WHERE `id` = 1
SQL (0.8ms)   COMMIT
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-3df4d44b06c8d9df8a0e49e8467d126e">Copiar</button>
</div>
<p>Você também pode passar SQL diretamente para o método <code>lock</code> para permitir diferentes tipos de bloqueio. Por exemplo, MySQL tem uma expressão chamada <code>LOCK IN SHARE MODE</code> que permite bloquear um registro mas ainda assim permitir que outras consultas o leiam. Para especificar esta expressão, basta passá-la ao método <code>lock</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Item</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
  <span class="n">i</span> <span class="o">=</span> <span class="no">Item</span><span class="p">.</span><span class="nf">lock</span><span class="p">(</span><span class="s2">"LOCK IN SHARE MODE"</span><span class="p">).</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">i</span><span class="p">.</span><span class="nf">increment!</span><span class="p">(</span><span class="ss">:views</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-25b44e9fdded65c5015bf2013732a027">Item.transaction do
  i = Item.lock("LOCK IN SHARE MODE").find(1)
  i.increment!(:views)
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-25b44e9fdded65c5015bf2013732a027">Copiar</button>
</div>
<p>Se você já tem uma instância do seu modelo, você pode iniciar uma transação e obter o bloqueio de uma vez só usando o código seguinte:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">item</span> <span class="o">=</span> <span class="no">Item</span><span class="p">.</span><span class="nf">first</span>
<span class="n">item</span><span class="p">.</span><span class="nf">with_lock</span> <span class="k">do</span>
  <span class="c1"># Este bloco é chamado dentro de uma transação,</span>
  <span class="c1"># o item já está bloqueado.</span>
  <span class="n">item</span><span class="p">.</span><span class="nf">increment!</span><span class="p">(</span><span class="ss">:views</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-88237b8bdea2f044fced92315556e614">item = Item.first
item.with_lock do
  # Este bloco é chamado dentro de uma transação,
  # o item já está bloqueado.
  item.increment!(:views)
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-88237b8bdea2f044fced92315556e614">Copiar</button>
</div>
<h3 id="associando-tabelas"><a class="anchorlink" href="#associando-tabelas">12 Associando Tabelas</a></h3><p>O <em>Active Record</em> fornece dois métodos de busca para especificar cláusulas <code>JOIN</code> no SQL resultante: <code>joins</code> e <code>left_outer_joins</code>.
Enquanto <code>joins</code> deve ser utilizado para <code>INNER JOIN</code> em consultas personalizadas,
<code>left_outer_joins</code> é usado para consultas usando <code>LEFT OUTER JOIN</code>.</p><h4 id="joins"><a class="anchorlink" href="#joins">12.1 <code>joins</code></a></h4><p>Há múltiplas maneiras de usar o método <code>joins</code>.</p><h5 id="usando-um-fragmento-de-string-sql"><a class="anchorlink" href="#usando-um-fragmento-de-string-sql">12.1.1 Usando um Fragmento de String SQL</a></h5><p>Você pode apenas fornecer o SQL literal especificando a cláusula <code>JOIN</code> para <code>joins</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Author</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="s2">"INNER JOIN posts ON posts.author_id = authors.id AND posts.published = 't'"</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-00f8a6c31e2e30d4fc25b010d9bfecfd">Author.joins("INNER JOIN posts ON posts.author_id = authors.id AND posts.published = 't'")
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-00f8a6c31e2e30d4fc25b010d9bfecfd">Copiar</button>
</div>
<p>Isso resultará no seguinte SQL:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">authors</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">authors</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">posts</span> <span class="k">ON</span> <span class="n">posts</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span> <span class="k">AND</span> <span class="n">posts</span><span class="p">.</span><span class="n">published</span> <span class="o">=</span> <span class="s1">'t'</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-5e6f99a4dfaf088f2c49a35e4c78cf92">SELECT authors.* FROM authors INNER JOIN posts ON posts.author_id = authors.id AND posts.published = 't'
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-5e6f99a4dfaf088f2c49a35e4c78cf92">Copiar</button>
</div>
<h5 id="usando-array-hash-de-associacoes-nomeadas"><a class="anchorlink" href="#usando-array-hash-de-associacoes-nomeadas">12.1.2 Usando Array/Hash de Associações Nomeadas</a></h5><p>O <em>Active Record</em> permite que você use os nomes de <a href="association_basics.html">associações</a> definidos no <em>model</em> como um atalho para especificar cláusulas <code>JOIN</code> para essas associações quando estiver usando o método  <code>joins</code>.</p><p>Por exemplo, considere os seguintes <em>models</em> <code>Category</code>, <code>Article</code>, <code>Comment</code>, <code>Guest</code> e <code>Tag</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Category</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_many</span> <span class="ss">:articles</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:category</span>
  <span class="n">has_many</span> <span class="ss">:comments</span>
  <span class="n">has_many</span> <span class="ss">:tags</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Comment</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:article</span>
  <span class="n">has_one</span> <span class="ss">:guest</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Guest</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:comment</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Tag</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">belongs_to</span> <span class="ss">:article</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-3e0667db41bf193b22a13b7fbc1ef2bf">class Category &lt; ApplicationRecord
  has_many :articles
end

class Article &lt; ApplicationRecord
  belongs_to :category
  has_many :comments
  has_many :tags
end

class Comment &lt; ApplicationRecord
  belongs_to :article
  has_one :guest
end

class Guest &lt; ApplicationRecord
  belongs_to :comment
end

class Tag &lt; ApplicationRecord
  belongs_to :article
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-3e0667db41bf193b22a13b7fbc1ef2bf">Copiar</button>
</div>
<p>Agora, todos os itens a seguir irão produzir as consultas de junção (<em>join</em>) esperadas usando <code>INNER JOIN</code>:</p><h6 id="unindo-uma-associacao-unica"><a class="anchorlink" href="#unindo-uma-associacao-unica">12.1.2.1 Unindo uma Associação Única</a></h6><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Category</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:articles</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-6a96accbf18ae47b6109081d3efa8c14">Category.joins(:articles)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-6a96accbf18ae47b6109081d3efa8c14">Copiar</button>
</div>
<p>Isso produz:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">categories</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">categories</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">articles</span> <span class="k">ON</span> <span class="n">articles</span><span class="p">.</span><span class="n">category_id</span> <span class="o">=</span> <span class="n">categories</span><span class="p">.</span><span class="n">id</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-8b156ec862989dd7589f0dc1b9cf9529">SELECT categories.* FROM categories
  INNER JOIN articles ON articles.category_id = categories.id
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-8b156ec862989dd7589f0dc1b9cf9529">Copiar</button>
</div>
<p>Ou, em Português: "retorne um objeto <code>Category</code> para todas as categorias com artigos". Observe que você verá categorias duplicadas se mais de um artigo tiver a mesma categoria. Se você quiser categorias exclusivas, pode usar <code>Category.joins(:articles).distinct</code>.</p><h5 id="unindo-multiplas-associacoes"><a class="anchorlink" href="#unindo-multiplas-associacoes">12.1.3 Unindo Múltiplas Associações</a></h5><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Article</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:category</span><span class="p">,</span> <span class="ss">:comments</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-258d62db6a2113cad449bf2ac339491f">Article.joins(:category, :comments)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-258d62db6a2113cad449bf2ac339491f">Copiar</button>
</div>
<p>Isso produz:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">articles</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">articles</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">categories</span> <span class="k">ON</span> <span class="n">categories</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">articles</span><span class="p">.</span><span class="n">category_id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">comments</span> <span class="k">ON</span> <span class="n">comments</span><span class="p">.</span><span class="n">article_id</span> <span class="o">=</span> <span class="n">articles</span><span class="p">.</span><span class="n">id</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-211a052f7b0167f8f7267770c861c351">SELECT articles.* FROM articles
  INNER JOIN categories ON categories.id = articles.category_id
  INNER JOIN comments ON comments.article_id = articles.id
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-211a052f7b0167f8f7267770c861c351">Copiar</button>
</div>
<p>Ou, em Português: "retorne todos os artigos que tem uma categoria e ao menos um comentário". Observe novamente que artigos com múltiplos comentários aparecerão múltiplas vezes.</p><h6 id="unindo-associacoes-aninhadas-nivel-unico"><a class="anchorlink" href="#unindo-associacoes-aninhadas-nivel-unico">12.1.3.1 Unindo Associações Aninhadas (Nível Único)</a></h6><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Article</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">comments: :guest</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-5c653ed678857abaa10cc7e693dd6fd2">Article.joins(comments: :guest)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-5c653ed678857abaa10cc7e693dd6fd2">Copiar</button>
</div>
<p>Isso produz:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">articles</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">articles</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">comments</span> <span class="k">ON</span> <span class="n">comments</span><span class="p">.</span><span class="n">article_id</span> <span class="o">=</span> <span class="n">articles</span><span class="p">.</span><span class="n">id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">guests</span> <span class="k">ON</span> <span class="n">guests</span><span class="p">.</span><span class="n">comment_id</span> <span class="o">=</span> <span class="n">comments</span><span class="p">.</span><span class="n">id</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-26725a70d06887f1fa2735ac1f20154c">SELECT articles.* FROM articles
  INNER JOIN comments ON comments.article_id = articles.id
  INNER JOIN guests ON guests.comment_id = comments.id
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-26725a70d06887f1fa2735ac1f20154c">Copiar</button>
</div>
<p>Ou, em Português: "retorne todos os artigos que tem um comentário feito por um convidado."</p><h6 id="unindo-associacoes-aninhadas-niveis-multiplos"><a class="anchorlink" href="#unindo-associacoes-aninhadas-niveis-multiplos">12.1.3.2 Unindo Associações Aninhadas (Níveis Múltiplos)</a></h6><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Category</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">articles: </span><span class="p">[{</span> <span class="ss">comments: :guest</span> <span class="p">},</span> <span class="ss">:tags</span><span class="p">])</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-4e8312ff07fa750cc7d644d8b582641e">Category.joins(articles: [{ comments: :guest }, :tags])
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-4e8312ff07fa750cc7d644d8b582641e">Copiar</button>
</div>
<p>Isso produz:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">categories</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">categories</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">articles</span> <span class="k">ON</span> <span class="n">articles</span><span class="p">.</span><span class="n">category_id</span> <span class="o">=</span> <span class="n">categories</span><span class="p">.</span><span class="n">id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">comments</span> <span class="k">ON</span> <span class="n">comments</span><span class="p">.</span><span class="n">article_id</span> <span class="o">=</span> <span class="n">articles</span><span class="p">.</span><span class="n">id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">guests</span> <span class="k">ON</span> <span class="n">guests</span><span class="p">.</span><span class="n">comment_id</span> <span class="o">=</span> <span class="n">comments</span><span class="p">.</span><span class="n">id</span>
  <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">tags</span> <span class="k">ON</span> <span class="n">tags</span><span class="p">.</span><span class="n">article_id</span> <span class="o">=</span> <span class="n">articles</span><span class="p">.</span><span class="n">id</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-9781c74bb084a9073196f324174f5d7e">SELECT categories.* FROM categories
  INNER JOIN articles ON articles.category_id = categories.id
  INNER JOIN comments ON comments.article_id = articles.id
  INNER JOIN guests ON guests.comment_id = comments.id
  INNER JOIN tags ON tags.article_id = articles.id
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-9781c74bb084a9073196f324174f5d7e">Copiar</button>
</div>
<p>Ou, em Português: "retorne todas as categorias que têm artigos, sendo que estes artigos têm um comentário feito por um convidado, e que estes artigos também tenham uma <em>tag</em>."</p><h5 id="especificando-condicoes-em-tabelas-associadas"><a class="anchorlink" href="#especificando-condicoes-em-tabelas-associadas">12.1.4 Especificando Condições em Tabelas Associadas</a></h5><p>Você pode especificar condições nas tabelas associadas com condições <a href="#array-conditions">Array</a> e <a href="#pure-string-conditions">String</a>. <a href="#hash-conditions">Hash conditions</a> fornecem uma sintaxe especial para especificar condições para as tabelas associadas:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">time_range</span> <span class="o">=</span> <span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span>
<span class="no">Client</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="s1">'orders.created_at'</span> <span class="o">=&gt;</span> <span class="n">time_range</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-74c7fc0065e444bc6f21424c5fee47c9">time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Client.joins(:orders).where('orders.created_at' =&gt; time_range)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-74c7fc0065e444bc6f21424c5fee47c9">Copiar</button>
</div>
<p>Uma sintaxe alternativa e mais limpa é aninhar as condições de <em>hash</em>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">time_range</span> <span class="o">=</span> <span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">)</span><span class="o">..</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">midnight</span>
<span class="no">Client</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:orders</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">orders: </span><span class="p">{</span> <span class="ss">created_at: </span><span class="n">time_range</span> <span class="p">})</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-a2820c33c4b4c18fd225d05f31429da8">time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Client.joins(:orders).where(orders: { created_at: time_range })
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-a2820c33c4b4c18fd225d05f31429da8">Copiar</button>
</div>
<p>Isso encontrará todos os clientes que têm pedidos criados ontem, novamente usando uma expressão SQL <code>BETWEEN</code>.</p><h4 id="left-outer-joins"><a class="anchorlink" href="#left-outer-joins">12.2 <code>left_outer_joins</code></a></h4><p>Se você deseja selecionar um conjunto de registros tendo ou não registros associados, você pode usar o método <code>left_outer_joins</code>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Author</span><span class="p">.</span><span class="nf">left_outer_joins</span><span class="p">(</span><span class="ss">:posts</span><span class="p">).</span><span class="nf">distinct</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s1">'authors.*, COUNT(posts.*) AS posts_count'</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="s1">'authors.id'</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-e1ead7030081573d6c55b185a4d4bf56">Author.left_outer_joins(:posts).distinct.select('authors.*, COUNT(posts.*) AS posts_count').group('authors.id')
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-e1ead7030081573d6c55b185a4d4bf56">Copiar</button>
</div>
<p>Que resulta em:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">authors</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">posts</span><span class="p">.</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">posts_count</span> <span class="k">FROM</span> <span class="nv">"authors"</span>
<span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">posts</span> <span class="k">ON</span> <span class="n">posts</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">authors</span><span class="p">.</span><span class="n">id</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-38af36c5b65dec4f158919f9d3fd2292">SELECT DISTINCT authors.*, COUNT(posts.*) AS posts_count FROM "authors"
LEFT OUTER JOIN posts ON posts.author_id = authors.id GROUP BY authors.id
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-38af36c5b65dec4f158919f9d3fd2292">Copiar</button>
</div>
<p>Que significa: "retorne todos os autores com suas contagens de posts, tenham eles postagens ou não"</p><h3 id="associations-com-eager-loading"><a class="anchorlink" href="#associations-com-eager-loading">13 Associations com <em>Eager Loading</em></a></h3><p>O <em>eager loading</em> rápido é o mecanismo para carregar os registros associados dos objetos retornados por <code>Model.find</code> usando o mínimo de consultas possível.</p><p><strong>Problema de consultas N + 1</strong></p><p>Considere o seguinte código, que encontra 10 clientes e imprime seus códigos postais:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">clients</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">clients</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">client</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">client</span><span class="p">.</span><span class="nf">address</span><span class="p">.</span><span class="nf">postcode</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-970bc79ed6aec1bc4fec8a0fd431e1bf">clients = Client.limit(10)

clients.each do |client|
  puts client.address.postcode
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-970bc79ed6aec1bc4fec8a0fd431e1bf">Copiar</button>
</div>
<p>Este código parece bom à primeira vista. Mas o problema está no número total de consultas executadas. O código acima executa 1 (para encontrar 10 clientes) + 10 (um para cada cliente para carregar o endereço) = <strong>11</strong> consultas no total.</p><p><strong>Solução para problemas de consultas N + 1</strong></p><p>o <em>Active Record</em> permite que você especifique com antecedência todas as associações que serão carregadas. Isso é possível especificando o método <code>includes</code> da chamada <code>Model.find</code>. Com o <code>includes</code>, o <em>Active Record</em> garante que todas as associações especificadas sejam carregadas usando o número mínimo possível de consultas.</p><p>Revisitando o caso acima, poderíamos reescrever <code>Client.limit(10)</code> para endereços de carregamento antecipado:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">clients</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:address</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="n">clients</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">client</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">client</span><span class="p">.</span><span class="nf">address</span><span class="p">.</span><span class="nf">postcode</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-fe0bd514eb8767e30d8019a8baf8d881">clients = Client.includes(:address).limit(10)

clients.each do |client|
  puts client.address.postcode
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-fe0bd514eb8767e30d8019a8baf8d881">Copiar</button>
</div>
<p>O código acima executará apenas <strong>2</strong> consultas, em oposição às <strong>11</strong> consultas do caso anterior:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">LIMIT</span> <span class="mi">10</span>
<span class="k">SELECT</span> <span class="n">addresses</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">addresses</span>
  <span class="k">WHERE</span> <span class="p">(</span><span class="n">addresses</span><span class="p">.</span><span class="n">client_id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-7d3992f1dad78ee5f7cecdfdacd668d7">SELECT * FROM clients LIMIT 10
SELECT addresses.* FROM addresses
  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-7d3992f1dad78ee5f7cecdfdacd668d7">Copiar</button>
</div>
<h4 id="eager-loading-multiple-associations"><a class="anchorlink" href="#eager-loading-multiple-associations">13.1 Eager Loading Multiple Associations</a></h4><p>O <em>Active Record</em> permite que você carregue rapidamente qualquer número de associações com uma única chamada <code>Model.find</code> usando um <em>array</em>, <em>hash</em>, ou um <em>hash</em> aninhado de <em>array</em> / <em>hash</em> com o método <code>includes</code>.</p><h5 id="array-de-associacoes-multiplas"><a class="anchorlink" href="#array-de-associacoes-multiplas">13.1.1 <em>Array</em> de Associações Múltiplas</a></h5><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Article</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:category</span><span class="p">,</span> <span class="ss">:comments</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-3459d0e7fd546732dd11e2c7d1173f19">Article.includes(:category, :comments)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-3459d0e7fd546732dd11e2c7d1173f19">Copiar</button>
</div>
<p>Isso carrega todos os artigos e a categoria associada e comentários para cada artigo.</p><h5 id="hash-de-associacoes-aninhadas"><a class="anchorlink" href="#hash-de-associacoes-aninhadas">13.1.2 <em>Hash</em> de Associações Aninhadas</a></h5><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Category</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">articles: </span><span class="p">[{</span> <span class="ss">comments: :guest</span> <span class="p">},</span> <span class="ss">:tags</span><span class="p">]).</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-ed269150bc5ac64422bcba09f8fab9f8">Category.includes(articles: [{ comments: :guest }, :tags]).find(1)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-ed269150bc5ac64422bcba09f8fab9f8">Copiar</button>
</div>
<p>Isso encontrará a categoria com id 1 e carregará antecipadamente todos os artigos associados, as tags e comentários dos artigos associados e todas as associações de comentários de convidados.</p><h4 id="especificando-condicoes-em-associacoes-eager-loaded"><a class="anchorlink" href="#especificando-condicoes-em-associacoes-eager-loaded">13.2 Especificando Condições em Associações <em>Eager Loaded</em></a></h4><p>Mesmo que o <em>Active Record</em> permita que você especifique as condições nas associações carregadas antecipadamente como <code>joins</code>, a maneira recomendada é usar <a href="#associando-tabelas">joins</a> ao invés.</p><p>No entanto, se você deve fazer isso, você pode usar <code>where</code> como faria normalmente.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Article</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:comments</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">comments: </span><span class="p">{</span> <span class="ss">visible: </span><span class="kp">true</span> <span class="p">})</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-918b68d4e99f5547268ae232aa6f0c91">Article.includes(:comments).where(comments: { visible: true })
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-918b68d4e99f5547268ae232aa6f0c91">Copiar</button>
</div>
<p>Isso geraria uma consulta que contém um <code>LEFT OUTER JOIN</code> enquanto o
O método <code>joins</code> geraria um usando a função <code>INNER JOIN</code>.</p><div class="code_container">
<pre><code class="highlight ruby">  <span class="no">SELECT</span> <span class="s2">"articles"</span><span class="o">.</span><span class="s2">"id"</span> <span class="no">AS</span> <span class="n">t0_r0</span><span class="p">,</span> <span class="o">...</span> <span class="s2">"comments"</span><span class="o">.</span><span class="s2">"updated_at"</span> <span class="no">AS</span> <span class="n">t1_r5</span> <span class="no">FROM</span> <span class="s2">"articles"</span> <span class="no">LEFT</span> <span class="no">OUTER</span> <span class="no">JOIN</span> <span class="s2">"comments"</span> <span class="no">ON</span> <span class="s2">"comments"</span><span class="o">.</span><span class="s2">"article_id"</span> <span class="o">=</span> <span class="s2">"articles"</span><span class="o">.</span><span class="s2">"id"</span> <span class="no">WHERE</span> <span class="p">(</span><span class="n">comments</span><span class="p">.</span><span class="nf">visible</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-194b2caccefa0bc69429da2948e40801">  SELECT "articles"."id" AS t0_r0, ... "comments"."updated_at" AS t1_r5 FROM "articles" LEFT OUTER JOIN "comments" ON "comments"."article_id" = "articles"."id" WHERE (comments.visible = 1)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-194b2caccefa0bc69429da2948e40801">Copiar</button>
</div>
<p>Se não houvesse uma condição <code>where</code>, isso geraria o conjunto normal de duas consultas.</p><p>NOTA: Usar <code>where</code> assim só funcionará quando você passar um Hash. Para
Fragmentos de SQL você precisa usar <code>references</code> para forçar tabelas unidas:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Article</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:comments</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="s2">"comments.visible = true"</span><span class="p">).</span><span class="nf">references</span><span class="p">(</span><span class="ss">:comments</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-f1e8ace32fca8b833c3dcbf9f43f147a">Article.includes(:comments).where("comments.visible = true").references(:comments)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-f1e8ace32fca8b833c3dcbf9f43f147a">Copiar</button>
</div>
<p>Se, no caso desta consulta <code>includes</code>, não houve comentários para qualquer
artigos, todos os artigos ainda seriam carregados. Usando <code>joins</code> (um INNER
JOIN), as condições de junção <strong>devem</strong> corresponder, caso contrário, nenhum registro será
devolvido.</p><div class="note"><p>Se uma associação for carregada antecipadamente como parte de uma junção, quaisquer campos de uma cláusula de seleção personalizada não estarão presentes nos <em>models</em> carregados.
Isso ocorre porque é ambíguo se eles devem aparecer no registro do pai ou do filho.</p></div><h3 id="scopes"><a class="anchorlink" href="#scopes">14 <em>Scopes</em></a></h3><p>A definição do escopo permite que você especifique consultas comumente usadas, que podem ser referenciadas como chamadas de método nos objetos ou <em>modelos</em> associados. Com esses escopos, você pode usar todos os métodos cobertos anteriormente, como <code>where</code>, <code>joins</code> e <code>includes</code>. Todos os corpos de escopo devem retornar um <code>ActiveRecord::Relation</code> ou <code>nil</code> para permitir que métodos adicionais (como outros escopos) sejam chamados nele.</p><p>Para definir um escopo simples, usamos o método <code>scope</code> dentro da classe, passando a consulta que gostaríamos de executar quando este escopo for chamado:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:published</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">published: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-fff6cf500696021897d271048bc3c4ed">class Article &lt; ApplicationRecord
  scope :published, -&gt; { where(published: true) }
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-fff6cf500696021897d271048bc3c4ed">Copiar</button>
</div>
<p>Os escopos também podem ser encadeados dentro dos escopos:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:published</span><span class="p">,</span>               <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">published: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:published_and_commented</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">published</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"comments_count &gt; 0"</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-0c0f64fe25848891628ad8006e7d5c3d">class Article &lt; ApplicationRecord
  scope :published,               -&gt; { where(published: true) }
  scope :published_and_commented, -&gt; { published.where("comments_count &gt; 0") }
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-0c0f64fe25848891628ad8006e7d5c3d">Copiar</button>
</div>
<p>Para chamar este escopo <code>published</code>, podemos chamá-lo tanto na classe:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Article</span><span class="p">.</span><span class="nf">published</span> <span class="c1"># =&gt; [published articles]</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-ca52b88779516c79addc1cd971732083">Article.published # =&gt; [published articles]
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-ca52b88779516c79addc1cd971732083">Copiar</button>
</div>
<p>Ou em uma associação que consiste em objetos <code>Article</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">category</span> <span class="o">=</span> <span class="no">Category</span><span class="p">.</span><span class="nf">first</span>
<span class="n">category</span><span class="p">.</span><span class="nf">articles</span><span class="p">.</span><span class="nf">published</span> <span class="c1"># =&gt; [published articles belonging to this category]</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-0be88be177d776642d92dc7307cacdbe">category = Category.first
category.articles.published # =&gt; [published articles belonging to this category]
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-0be88be177d776642d92dc7307cacdbe">Copiar</button>
</div>
<h4 id="transmitindo-argumentos"><a class="anchorlink" href="#transmitindo-argumentos">14.1 Transmitindo argumentos</a></h4><p>Seu escopo pode receber argumentos:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:created_before</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="s2">"created_at &lt; ?"</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-c1642542739791097f63b158f2746082">class Article &lt; ApplicationRecord
  scope :created_before, -&gt;(time) { where("created_at &lt; ?", time) }
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-c1642542739791097f63b158f2746082">Copiar</button>
</div>
<p>Chame o escopo como se fosse um método de classe:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Article</span><span class="p">.</span><span class="nf">created_before</span><span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">zone</span><span class="p">.</span><span class="nf">now</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-9c72fcf8ed644ade37ab331b954812c5">Article.created_before(Time.zone.now)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-9c72fcf8ed644ade37ab331b954812c5">Copiar</button>
</div>
<p>No entanto, isso é apenas a duplicação da funcionalidade que seria fornecida a você por um método de classe.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">created_before</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">where</span><span class="p">(</span><span class="s2">"created_at &lt; ?"</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-67063b58adaebe05fd760454fa023e4b">class Article &lt; ApplicationRecord
  def self.created_before(time)
    where("created_at &lt; ?", time)
  end
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-67063b58adaebe05fd760454fa023e4b">Copiar</button>
</div>
<p>Usar um método de classe é a maneira preferida de aceitar argumentos para escopos. Esses métodos ainda estarão acessíveis nos objetos de associação:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">category</span><span class="p">.</span><span class="nf">articles</span><span class="p">.</span><span class="nf">created_before</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-4db8dab45d255bfac3b55d8d1d8259ec">category.articles.created_before(time)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-4db8dab45d255bfac3b55d8d1d8259ec">Copiar</button>
</div>
<h4 id="usando-condicionais"><a class="anchorlink" href="#usando-condicionais">14.2 Usando condicionais</a></h4><p>Seu escopo pode utilizar condicionais:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:created_before</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="s2">"created_at &lt; ?"</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="k">if</span> <span class="n">time</span><span class="p">.</span><span class="nf">present?</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-b61c817fef79df7ff2fb7a5795bc6cbd">class Article &lt; ApplicationRecord
  scope :created_before, -&gt;(time) { where("created_at &lt; ?", time) if time.present? }
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-b61c817fef79df7ff2fb7a5795bc6cbd">Copiar</button>
</div>
<p>Como os outros exemplos, isso se comportará de maneira semelhante a um método de classe.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">created_before</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">where</span><span class="p">(</span><span class="s2">"created_at &lt; ?"</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="k">if</span> <span class="n">time</span><span class="p">.</span><span class="nf">present?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-54c1d188e99b4b3d56153b627d590459">class Article &lt; ApplicationRecord
  def self.created_before(time)
    where("created_at &lt; ?", time) if time.present?
  end
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-54c1d188e99b4b3d56153b627d590459">Copiar</button>
</div>
<p>No entanto, há uma advertência importante: um escopo sempre retornará um objeto <code>ActiveRecord::Relation</code>, mesmo se a condicional for avaliada como <code>false</code>, enquanto um método de classe retornará <code>nil</code>. Isso pode causar <code>NoMethodError</code> ao encadear métodos de classe com condicionais, se qualquer uma das condicionais retornar <code>false</code>.</p><h4 id="aplicando-um-escopo-padrao"><a class="anchorlink" href="#aplicando-um-escopo-padrao">14.3 Aplicando um escopo padrão</a></h4><p>Se desejarmos que um escopo seja aplicado em todas as consultas do <em>model</em>, podemos usar o
método <code>default_scope</code> dentro do próprio <em>model</em>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Client</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="s2">"removed_at IS NULL"</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-143e0c495439d54fb41762b298aebc05">class Client &lt; ApplicationRecord
  default_scope { where("removed_at IS NULL") }
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-143e0c495439d54fb41762b298aebc05">Copiar</button>
</div>
<p>Quando as consultas são executadas neste <em>model</em>, a consulta SQL agora será semelhante a
isto:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">WHERE</span> <span class="n">removed_at</span> <span class="k">IS</span> <span class="k">NULL</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-1621e2826bcad29a9ad96bfa53eb4f11">SELECT * FROM clients WHERE removed_at IS NULL
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-1621e2826bcad29a9ad96bfa53eb4f11">Copiar</button>
</div>
<p>Se você precisa fazer coisas mais complexas com um escopo padrão, você pode alternativamente
defini-lo como um método de classe:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Client</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">default_scope</span>
    <span class="c1"># Should return an ActiveRecord::Relation.</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-9afd83e866f6245325c923d9de8eeed7">class Client &lt; ApplicationRecord
  def self.default_scope
    # Should return an ActiveRecord::Relation.
  end
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-9afd83e866f6245325c923d9de8eeed7">Copiar</button>
</div>
<div class="note"><p>O <code>default_scope</code> também é aplicado ao criar/construir um registro
quando os argumentos do escopo são fornecidos como <code>Hash</code>. Não é aplicado enquanto
atualizando um registro. E.g.:</p></div><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Client</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">active: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>

<span class="no">Client</span><span class="p">.</span><span class="nf">new</span>          <span class="c1"># =&gt; #&lt;Client id: nil, active: true&gt;</span>
<span class="no">Client</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">new</span> <span class="c1"># =&gt; #&lt;Client id: nil, active: nil&gt;</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-ddb9a0769d02169459d171f07c886a30">class Client &lt; ApplicationRecord
  default_scope { where(active: true) }
end

Client.new          # =&gt; #&lt;Client id: nil, active: true&gt;
Client.unscoped.new # =&gt; #&lt;Client id: nil, active: nil&gt;
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-ddb9a0769d02169459d171f07c886a30">Copiar</button>
</div>
<p>Esteja ciente de que, quando fornecido no formato <code>Array</code>, os argumentos de consulta <code>default_scope</code>
não pode ser convertido em <code>Hash</code> para atribuição de atributo padrão. E.g.:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Client</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="s2">"active = ?"</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>

<span class="no">Client</span><span class="p">.</span><span class="nf">new</span> <span class="c1"># =&gt; #&lt;Client id: nil, active: nil&gt;</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-a632ec6936c935670e3d53ffe2469abb">class Client &lt; ApplicationRecord
  default_scope { where("active = ?", true) }
end

Client.new # =&gt; #&lt;Client id: nil, active: nil&gt;
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-a632ec6936c935670e3d53ffe2469abb">Copiar</button>
</div>
<h4 id="mesclagem-de-escopos"><a class="anchorlink" href="#mesclagem-de-escopos">14.4 Mesclagem de escopos</a></h4><p>Assim como os escopos das cláusulas <code>where</code> são mesclados usando as condições <code>AND</code>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:active</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="ss">state: </span><span class="s1">'active'</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:inactive</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="ss">state: </span><span class="s1">'inactive'</span> <span class="p">}</span>
<span class="k">end</span>

<span class="no">User</span><span class="p">.</span><span class="nf">active</span><span class="p">.</span><span class="nf">inactive</span>
<span class="c1"># SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'inactive'</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-36197dccf07d24ede3c5e5d0bae712f2">class User &lt; ApplicationRecord
  scope :active, -&gt; { where state: 'active' }
  scope :inactive, -&gt; { where state: 'inactive' }
end

User.active.inactive
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'inactive'
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-36197dccf07d24ede3c5e5d0bae712f2">Copiar</button>
</div>
<p>Podemos misturar e combinar as condições <code>scope</code> e <code>where</code> e o sql final
terá todas as condições unidas com <code>AND</code>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">User</span><span class="p">.</span><span class="nf">active</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">state: </span><span class="s1">'finished'</span><span class="p">)</span>
<span class="c1"># SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'finished'</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-ccf8c27e0cebead5befb7dc99db3f2bc">User.active.where(state: 'finished')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'finished'
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-ccf8c27e0cebead5befb7dc99db3f2bc">Copiar</button>
</div>
<p>Se quisermos que a última cláusula <code>where</code> vença, então <code>Relation#merge</code> pode
ser usado.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">User</span><span class="p">.</span><span class="nf">active</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="no">User</span><span class="p">.</span><span class="nf">inactive</span><span class="p">)</span>
<span class="c1"># SELECT "users".* FROM "users" WHERE "users"."state" = 'inactive'</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-ed92ce513179ca2cd73fcd1ff35fb6b0">User.active.merge(User.inactive)
# SELECT "users".* FROM "users" WHERE "users"."state" = 'inactive'
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-ed92ce513179ca2cd73fcd1ff35fb6b0">Copiar</button>
</div>
<p>Uma advertência importante é que <code>default_scope</code> será anexado em
condições <code>scope</code> e <code>where</code>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">where</span> <span class="ss">state: </span><span class="s1">'pending'</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:active</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="ss">state: </span><span class="s1">'active'</span> <span class="p">}</span>
  <span class="n">scope</span> <span class="ss">:inactive</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="ss">state: </span><span class="s1">'inactive'</span> <span class="p">}</span>
<span class="k">end</span>

<span class="no">User</span><span class="p">.</span><span class="nf">all</span>
<span class="c1"># SELECT "users".* FROM "users" WHERE "users"."state" = 'pending'</span>

<span class="no">User</span><span class="p">.</span><span class="nf">active</span>
<span class="c1"># SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."state" = 'active'</span>

<span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">state: </span><span class="s1">'inactive'</span><span class="p">)</span>
<span class="c1"># SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."state" = 'inactive'</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-f3ce3b578491aa0e683f6bbb89a9e354">class User &lt; ApplicationRecord
  default_scope { where state: 'pending' }
  scope :active, -&gt; { where state: 'active' }
  scope :inactive, -&gt; { where state: 'inactive' }
end

User.all
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending'

User.active
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."state" = 'active'

User.where(state: 'inactive')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."state" = 'inactive'
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-f3ce3b578491aa0e683f6bbb89a9e354">Copiar</button>
</div>
<p>Como você pode ver acima, o <code>default_scope</code> está sendo mesclado em ambos
condições <code>scope</code> e <code>where</code>.</p><h4 id="removendo-todo-o-escopo"><a class="anchorlink" href="#removendo-todo-o-escopo">14.5 Removendo todo o escopo</a></h4><p>Se desejarmos remover o escopo por qualquer motivo, podemos usar o método <code>unscoped</code>. Isto é
especialmente útil se um <code>default_scope</code> é especificado no <em>model</em> e não deve ser
aplicado para esta consulta particular.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">load</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-63dbd7823d85b1390972b908d2e92b67">Client.unscoped.load
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-63dbd7823d85b1390972b908d2e92b67">Copiar</button>
</div>
<p>Este método remove todo o escopo e fará uma consulta normal na tabela.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">all</span>
<span class="c1"># SELECT "clients".* FROM "clients"</span>

<span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">published: </span><span class="kp">false</span><span class="p">).</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">all</span>
<span class="c1"># SELECT "clients".* FROM "clients"</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-b26fb911aafa78da1ad8d07cf37c08f0">Client.unscoped.all
# SELECT "clients".* FROM "clients"

Client.where(published: false).unscoped.all
# SELECT "clients".* FROM "clients"
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-b26fb911aafa78da1ad8d07cf37c08f0">Copiar</button>
</div>
<p><code>unscoped</code> também pode aceitar um bloqueio.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">unscoped</span> <span class="p">{</span>
  <span class="no">Client</span><span class="p">.</span><span class="nf">created_before</span><span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">zone</span><span class="p">.</span><span class="nf">now</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-e131304223a155f97e59036551d93466">Client.unscoped {
  Client.created_before(Time.zone.now)
}
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-e131304223a155f97e59036551d93466">Copiar</button>
</div>
<h3 id="localizadores-dinamicos"><a class="anchorlink" href="#localizadores-dinamicos">15 Localizadores Dinâmicos</a></h3><p>Para cada campo (também conhecido como atributo) que você define na sua tabela, o <em>Active Record</em> fornece um método localizador. Se você tiver um campo chamado <code>first_name</code> no seu <em>model</em> <code>Client</code> por exemplo, você terá de graça o método <code>find_by_first_name</code> fornecido pelo <em>Active Record</em>. Se você tiver o campo <code>locked</code> no seu <em>model</em> <code>Client</code>, você também receberá o método <code>find_by_locked</code>.</p><p>Você pode especificar o ponto de exclamação (<code>!</code>) no final de um localizador dinâmico para que ele levante um erro <code>ActiveRecord::RecordNotFound</code> caso não seja retornado nenhum registro, por exemplo <code>Client.find_by_name!("Ryan")</code></p><p>Se você deseja localizar por <em>name</em> e <em>locked</em>, você pode encadear esses localizadores juntos simplesmente digitando "<code>and</code>" entre os campos. Por exemplo, <code>Client.find_by_first_name_and_locked("Ryan", true)</code>.</p><h3 id="enums"><a class="anchorlink" href="#enums">16 Enums</a></h3><p>The <code>enum</code> macro maps an integer column to a set of possible values.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">enum</span> <span class="ss">availability: </span><span class="p">[</span><span class="ss">:available</span><span class="p">,</span> <span class="ss">:unavailable</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-6290455c73150e26bbc83e0d4e968f6f">class Book &lt; ApplicationRecord
  enum availability: [:available, :unavailable]
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-6290455c73150e26bbc83e0d4e968f6f">Copiar</button>
</div>
<p>This will automatically create the corresponding <a href="#scopes">scopes</a> to query the
model. Methods to transition between states and query the current state are also
added.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># Both examples below query just available books.</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">available</span>
<span class="c1"># or</span>
<span class="no">Book</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">availability: :available</span><span class="p">)</span>

<span class="n">book</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">availability: :available</span><span class="p">)</span>
<span class="n">book</span><span class="p">.</span><span class="nf">available?</span>   <span class="c1"># =&gt; true</span>
<span class="n">book</span><span class="p">.</span><span class="nf">unavailable!</span> <span class="c1"># =&gt; true</span>
<span class="n">book</span><span class="p">.</span><span class="nf">available?</span>   <span class="c1"># =&gt; false</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-15a75e7b0c70fe6bfdeafb6ac1497e99"># Both examples below query just available books.
Book.available
# or
Book.where(availability: :available)

book = Book.new(availability: :available)
book.available?   # =&gt; true
book.unavailable! # =&gt; true
book.available?   # =&gt; false
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-15a75e7b0c70fe6bfdeafb6ac1497e99">Copiar</button>
</div>
<p>Read the full documentation about enums
<a href="https://api.rubyonrails.org/v6.0.3.4/classes/ActiveRecord/Enum.html">in the Rails API docs</a>.</p><h3 id="entendendo-o-encadeamento-de-metodos"><a class="anchorlink" href="#entendendo-o-encadeamento-de-metodos">17 Entendendo o Encadeamento de Métodos</a></h3><p>O <em>Active Record</em> implementa o padrão <a href="https://en.wikipedia.org/wiki/Method_chaining">Encadeamento de Métodos</a>
(<em>method chaining</em>) que nos permite usar vários métodos do <em>Active Record</em> juntos de uma maneira simples e direta.</p><p>Você pode encadear métodos numa sentença quando o método chamado anteriormente retorna
uma <code>ActiveRecord::Relation</code>, como <code>all</code>, <code>where</code> e <code>joins</code>. Métodos que retornam um único objeto
(veja <a href="#retornando-um-unico-objeto">a seção Retornando um Único Objeto</a>) devem estar no fim da sentença.</p><p>Há alguns exemplos abaixo. Esse guia não vai mostrar todas as possibilidades, só alguns exemplos.
Quando um método <em>Active Record</em> é chamado, a consulta não é imediatamente gerada e enviada para o banco
de dados, isso só acontece quando os dados são realmente necessários. Logo, cada exemplo abaixo só gera
uma consulta.</p><h4 id="buscando-dados-filtrados-de-multiplas-tabelas"><a class="anchorlink" href="#buscando-dados-filtrados-de-multiplas-tabelas">17.1 Buscando dados filtrados de múltiplas tabelas</a></h4><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Person</span>
  <span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s1">'people.id, people.name, comments.text'</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:comments</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'comments.created_at &gt; ?'</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="nf">week</span><span class="p">.</span><span class="nf">ago</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-4cd8fc03c5ad07bcbb321df7bc2e55d0">Person
  .select('people.id, people.name, comments.text')
  .joins(:comments)
  .where('comments.created_at &gt; ?', 1.week.ago)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-4cd8fc03c5ad07bcbb321df7bc2e55d0">Copiar</button>
</div>
<p>O resultado deve ser algo parecido com isso:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">people</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">people</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">comments</span><span class="p">.</span><span class="nb">text</span>
<span class="k">FROM</span> <span class="n">people</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">comments</span>
  <span class="k">ON</span> <span class="n">comments</span><span class="p">.</span><span class="n">person_id</span> <span class="o">=</span> <span class="n">people</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">comments</span><span class="p">.</span><span class="n">created_at</span> <span class="o">&gt;</span> <span class="s1">'2015-01-01'</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-442a46f34d2c6130e5904c36c1b64803">SELECT people.id, people.name, comments.text
FROM people
INNER JOIN comments
  ON comments.person_id = people.id
WHERE comments.created_at &gt; '2015-01-01'
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-442a46f34d2c6130e5904c36c1b64803">Copiar</button>
</div>
<h4 id="buscando-dados-especificos-de-multiplas-tabelas"><a class="anchorlink" href="#buscando-dados-especificos-de-multiplas-tabelas">17.2 Buscando dados específicos de múltiplas tabelas</a></h4><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Person</span>
  <span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s1">'people.id, people.name, companies.name'</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:company</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="s1">'people.name'</span> <span class="o">=&gt;</span> <span class="s1">'John'</span><span class="p">)</span> <span class="c1"># this should be the last</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-c231ec2827fb417532b8b56555f3c81d">Person
  .select('people.id, people.name, companies.name')
  .joins(:company)
  .find_by('people.name' =&gt; 'John') # this should be the last
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-c231ec2827fb417532b8b56555f3c81d">Copiar</button>
</div>
<p>O comando acima deve gerar:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">people</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">people</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">companies</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span> <span class="n">people</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">companies</span>
  <span class="k">ON</span> <span class="n">companies</span><span class="p">.</span><span class="n">person_id</span> <span class="o">=</span> <span class="n">people</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">people</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'John'</span>
<span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-2f24520c8b500889ff5a1d938b049138">SELECT people.id, people.name, companies.name
FROM people
INNER JOIN companies
  ON companies.person_id = people.id
WHERE people.name = 'John'
LIMIT 1
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-2f24520c8b500889ff5a1d938b049138">Copiar</button>
</div>
<div class="note"><p>Note que se uma consulta trouxer múltiplos registros, o
método <code>find_by</code> irá retornar somente o primeiro e ignorar o
restante (perceba a sentença <code>LIMIT 1</code> acima).</p></div><h3 id="encontrando-ou-construindo-um-novo-objeto"><a class="anchorlink" href="#encontrando-ou-construindo-um-novo-objeto">18 Encontrando ou Construindo um Novo Objeto</a></h3><p>É comum que você precise localizar um registro ou criá-lo se ele não existir. Você pode fazer isso com os métodos <code>find_or_create_by</code> e <code>find_or_create_by!</code>.</p><h4 id="find-or-create-by"><a class="anchorlink" href="#find-or-create-by">18.1 <code>find_or_create_by</code></a></h4><p>O método <code>find_or_create_by</code> verifica se existe um registro com os atributos especificados. Se não, então <code>create</code> é chamado. Vejamos um exemplo.</p><p>Suponha que você queira encontrar um cliente chamado 'Andy' e, se não houver nenhum, crie um. Você pode fazer isso executando:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Andy'</span><span class="p">)</span>
<span class="c1"># =&gt; #&lt;Client id: 1, first_name: "Andy", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27"&gt;</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-79825900f642a83e9ea190ed3e7a6598">Client.find_or_create_by(first_name: 'Andy')
# =&gt; #&lt;Client id: 1, first_name: "Andy", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27"&gt;
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-79825900f642a83e9ea190ed3e7a6598">Copiar</button>
</div>
<p>O SQL gerado por esse método parece com isso:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">clients</span><span class="p">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Andy'</span><span class="p">)</span> <span class="k">LIMIT</span> <span class="mi">1</span>
<span class="k">BEGIN</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">clients</span> <span class="p">(</span><span class="n">created_at</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">locked</span><span class="p">,</span> <span class="n">orders_count</span><span class="p">,</span> <span class="n">updated_at</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'2011-08-30 05:22:57'</span><span class="p">,</span> <span class="s1">'Andy'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">NULL</span><span class="p">,</span> <span class="s1">'2011-08-30 05:22:57'</span><span class="p">)</span>
<span class="k">COMMIT</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-763f654a35e4af271105bcc6557de871">SELECT * FROM clients WHERE (clients.first_name = 'Andy') LIMIT 1
BEGIN
INSERT INTO clients (created_at, first_name, locked, orders_count, updated_at) VALUES ('2011-08-30 05:22:57', 'Andy', 1, NULL, '2011-08-30 05:22:57')
COMMIT
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-763f654a35e4af271105bcc6557de871">Copiar</button>
</div>
<p><code>find_or_create_by</code> retorna o registro que já existe ou o novo registro. Em nosso caso, ainda não tínhamos um cliente chamado Andy, então o registro é criado e retornado.</p><p>O novo registro pode não ser salvo no banco de dados; isso depende se as validações foram aprovadas ou não (assim como <code>create</code>).</p><p>Suponha que queremos definir o atributo 'bloqueado (<em>locked</em>)' para <code>false</code> se estamos
criando um novo registro, mas não queremos incluí-lo na consulta. Então
queremos encontrar o cliente chamado "Andy", ou se esse cliente não
existir, crie um cliente chamado "Andy" que não esteja bloqueado.</p><p>Podemos conseguir isso de duas maneiras. A primeira é usar <code>create_with</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">create_with</span><span class="p">(</span><span class="ss">locked: </span><span class="kp">false</span><span class="p">).</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Andy'</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-55238309bd8cecc3e6fdb50e64ecd1ac">Client.create_with(locked: false).find_or_create_by(first_name: 'Andy')
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-55238309bd8cecc3e6fdb50e64ecd1ac">Copiar</button>
</div>
<p>A segunda maneira é usar um bloco:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">find_or_create_by</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Andy'</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
  <span class="n">c</span><span class="p">.</span><span class="nf">locked</span> <span class="o">=</span> <span class="kp">false</span>
<span class="k">end</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-dcc7e189387aa813dbf48c0ecdb0af7e">Client.find_or_create_by(first_name: 'Andy') do |c|
  c.locked = false
end
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-dcc7e189387aa813dbf48c0ecdb0af7e">Copiar</button>
</div>
<p>O bloco só será executado se o cliente estiver sendo criado. A segunda vez que rodarmos este código, o todo o bloco será ignorado.</p><h4 id="find-or-create-by-bang"><a class="anchorlink" href="#find-or-create-by-bang">18.2 <code>find_or_create_by!</code></a></h4><p>Você também pode usar <code>find_or_create_by!</code> Você também pode usar <code>find_or_create_by!</code> para gerar uma exceção se o novo registro for inválido. As validações não são abordadas neste guia, mas vamos supor por um momento que você adiciona temporariamente</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">validates</span> <span class="ss">:orders_count</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-a6df078ba6ab43bae95a9137e66e2cbf">validates :orders_count, presence: true
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-a6df078ba6ab43bae95a9137e66e2cbf">Copiar</button>
</div>
<p>ao seu <em>model</em> <code>Client</code>. Se você tentar criar um novo <code>Client</code> sem passar <code>orders_count</code>, o registro será inválido e uma exceção será levantada:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">find_or_create_by!</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Andy'</span><span class="p">)</span>
<span class="c1"># =&gt; ActiveRecord::RecordInvalid: Validation failed: Orders count can't be blank</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-506c75490c0588008f90ade73bb373ee">Client.find_or_create_by!(first_name: 'Andy')
# =&gt; ActiveRecord::RecordInvalid: Validation failed: Orders count can't be blank
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-506c75490c0588008f90ade73bb373ee">Copiar</button>
</div>
<h4 id="find-or-initialize-by"><a class="anchorlink" href="#find-or-initialize-by">18.3 <code>find_or_initialize_by</code></a></h4><p>O método <code>find_or_initialize_by</code> funcionará como o
<code>find_or_create_by</code> mas chamará <code>new</code> ao invés de <code>create</code>. Isso significa que uma nova instância do <em>model</em> será criada na memória, mas não será salva no banco de dados. Continuando com o exemplo <code>find_or_create_by</code>, agora queremos o cliente chamado 'Nick':</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">nick</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">find_or_initialize_by</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Nick'</span><span class="p">)</span>
<span class="c1"># =&gt; #&lt;Client id: nil, first_name: "Nick", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27"&gt;</span>

<span class="n">nick</span><span class="p">.</span><span class="nf">persisted?</span>
<span class="c1"># =&gt; false</span>

<span class="n">nick</span><span class="p">.</span><span class="nf">new_record?</span>
<span class="c1"># =&gt; true</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-3a39aa349a08fdeccad69213702fc5df">nick = Client.find_or_initialize_by(first_name: 'Nick')
# =&gt; #&lt;Client id: nil, first_name: "Nick", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27"&gt;

nick.persisted?
# =&gt; false

nick.new_record?
# =&gt; true
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-3a39aa349a08fdeccad69213702fc5df">Copiar</button>
</div>
<p>Como o objeto ainda não está armazenado no banco de dados, o SQL gerado tem a seguinte aparência:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">clients</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">clients</span><span class="p">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Nick'</span><span class="p">)</span> <span class="k">LIMIT</span> <span class="mi">1</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-c55268f13c89ec1c9fd91fcee39b7476">SELECT * FROM clients WHERE (clients.first_name = 'Nick') LIMIT 1
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-c55268f13c89ec1c9fd91fcee39b7476">Copiar</button>
</div>
<p>Quando você quiser salvar no banco, apenas chame <code>save</code>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="n">nick</span><span class="p">.</span><span class="nf">save</span>
<span class="c1"># =&gt; true</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-ce18eb79f67555f1428f3df7b98cd365">nick.save
# =&gt; true
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-ce18eb79f67555f1428f3df7b98cd365">Copiar</button>
</div>
<h3 id="finding-by-sql"><a class="anchorlink" href="#finding-by-sql">19 Finding by SQL</a></h3><p>If you'd like to use your own SQL to find records in a table you can use <code>find_by_sql</code>. The <code>find_by_sql</code> method will return an array of objects even if the underlying query returns just a single record. For example you could run this query:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">find_by_sql</span><span class="p">(</span><span class="s2">"SELECT * FROM clients
  INNER JOIN orders ON clients.id = orders.client_id
  ORDER BY clients.created_at desc"</span><span class="p">)</span>
<span class="c1"># =&gt;  [</span>
<span class="c1">#   #&lt;Client id: 1, first_name: "Lucas" &gt;,</span>
<span class="c1">#   #&lt;Client id: 2, first_name: "Jan" &gt;,</span>
<span class="c1">#   ...</span>
<span class="c1"># ]</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-523020c36af56c46205b81a01426338c">Client.find_by_sql("SELECT * FROM clients
  INNER JOIN orders ON clients.id = orders.client_id
  ORDER BY clients.created_at desc")
# =&gt;  [
#   #&lt;Client id: 1, first_name: "Lucas" &gt;,
#   #&lt;Client id: 2, first_name: "Jan" &gt;,
#   ...
# ]
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-523020c36af56c46205b81a01426338c">Copiar</button>
</div>
<p><code>find_by_sql</code> provides you with a simple way of making custom calls to the database and retrieving instantiated objects.</p><h4 id="select-all"><a class="anchorlink" href="#select-all">19.1 <code>select_all</code></a></h4><p><code>find_by_sql</code> has a close relative called <code>connection#select_all</code>. <code>select_all</code> will retrieve
objects from the database using custom SQL just like <code>find_by_sql</code> but will not instantiate them.
This method will return an instance of <code>ActiveRecord::Result</code> class and calling <code>to_a</code> on this
object would return you an array of hashes where each hash indicates a record.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">connection</span><span class="p">.</span><span class="nf">select_all</span><span class="p">(</span><span class="s2">"SELECT first_name, created_at FROM clients WHERE id = '1'"</span><span class="p">).</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#   {"first_name"=&gt;"Rafael", "created_at"=&gt;"2012-11-10 23:23:45.281189"},</span>
<span class="c1">#   {"first_name"=&gt;"Eileen", "created_at"=&gt;"2013-12-09 11:22:35.221282"}</span>
<span class="c1"># ]</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-c1d0c6ceebf5badc7297f9fb20eddf73">Client.connection.select_all("SELECT first_name, created_at FROM clients WHERE id = '1'").to_a
# =&gt; [
#   {"first_name"=&gt;"Rafael", "created_at"=&gt;"2012-11-10 23:23:45.281189"},
#   {"first_name"=&gt;"Eileen", "created_at"=&gt;"2013-12-09 11:22:35.221282"}
# ]
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-c1d0c6ceebf5badc7297f9fb20eddf73">Copiar</button>
</div>
<h4 id="pluck"><a class="anchorlink" href="#pluck">19.2 <code>pluck</code></a></h4><p><code>pluck</code> can be used to query single or multiple columns from the underlying table of a model. It accepts a list of column names as argument and returns an array of values of the specified columns with the corresponding data type.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">active: </span><span class="kp">true</span><span class="p">).</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
<span class="c1"># SELECT id FROM clients WHERE active = 1</span>
<span class="c1"># =&gt; [1, 2, 3]</span>

<span class="no">Client</span><span class="p">.</span><span class="nf">distinct</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:role</span><span class="p">)</span>
<span class="c1"># SELECT DISTINCT role FROM clients</span>
<span class="c1"># =&gt; ['admin', 'member', 'guest']</span>

<span class="no">Client</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:name</span><span class="p">)</span>
<span class="c1"># SELECT clients.id, clients.name FROM clients</span>
<span class="c1"># =&gt; [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-0b2db40316978cd0ebeb11f93d42e8cc">Client.where(active: true).pluck(:id)
# SELECT id FROM clients WHERE active = 1
# =&gt; [1, 2, 3]

Client.distinct.pluck(:role)
# SELECT DISTINCT role FROM clients
# =&gt; ['admin', 'member', 'guest']

Client.pluck(:id, :name)
# SELECT clients.id, clients.name FROM clients
# =&gt; [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-0b2db40316978cd0ebeb11f93d42e8cc">Copiar</button>
</div>
<p><code>pluck</code> makes it possible to replace code like:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="n">c</span><span class="p">.</span><span class="nf">id</span> <span class="p">}</span>
<span class="c1"># or</span>
<span class="no">Client</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:id</span><span class="p">)</span>
<span class="c1"># or</span>
<span class="no">Client</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:name</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="p">[</span><span class="n">c</span><span class="p">.</span><span class="nf">id</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="nf">name</span><span class="p">]</span> <span class="p">}</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-1f9692163ee1d051e2c42729af82fe8a">Client.select(:id).map { |c| c.id }
# or
Client.select(:id).map(&amp;:id)
# or
Client.select(:id, :name).map { |c| [c.id, c.name] }
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-1f9692163ee1d051e2c42729af82fe8a">Copiar</button>
</div>
<p>with:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
<span class="c1"># or</span>
<span class="no">Client</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:name</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-0f585ff3e67115f8a9d78e0d11248efe">Client.pluck(:id)
# or
Client.pluck(:id, :name)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-0f585ff3e67115f8a9d78e0d11248efe">Copiar</button>
</div>
<p>Unlike <code>select</code>, <code>pluck</code> directly converts a database result into a Ruby <code>Array</code>,
without constructing <code>ActiveRecord</code> objects. This can mean better performance for
a large or often-running query. However, any model method overrides will
not be available. For example:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Client</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="k">def</span> <span class="nf">name</span>
    <span class="s2">"I am </span><span class="si">#{</span><span class="k">super</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Client</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:name</span><span class="p">).</span><span class="nf">map</span> <span class="o">&amp;</span><span class="ss">:name</span>
<span class="c1"># =&gt; ["I am David", "I am Jeremy", "I am Jose"]</span>

<span class="no">Client</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>
<span class="c1"># =&gt; ["David", "Jeremy", "Jose"]</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-649b3a5e1afbe33897c848d2e4216fe1">class Client &lt; ApplicationRecord
  def name
    "I am #{super}"
  end
end

Client.select(:name).map &amp;:name
# =&gt; ["I am David", "I am Jeremy", "I am Jose"]

Client.pluck(:name)
# =&gt; ["David", "Jeremy", "Jose"]
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-649b3a5e1afbe33897c848d2e4216fe1">Copiar</button>
</div>
<p>You are not limited to querying fields from a single table, you can query multiple tables as well.</p><div class="code_container">
<pre><code class="highlight plaintext">Client.joins(:comments, :categories).pluck("clients.email, comments.title, categories.name")
</code></pre>
<textarea class="clipboard-content" id="clipboard-a1c9da0c72c1bb3cbea8cb7367e1d5bd">Client.joins(:comments, :categories).pluck("clients.email, comments.title, categories.name")
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-a1c9da0c72c1bb3cbea8cb7367e1d5bd">Copiar</button>
</div>
<p>Furthermore, unlike <code>select</code> and other <code>Relation</code> scopes, <code>pluck</code> triggers an immediate
query, and thus cannot be chained with any further scopes, although it can work with
scopes already constructed earlier:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:name</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># =&gt; NoMethodError: undefined method `limit' for #&lt;Array:0x007ff34d3ad6d8&gt;</span>

<span class="no">Client</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>
<span class="c1"># =&gt; ["David"]</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-05c0b036ff9ee0f3cc7911c13fcb9853">Client.pluck(:name).limit(1)
# =&gt; NoMethodError: undefined method `limit' for #&lt;Array:0x007ff34d3ad6d8&gt;

Client.limit(1).pluck(:name)
# =&gt; ["David"]
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-05c0b036ff9ee0f3cc7911c13fcb9853">Copiar</button>
</div>
<h4 id="ids"><a class="anchorlink" href="#ids">19.3 <code>ids</code></a></h4><p><code>ids</code> can be used to pluck all the IDs for the relation using the table's primary key.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Person</span><span class="p">.</span><span class="nf">ids</span>
<span class="c1"># SELECT id FROM people</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-5abe9c9420d86326c19768944800d83f">Person.ids
# SELECT id FROM people
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-5abe9c9420d86326c19768944800d83f">Copiar</button>
</div>
<div class="code_container">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Person</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">primary_key</span> <span class="o">=</span> <span class="s2">"person_id"</span>
<span class="k">end</span>

<span class="no">Person</span><span class="p">.</span><span class="nf">ids</span>
<span class="c1"># SELECT person_id FROM people</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-66b8df1edc615548a320bf7b8802a716">class Person &lt; ApplicationRecord
  self.primary_key = "person_id"
end

Person.ids
# SELECT person_id FROM people
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-66b8df1edc615548a320bf7b8802a716">Copiar</button>
</div>
<h3 id="existencia-de-objetos"><a class="anchorlink" href="#existencia-de-objetos">20 Existência de Objetos</a></h3><p>Se você simplesmente quer checar a existência do objeto, existe um método chamado <code>exists?</code>.
Este método irá consultar o banco de dados usando a mesma consulta que <code>find</code>, mas ao invés de retornar um objeto ou uma coleção de objetos, irá retornar <code>true</code> ou <code>false</code>.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-31bd10ae02701a44abc02aa2074c314e">Client.exists?(1)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-31bd10ae02701a44abc02aa2074c314e">Copiar</button>
</div>
<p>O método <code>exists?</code> também assume valores múltiplos, mas o problema é que retornará <code>true</code> se algum desses registros existirem.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(</span><span class="ss">id: </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="c1"># or</span>
<span class="no">Client</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(</span><span class="ss">name: </span><span class="p">[</span><span class="s1">'John'</span><span class="p">,</span> <span class="s1">'Sergei'</span><span class="p">])</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-0938121a7de60850f1c02748cc9bea29">Client.exists?(id: [1,2,3])
# or
Client.exists?(name: ['John', 'Sergei'])
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-0938121a7de60850f1c02748cc9bea29">Copiar</button>
</div>
<p>É até possível usar <code>exists?</code> sem algum argumento em um <em>model</em> ou relação.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Ryan'</span><span class="p">).</span><span class="nf">exists?</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-e28e218a88f78a2cbc2972054cc17007">Client.where(first_name: 'Ryan').exists?
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-e28e218a88f78a2cbc2972054cc17007">Copiar</button>
</div>
<p>O código acima retorna <code>true</code> se existir ao menos um cliente com o <code>first_name</code> 'Ryan' e <code>false</code> caso não exista.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">exists?</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-b9dbb7b58378f3dca42af5a7b177c1b8">Client.exists?
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-b9dbb7b58378f3dca42af5a7b177c1b8">Copiar</button>
</div>
<p>O código acima retorna <code>false</code> se a tabela <code>clients</code> estiver vazia e <code>true</code> caso não esteja.</p><p>Você também pode usar <code>any?</code> e <code>many?</code> para verificar a existência de um <em>model</em> ou relação.</p><div class="code_container">
<pre><code class="highlight ruby"><span class="c1"># via a model</span>
<span class="no">Article</span><span class="p">.</span><span class="nf">any?</span>
<span class="no">Article</span><span class="p">.</span><span class="nf">many?</span>

<span class="c1"># via a named scope</span>
<span class="no">Article</span><span class="p">.</span><span class="nf">recent</span><span class="p">.</span><span class="nf">any?</span>
<span class="no">Article</span><span class="p">.</span><span class="nf">recent</span><span class="p">.</span><span class="nf">many?</span>

<span class="c1"># via a relation</span>
<span class="no">Article</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">published: </span><span class="kp">true</span><span class="p">).</span><span class="nf">any?</span>
<span class="no">Article</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">published: </span><span class="kp">true</span><span class="p">).</span><span class="nf">many?</span>

<span class="c1"># via an association</span>
<span class="no">Article</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">categories</span><span class="p">.</span><span class="nf">any?</span>
<span class="no">Article</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">categories</span><span class="p">.</span><span class="nf">many?</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-280225d3016ff105b9dc6f2f276b3e7a"># via a model
Article.any?
Article.many?

# via a named scope
Article.recent.any?
Article.recent.many?

# via a relation
Article.where(published: true).any?
Article.where(published: true).many?

# via an association
Article.first.categories.any?
Article.first.categories.many?
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-280225d3016ff105b9dc6f2f276b3e7a">Copiar</button>
</div>
<h3 id="calculos"><a class="anchorlink" href="#calculos">21 Cálculos</a></h3><p>Essa seção usa <em>count</em> como exemplo de método nessa introdução, mas as opções descritas se aplicam para todas as
subseções.</p><p>Todos os métodos de cálculo funcionam diretamente em um <em>model</em>:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">count</span>
<span class="c1"># SELECT COUNT(*) FROM clients</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-c3c77f79785d37142d7e567e97289b26">Client.count
# SELECT COUNT(*) FROM clients
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-c3c77f79785d37142d7e567e97289b26">Copiar</button>
</div>
<p>Ou em uma relação:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Ryan'</span><span class="p">).</span><span class="nf">count</span>
<span class="c1"># SELECT COUNT(*) FROM clients WHERE (first_name = 'Ryan')</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-e2c14ec0307e6172cd8269c24bac7692">Client.where(first_name: 'Ryan').count
# SELECT COUNT(*) FROM clients WHERE (first_name = 'Ryan')
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-e2c14ec0307e6172cd8269c24bac7692">Copiar</button>
</div>
<p>Você também pode utilizar vários métodos de busca em uma relação para fazer cálculos complexos:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="s2">"orders"</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Ryan'</span><span class="p">,</span> <span class="ss">orders: </span><span class="p">{</span> <span class="ss">status: </span><span class="s1">'received'</span> <span class="p">}).</span><span class="nf">count</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-f20957e30821905dbdfdfe55da00d806">Client.includes("orders").where(first_name: 'Ryan', orders: { status: 'received' }).count
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-f20957e30821905dbdfdfe55da00d806">Copiar</button>
</div>
<p>O que vai executar:</p><div class="code_container">
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">clients</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">clients</span>
  <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">orders</span> <span class="k">ON</span> <span class="n">orders</span><span class="p">.</span><span class="n">client_id</span> <span class="o">=</span> <span class="n">clients</span><span class="p">.</span><span class="n">id</span>
  <span class="k">WHERE</span> <span class="p">(</span><span class="n">clients</span><span class="p">.</span><span class="n">first_name</span> <span class="o">=</span> <span class="s1">'Ryan'</span> <span class="k">AND</span> <span class="n">orders</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="s1">'received'</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-29034452e9c92a78fb4a2ab1dbab4b9a">SELECT COUNT(DISTINCT clients.id) FROM clients
  LEFT OUTER JOIN orders ON orders.client_id = clients.id
  WHERE (clients.first_name = 'Ryan' AND orders.status = 'received')
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-29034452e9c92a78fb4a2ab1dbab4b9a">Copiar</button>
</div>
<h4 id="contar-count"><a class="anchorlink" href="#contar-count">21.1 Contar (<em>count</em>)</a></h4><p>Se você quiser saber quantos registros estão na tabela do seu <em>model</em> você pode chamar <code>Client.count</code> e isso vai retornar um número.
Se você quiser ser mais específico e encontrar todos os clientes que tem idade presente no banco de dados, você pode utilizar
<code>Client.count(:age)</code></p><p>Para mais opções, veja a seção pai, <a href="#calculos">Cálculos</a>.</p><h4 id="media-average"><a class="anchorlink" href="#media-average">21.2 Média (<em>average</em>)</a></h4><p>Se você quiser saber a média de um certo número em uma das suas tabelas, você pode chamar o método <code>average</code>
na sua classe que se relaciona com essa tabela. Essa chamada de método vai parecer desse jeito:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">average</span><span class="p">(</span><span class="s2">"orders_count"</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-0a808e2e97013562be2dc34b1fb1bd84">Client.average("orders_count")
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-0a808e2e97013562be2dc34b1fb1bd84">Copiar</button>
</div>
<p>Isso vai retornar um número (possivelmente um número de ponto flutuante como 3.14159265) representando o valor médio
desse campo.</p><p>Para mais opções, veja a seção pai, <a href="#calculos">Cálculos</a>.</p><h4 id="minimo-minimum"><a class="anchorlink" href="#minimo-minimum">21.3 Mínimo (<em>minimum</em>)</a></h4><p>Se você quiser encontrar o valor mínimo de um campo na sua tabela, você pode chamar o método <code>minimum</code>
na classe que se relaciona com a tabela. Essa chamada de método vai parecer desse jeito:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="s2">"age"</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-2533c8a2690abfc2b5e91c4cba43a542">Client.minimum("age")
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-2533c8a2690abfc2b5e91c4cba43a542">Copiar</button>
</div>
<p>Para mais opções, veja a seção pai, <a href="#calculos">Cálculos</a>.</p><h4 id="maximo-maximum"><a class="anchorlink" href="#maximo-maximum">21.4 Máximo (<em>maximum</em>)</a></h4><p>Se você quiser encontrar o valor máximo de um campo na sua tabela, você pode chamar o método <code>maximum</code>
na classe que se relaciona com a tabela. Essa chamada de método vai parecer desse jeito:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="s2">"age"</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-b11b634731c5d6b11d1fa5816c8bf8c4">Client.maximum("age")
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-b11b634731c5d6b11d1fa5816c8bf8c4">Copiar</button>
</div>
<p>Para mais opções, veja a seção pai, <a href="#calculos">Cálculos</a>.</p><h4 id="soma-sum"><a class="anchorlink" href="#soma-sum">21.5 Soma (<em>sum</em>)</a></h4><p>Se você quiser encontrar a soma de todos os registros na sua tabela, você pode chamar o método <code>sum</code>
na classe que se relaciona com a tabela. Essa chamada de método vai parecer desse jeito:</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">Client</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="s2">"orders_count"</span><span class="p">)</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-df8027b8eec3e970a69b6dd9d8b59acd">Client.sum("orders_count")
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-df8027b8eec3e970a69b6dd9d8b59acd">Copiar</button>
</div>
<p>Para mais opções, veja a seção pai, <a href="#calculos">Cálculos</a>.</p><h3 id="executando-o-explain"><a class="anchorlink" href="#executando-o-explain">22 Executando o EXPLAIN</a></h3><p>Você pode executar o <em>EXPLAIN</em> nas <em>queries</em> disparadas por relações. Por exemplo,</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:articles</span><span class="p">).</span><span class="nf">explain</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-0cdd7af90c575ea94c9a0a7e53ca9dce">User.where(id: 1).joins(:articles).explain
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-0cdd7af90c575ea94c9a0a7e53ca9dce">Copiar</button>
</div>
<p>pode produzir</p><div class="code_container">
<pre><code class="highlight plaintext">EXPLAIN for: SELECT `users`.* FROM `users` INNER JOIN `articles` ON `articles`.`user_id` = `users`.`id` WHERE `users`.`id` = 1
+----+-------------+----------+-------+---------------+
| id | select_type | table    | type  | possible_keys |
+----+-------------+----------+-------+---------------+
|  1 | SIMPLE      | users    | const | PRIMARY       |
|  1 | SIMPLE      | articles | ALL   | NULL          |
+----+-------------+----------+-------+---------------+
+---------+---------+-------+------+-------------+
| key     | key_len | ref   | rows | Extra       |
+---------+---------+-------+------+-------------+
| PRIMARY | 4       | const |    1 |             |
| NULL    | NULL    | NULL  |    1 | Using where |
+---------+---------+-------+------+-------------+

2 rows in set (0.00 sec)
</code></pre>
<textarea class="clipboard-content" id="clipboard-a546688ca55267b0dc854d47676804a4">EXPLAIN for: SELECT `users`.* FROM `users` INNER JOIN `articles` ON `articles`.`user_id` = `users`.`id` WHERE `users`.`id` = 1
+----+-------------+----------+-------+---------------+
| id | select_type | table    | type  | possible_keys |
+----+-------------+----------+-------+---------------+
|  1 | SIMPLE      | users    | const | PRIMARY       |
|  1 | SIMPLE      | articles | ALL   | NULL          |
+----+-------------+----------+-------+---------------+
+---------+---------+-------+------+-------------+
| key     | key_len | ref   | rows | Extra       |
+---------+---------+-------+------+-------------+
| PRIMARY | 4       | const |    1 |             |
| NULL    | NULL    | NULL  |    1 | Using where |
+---------+---------+-------+------+-------------+

2 rows in set (0.00 sec)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-a546688ca55267b0dc854d47676804a4">Copiar</button>
</div>
<p>em MySQL e MariaDB.</p><p>O <em>Active Record</em> exibe uma impressão que simula a do <em>shell</em> do banco de dados correspondente. Então, a mesma <em>query</em> sendo executada quando usado o adaptador de PostgreSQL poderá produzir o seguinte:</p><div class="code_container">
<pre><code class="highlight plaintext">EXPLAIN for: SELECT "users".* FROM "users" INNER JOIN "articles" ON "articles"."user_id" = "users"."id" WHERE "users"."id" = 1
                                  QUERY PLAN
------------------------------------------------------------------------------
 Nested Loop Left Join  (cost=0.00..37.24 rows=8 width=0)
   Join Filter: (articles.user_id = users.id)
   -&gt;  Index Scan using users_pkey on users  (cost=0.00..8.27 rows=1 width=4)
         Index Cond: (id = 1)
   -&gt;  Seq Scan on articles  (cost=0.00..28.88 rows=8 width=4)
         Filter: (articles.user_id = 1)
(6 rows)
</code></pre>
<textarea class="clipboard-content" id="clipboard-dddc7be19b31fcc4aedfd2a14f10f082">EXPLAIN for: SELECT "users".* FROM "users" INNER JOIN "articles" ON "articles"."user_id" = "users"."id" WHERE "users"."id" = 1
                                  QUERY PLAN
------------------------------------------------------------------------------
 Nested Loop Left Join  (cost=0.00..37.24 rows=8 width=0)
   Join Filter: (articles.user_id = users.id)
   -&gt;  Index Scan using users_pkey on users  (cost=0.00..8.27 rows=1 width=4)
         Index Cond: (id = 1)
   -&gt;  Seq Scan on articles  (cost=0.00..28.88 rows=8 width=4)
         Filter: (articles.user_id = 1)
(6 rows)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-dddc7be19b31fcc4aedfd2a14f10f082">Copiar</button>
</div>
<p>O <em>Eager Loading</em> pode disparar mais que uma <em>query</em> por debaixo dos panos,
e algumas <em>queries</em> podem necessitar de resultados prévios. Por causa disso,
o <code>explain</code> na verdade executa a <em>query</em> e somente depois solicita o que a <em>query</em> planeja.
Por exemplo,</p><div class="code_container">
<pre><code class="highlight ruby"><span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="mi">1</span><span class="p">).</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:articles</span><span class="p">).</span><span class="nf">explain</span>
</code></pre>
<textarea class="clipboard-content" id="clipboard-78801e58dbd001e9c89d055eb664e2ce">User.where(id: 1).includes(:articles).explain
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-78801e58dbd001e9c89d055eb664e2ce">Copiar</button>
</div>
<p>produz</p><div class="code_container">
<pre><code class="highlight plaintext">EXPLAIN for: SELECT `users`.* FROM `users`  WHERE `users`.`id` = 1
+----+-------------+-------+-------+---------------+
| id | select_type | table | type  | possible_keys |
+----+-------------+-------+-------+---------------+
|  1 | SIMPLE      | users | const | PRIMARY       |
+----+-------------+-------+-------+---------------+
+---------+---------+-------+------+-------+
| key     | key_len | ref   | rows | Extra |
+---------+---------+-------+------+-------+
| PRIMARY | 4       | const |    1 |       |
+---------+---------+-------+------+-------+

1 row in set (0.00 sec)

EXPLAIN for: SELECT `articles`.* FROM `articles`  WHERE `articles`.`user_id` IN (1)
+----+-------------+----------+------+---------------+
| id | select_type | table    | type | possible_keys |
+----+-------------+----------+------+---------------+
|  1 | SIMPLE      | articles | ALL  | NULL          |
+----+-------------+----------+------+---------------+
+------+---------+------+------+-------------+
| key  | key_len | ref  | rows | Extra       |
+------+---------+------+------+-------------+
| NULL | NULL    | NULL |    1 | Using where |
+------+---------+------+------+-------------+


1 row in set (0.00 sec)
</code></pre>
<textarea class="clipboard-content" id="clipboard-4434d93f2d6fdd9a17fcfb0f49b7bc9d">EXPLAIN for: SELECT `users`.* FROM `users`  WHERE `users`.`id` = 1
+----+-------------+-------+-------+---------------+
| id | select_type | table | type  | possible_keys |
+----+-------------+-------+-------+---------------+
|  1 | SIMPLE      | users | const | PRIMARY       |
+----+-------------+-------+-------+---------------+
+---------+---------+-------+------+-------+
| key     | key_len | ref   | rows | Extra |
+---------+---------+-------+------+-------+
| PRIMARY | 4       | const |    1 |       |
+---------+---------+-------+------+-------+

1 row in set (0.00 sec)

EXPLAIN for: SELECT `articles`.* FROM `articles`  WHERE `articles`.`user_id` IN (1)
+----+-------------+----------+------+---------------+
| id | select_type | table    | type | possible_keys |
+----+-------------+----------+------+---------------+
|  1 | SIMPLE      | articles | ALL  | NULL          |
+----+-------------+----------+------+---------------+
+------+---------+------+------+-------------+
| key  | key_len | ref  | rows | Extra       |
+------+---------+------+------+-------------+
| NULL | NULL    | NULL |    1 | Using where |
+------+---------+------+------+-------------+


1 row in set (0.00 sec)
</textarea>
<button class="clipboard-button" data-clipboard-target="#clipboard-4434d93f2d6fdd9a17fcfb0f49b7bc9d">Copiar</button>
</div>
<p>em MySQL e MariaDB.</p><h4 id="interpretando-o-explain"><a class="anchorlink" href="#interpretando-o-explain">22.1 Interpretando o EXPLAIN</a></h4><p>A interpretação da saída do <em>EXPLAIN</em> está além do escopo deste guia. Os links
a seguir podem servir de ajuda:</p>
<ul>
<li><p>SQLite3: <a href="https://www.sqlite.org/eqp.html">EXPLAIN QUERY PLAN</a></p></li>
<li><p>MySQL: <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">EXPLAIN Output Format</a></p></li>
<li><p>MariaDB: <a href="https://mariadb.com/kb/en/mariadb/explain/">EXPLAIN</a></p></li>
<li><p>PostgreSQL: <a href="https://www.postgresql.org/docs/current/static/using-explain.html">Using EXPLAIN</a></p></li>
</ul>


        <h3>Feedback</h3>
        <p>
          Você é incentivado a ajudar a melhorar a qualidade deste guia.
        </p>
        <p>
          Por favor, contribua se vir qualquer erros, inclusive erros de digitação.
          Para começar, você pode ler nossa sessão de <a href="https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">contribuindo com a documentação</a>.
        </p>
        <p>
          Você também pode encontrar conteúdo incompleto ou coisas que não estão atualizadas.
          Por favor, adicione qualquer documentação em falta na master do Rails. Certifique-se de checar o
          <a href="http://edgeguides.rubyonrails.org">Edge Guides (en-US)</a> primeiro para verificar
          se o problema já foi resolvido ou não no branch master.
          Verifique as <a href="ruby_on_rails_guides_guidelines.html">Diretrizes do Guia Ruby on Rails</a>
          para estilo e convenções.
        </p>
        <p>
          Se, por qualquer motivo, você encontrar algo para consertar, mas não conseguir consertá-lo, por favor
          <a href="https://github.com/campuscode/rails-guides-pt-BR/issues">abra uma issue no nosso Guia</a>.
        </p>
        <p>
          E por último, mas não menos importante, qualquer tipo de discussão sobre a documentação do Ruby on Rails
          é muito bem vinda na <a href="https://discuss.rubyonrails.org/c/rubyonrails-docs">lista de discussão rubyonrails-docs</a> e nas
          <a href="https://github.com/campuscode/rails-guides-pt-BR/issues">issues do Guia em português</a>.
        </p>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p> Este projeto está licenciado sob uma licença <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International</a></p>
<p>"Rails", "Ruby on Rails", e o logotipo Rails são marcas comerciais de David Heinemeier Hansson. Todos os direitos reservados.</p>

    </div>
  </div>
</body>
</html>
